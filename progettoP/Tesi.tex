\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{empheq}
\usepackage{color}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\usepackage[all]{hypcap}
\usepackage{longtable}
\usepackage{array}
%\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}
\usepackage{tabularx}
\usepackage{caption}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{tipa}
\usepackage{pbox}
\usepackage{placeins}
\usepackage{adjustbox}

%\setmonofont{Consolas} %to be used with XeLaTeX or LuaLaTeX
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{blue(munsell)}{rgb}{0.0, 0.5, 0.69}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\setlength\parindent{0pt}

\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, get, set,string,false,true},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
extendedchars=true,
literate={à}{{\`a}}1 {è}{{\`e}}1 {ò}{{\`o}}1 {ù}{{\`u}}1 {é}{{\'e}}1,
}
\lstset%
{%
    emph=[1]%
    {%
        Process,
        Cplex,
        Program,
        IntParam,
        NumVarType,
        INumVar,
        SystemInformation,
        Param,
        Stopwatch,
        Instance,
        ProcessStartInfo,
        Point,
        ILinearNumExpr,
        List,
        PathGenetic,
        Random,
        ILinearNumExpr,
        TSPLazyConsCallback,
        StreamWriter,
        IRange,
        itemList,
        DoubleParam,
        Convert,
        StringSplitOptions
    },
    emphstyle=[1]{\color{blue(munsell)}},
}

\begin{document}

\section*{SEZIONE UNO}

Il presente progetto riguarda la progettazione di un software in grado di risolvere istanze del problema "Il Commesso Viaggiatore" applicando differenti algoritmi risolutori. L'obiettivo di questo testo è quello di descrivere le tecniche utilizzate e di confrontare i risultati ottenuti in termini di efficienza e bontà\`a della soluzione prodotta. Verrà\`a fornita una descrizione degli strumenti e l'ambiente di sviluppo utilizzati e sarà\`a analizzato il codice di programmazione realizzato; non mancheranno paragrafi dedicati ad approfondire concetti teorici senza i quali la comprensione del codice potrebbe risultare meno chiara. 

\subsection*{INTRODUZIONE}

Questa capitolo introduttivo \`e dedicato alla storia, alle applicazioni e correnti sfide riguardanti uno dei pi\`u importanti problemi che la disciplina di Ricerca Operativa si trova ad affrontare, ossia il problema del commesso viaggiatore(Travelling Salesman Problem -TSP). 
Il nome deriva dalla sua pi\`u tipica rappresentazione: data una rete di città\`a, connesse tramite delle strade, si vuole trovare il percorso di minore distanza che un commesso viaggiatore deve seguire per visitare tutte le città\`a una ed una sola volta e ritornare alla città\`a di partenza. Per quanto detto, risulta naturale modellare il TSP come un grafo pesato i cui nodi modellizzano le città\`a relative al problema in questione mentre i possibili collegamenti tra le località\`a sono modellati con gli archi del grafo i cui pesi possono rappresentare,per esempio, la distanza esistente fra la coppia di nodi collegati dall’arco. Chiaramente è possibile assegnare i pesi in modo arbitrario secondo le nostre esigenze, ad esempio si potrebbe anche tenere conto dei tempi di percorrenza o eventuali pedaggi presenti nei singoli percorsi. Come è facile immaginare, il TSP può essere quindi utilizzato per una infinità di problemi pratici ma anche teorici:\\
Il problema del commesso viaggiatore riveste un ruolo notevole nell'ambito di problemi di logistica distributiva, detti anche di routing. Questi riguardano l’organizzazione di sistemi di distribuzione di beni e servizi. Esempi di problemi di questo genere sono la movimentazione di pezzi o semilavorati tra reparti di produzione, la raccolta e distribuzione di materiali, lo smistamento di merci da centri di produzione a di distribuzione.
Sebbene le applicazioni nel contesto dei trasporti siano le più naturali per il TSP, la semplicità\`a del modello ha portato a molte applicazioni interessanti in altre aree. Un esempio può essere la programmazione di una macchina per eseguire fori in un circuito. In questo caso i fori da forare sono le città e il costo del viaggio è il tempo necessario per spostare la testa del trapano da un foro all'altro. 
Il problema del commesso viaggiatore risulta essere NP-hard: questo significa che, al momento, non è noto in letteratura un algoritmo che lo risolva in tempo polinomiale. Poiché\`e esiste sempre una istanza per cui il tempo di risoluzione cresce esponenzialmente non è sempre possibile utilizzare algoritmi esatti per risolvere il TPS. Risulta quindi necessario fornire algoritmi euristici, in grado di risolvere in modo efficace istanze con un numero elevato di nodi in tempi ragionevoli.


Problemi matematici riconducibili al TSP furono trattati nell'Ottocento dal matematico irlandese Sir William Rowan Hamilton e dal matematico Britannico Thomas Penyngton.  Nel 1857, a Dublino, Rowan Hamilton descrisse un gioco, detto Icosian game, a una riunione della British Association for the Advancement of Science. Il gioco consisteva nel trovare un percorso che toccasse tutti i vertici di un icosaedro, passando lungo gli spigoli, ma senza mai percorrere due volte lo stesso spigolo. L'icosaedro ha 12 vertici, 30 spigoli e 20 facce identiche a forma di triangolo equilatero.
Il gioco, venduto alla ditta J. Jacques and Sons per 25 sterline, fu brevettato a Londra nel 1859, ma vendette pochissimo. Questo problema \`e un TSP nel quale gli archi che collegano vertici adiacenti, e quindi corrispondono a spigoli dell'icosaedro, sono consentiti e gli altri no (si può pensare che richiedano moltissimo tempo e quindi vadano sicuramente scartati), per tale ragione si tratta di un caso molto particolare di TSP. La forma generale del TSP fu invece studiata solo negli anni Venti e Trenta del ventesimo secolo dal matematico ed economista Karl Menger. Tuttavia, per molto tempo non si ebbe altra idea che quella di generare e valutare tutte le soluzioni, il che mantenne il problema praticamente insolubile. Il numero totale dei differenti percorsi possibili attraverso le $n$ città\`a \`e facile da calcolare: data una città\`a di partenza, ci sono a disposizione $(n - 1)$ scelte per la seconda città\`a, $(n - 2)$ per la terza e così via. Il totale delle possibili scelte tra le quali cercare il percorso migliore in termini di costo \`e dunque $(n - 1)!$, ma dato che il problema ha simmetria, questo numero va diviso a metà. Insomma, date n città\`a, ci sono $\frac{(n-1)!}{2}$ percorsi che le collegano.

Solo nel 1954, George Dantzig, Ray Fulkerson e Selmer Johnson proposero un metodo più raffinato per risolvere il TSP  su un campione di $n = 49$ città\`a: queste rappresentavano le capitali degli Stati Uniti e il costo del percorso era calcolato in base alle distanze stradali. 

Nel 1962, Procter and Gamble bandì un concorso per 33 città\`a, nel 1977 fu bandito un concorso che collegasse le 120 principali città\`a della Germania Federale e la vittoria andò a Martin Gr\"otschel oggi Presidente del Konrad-Zuse-Zentrum f\"ur Informarionstechnik Berlin(ZIB) e docente presso la Technische Universit\"at Berlin(TUB).

Nel 1987  Padberg e Rinaldi riuscirono a completare il giro degli Stati Uniti attraverso 532 città\`a. Nello stesso periodo Groetschel e Holland trovarono il TSP ottimale per il giro del mondo che passava per 666 mete importanti. 
Nel 2001, Applegate, Bixby, Chvátal, and Cook trovarono la soluzione esatta a un problema di 15.112 città\`a tedesche, usando il metodo cutting plane, originariamente proposto nel 1954 da George Dantzig, Delbert Ray Fulkerson e Selmer Johnson. Il calcolo fu eseguito da una rete di 110 processori della Rice University e della Princeton University. Il tempo di elaborazione totale fu equivalente a 22,6 anni su un singolo processore Alpha a 500 MHz.
Sempre Applegate, Bixby, Chv\a`tal, Cook, e Helsgaun trovarono nel Maggio del 2004 il percorso ottimale di 24,978 città\`a della Svezia. 
Nel marzo 2005, il TSP riguardante la visita di tutti i 33.810 punti in una scheda di circuito fu risolto usando CONCORDE: fu trovato un percorso di 66.048.945 unità\`a, e provato che non poteva esisterne uno migliore. L'esecuzione richiese approssimativamente 15,7 anni CPU. 
Ai giorni nostri il risolutore Concorde per il problema del commesso viaggiatore è utilizzato per ottenere soluzioni ottime su tutte le 110 istanze della libreria TSPLIB; l' istanza con più nodi in assoluto ha 85,900 città\`a. 


\subsection*{AMBIENTE DI SVILUPPO: Cplex, Visual Studio e C\#}

Il progetto è stato sviluppato in ambiente Windows, in particolare il sistema operativo scelto è Windows 10.\\
Cplex è la componente principale del progetto, prima di procedere è perciò necessario assicurarsi per potervi interagire dall'IDE che si desidera utilizzare. Il nostro gruppo ha deciso di adottare come linguaggio di programmazione il \textbf{C\#}, successore del \textbf{C++} ed anch'esso orientato agli oggetti.\\
L'IDE più comune per chi desidera utilizzare tale linguaggio è senza dubbio \textbf{Visual Studio}, sviluppato dalla stessa Microsoft e distribuito gratuitamente. La versione utilizzata in questo progetto e dunque quella a cui si farà riferimento in questa guida è \textbf{Visual Studio Community 2017}. Una volta aperto l'installer reperibile al seguente \href{https://www.visualstudio.com/it/thank-you-downloading-visual-studio/?sku=Community&rel=15#}{indirizzo} è sufficiente installare i pacchetti \textbf{Sviluppo per desktop .NET} e \textbf{Sviluppo di applicazioni desktop con C++} (vedremo in seguito perché sono necessari pacchetti C++).\\
Una volta terminata l'installazione assicuriamoci di aver installare nella nostra macchina una versione di cplex pari o superiore alla \textbf{12.7.0}, quella da noi utilizzata è più precisamente la \textbf{12.7.0}.\\
A questo punto non ci rimane altro che creare il nostro progetto all'interno di Visual Studio e di collegarvi le apposite librerie di Cplex. Selezionare quindi dal menu a tendina \textbf{Visual C\#} e quindi \textbf{App console (.NET Framework)}, forniamo il nome e percorso che desideriamo:

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"Progetto C Sharp".png}
    \caption{Creazione progetto C Sharp}
\end{figure}

Per connettere Cplex al nostro progetto sono necessari i seguenti passaggi:

\begin{flushleft}
    \hyphenpenalty=10000
    \exhyphenpenalty=10000
    
    \begin{itemize}
        
        \item Selezionare la voce \textbf{Progetto} e quindi \textbf{Aggiungi riferimento...}
        
        \item Premere il pulsante \textbf{Sfoglia} e dopo essersi recati nella propria cartella di installazione di Cplex, in genere "C:\textbackslash Program Files\textbackslash IBM\textbackslash ILOG\textbackslash CPLEX\_Studio1271\textbackslash cplex" accedere alla sotto directory "\textbackslash bin\textbackslash x64\_win64" e selezionare i file \textbf{ILOG.CPLEX.dll} e \textbf{ILOG.Concert.dll}. Fatto ciò possiamo chiudere la finestra per la gestione dei riferimenti appena aperta
        
        \item Selezionare la voce \textbf{Compilazione} e quindi \textbf{Gestione configurazione..}, nella nuova finestra inserire nella voce  \textbf{Piattaforma} una nuova voce e selezionare \textbf{x64}. Per quanto riguarda la voce configurazione è indifferente selezionare la voce \textbf{Debug} oppure \textbf{Release}: come è facilmente intuibile nella prima modalità e differenza della seconda sarà possibile effettuare il classico debug con break points e gestione delle eccezioni a discapito di tempi di esecuzione leggermente più alti. Cogliamo quindi l'occasione per specificare che tutti i risultati proposti nel seguito di questo testo sono tutti stati ottenuti in modalità \textbf{Release} per il motivo indicato precedentemente.
        
    \end{itemize}
    
    
\end{flushleft}

A questo punto è possibile importare attraverso le direttive \textbf{using} sia \textbf{ILOG.CPLEX} che \textbf{ILOG.Concert}.

\subsection*{Creazione ed utilizzo DLL C/C++ }

In questa sezione viene spiegato come sia possibile utilizzare codice esterno, compilato anche in linguaggi differenti dal C\#, sotto forma di \textbf{DLL}. In particolare nel nostro caso si è presentata la necessità di poter utilizzare codice scritto in linguaggio C appartenente al programma Concorde.

La problematica principale con cui ci si scontra in questi casi è l'incompatibilità dei tipi, per noi questo è ancora più accentuato in quanto C al contrario di C\# non è un linguaggio orientato agli oggetti e l'interfaccia con Cplex segue un differente approccio. La soluzione migliore è stata quindi quella di passare al codice C solamente le informazioni fornite in input dall'utente e cioè il nome del file contenente i dati ed il time limit. In altre parole il codice C\# diventa solamente\footnote{In realtà mantiene anche un cronometro per il tempo di risoluzione} una interfaccia per richiamare la DLL, la quale dovrà gestire completamente la lettura dell'input, la risoluzione e la visualizzazione dei risultati\footnote{Tutte le stampe effettuate nella DLL vengono automaticamente reindirizzate nella finestra Console di default utilizzata dal C\#}.

Entriamo ora nel dettaglio della procedura da seguire:


\hyphenpenalty=10000
\exhyphenpenalty=10000

\begin{itemize}
    
    \item Prima di tutto da Visual Studio creiamo un nuovo progetto selezionando la voce \textbf{Visual C++} e quindi \textbf{Progetto Win32}. Nel caso in cui questa opzioni siano assenti significa che durante l'installazione di Visual Studio non sono stati selezionati i pacchetti C++, per maggiori dettagli seguire la procedura indicata nella sezione apposita.
    
    \item Nelle schermate successive è necessario selezionare l'opzione \textbf{DLL} come tipo di applicazione e \textbf{Progetto vuoto} come opzione aggiuntiva.
    
    \item A questo punto dovrebbe essersi creato il nostro nuovo e vuoto progetto, dal menu \textbf{Esplora soluzioni} nella cartella \textbf{File di origine} premiamo il tasto destro ed aggiungiamo un nuovo elemento. Selezioniamo dal menu \textbf{File di C++ (.cpp)}, assegniamo il nome che preferiamo e premiamo il tasto \textbf{Aggiungi}.
    
    \item A questo punto il file appena creato verrà compilato come codice \textbf{C++} ma Concorde utilizza \textbf{C} perciò per prima cosa dobbiamo inserire 
    \begin{lstlisting}
    extern "C"
    {
    }
    \end{lstlisting}
    In questo modo tutto il codice al suo interno viene compilato come \textbf{C}.
    
    \item Definiamo ora l'entry point per la nostra DLL che si tratta di un semplice metodo con prefisso \textbf{\_\_declspec(dllexport)}. Nel nostro caso si è deciso di utilizzare il metodo entry point come semplice interfaccia per la chiamata di un altro metodo che procederà alla reale risoluzione del problema:
    \begin{lstlisting}
    __declspec(dllexport) int Concorde(char *fileName, int timeLimit)
    {
        return exemain(strtok(fileName, "\0"), timeLimit);
    }
    \end{lstlisting}
    
    \item In modo analogo a come abbiamo appena creato questo file selezionando invece l'opzione per aggiungere file esistenti, importiamo tutti i file con estensione \textbf{.C} di cui necessitiamo da Concorde (maggiori dettagli riguardo quelli da noi utilizzati possono essere trovati nella sezione apposita).
    
    \item Settiamo ora le proprietà del progetto in modo tale che sia possibile utilizzare Cplex, diverse guide sono già disponibili e la procedura non viene qui riportata. In aggiunta è necessario selezionare nel sottomenù \textbf{C/C++ $\rightarrow$ Generale $\rightarrow$ Directory di inclusione aggiuntive} la cartella dove sono presenti i file \textbf{.h} di Concorde. 
    
    \item A questo punto non rimane altro che completare il nostro progetto inserendo i vari metodi necessari, maggiori dettagli nella sezione apposita. Fatto ciò siamo pronti a creare la DLL, dal menu \textbf{Compilazione} selezioniamo la voce \textbf{Compila soluzione} (assicuriamoci che nella barra degli strumenti sia selezionata la modalità release a 64 bit, in realtà è importante si utilizzino gli stessi bit che si adottano nel progetto originale). Terminata la compilazione la DLL si può trovare all'interno della cartella del progetto nella sottocartella \textbf{/x64/Release}.
    
    \item Posizioniamo la DLL all'interno della directory del nostro progetto C\# in particolare dentro \textbf{/bin/x64/Release} e \textbf{/bin/x64/Debug} per essere utilizzata nelle due modalità.
    
    \item Apriamo infine la classe del nostro progetto nella quale vogliamo utilizzare la DLL ed utilizziamo questo codice:
    \begin{lstlisting}
    [DllImport("ConcordeDLL.dll")]
    public static extern int Concorde(StringBuilder fileName, int timeLimit);
    \end{lstlisting} 
    Successivamente potremmo utilizzare il metodo esterno importato come se fosse stato definito all'interno della classe, nel nostro caso:
    \begin{lstlisting}
    Concorde(new StringBuilder(instance.InputFile), (int)instance.TimeLimit);
    \end{lstlisting}
    Da notare che la classe \textbf{StringBuilder} permette la conversione automatica del tipo \textbf{String} di C\# a \textbf{char*} di C.
    
\end{itemize}

\section*{SEZIONE DUE}

\subsection*{MODELLO MATEMATICO}

Nella sua formalizzazione più generale, il problema del Commesso Viaggiatore consiste nell'individuare un circuito hamiltoniano di costo minimo per un dato grafo orientato $G=(V,A)$, dove $V = $\{$ {v_1,\dots,v_n} $\}$ $ è un insieme di $n$ nodi e $A = $\{$ {(i,j): i, j \in V} $\}$ $ è un insieme di $m$ archi\footnote{Chiaramente sia $n$ che $m$ sono interi positivi}. 

Senza perdita di generalità, si suppone che il grafo $G$ sia completo e che il costo associato all'arco $[i,j]$, che indicheremo con $c\_{ij}$, sia non negativo. Si osserva che aver imposto $c\_{ij} \ge 0$ non è limitativo poichè è sempre possibile sommare a tutti i costi una costante sufficientemente elevata che li renda positivi senza alterarne l'ordinamento delle soluzioni. 
A differenza di quanto detto in precedenza, per tutto il proseguimento della tesi supporremmo il grafo $G$ non orientato: tale scelta deriva dal fatto che $c\_{ij}$ nel nostro lavoro rappresenta sempre la distanza (tipicamente euclidea) fra i vertici i e j si ha che:
$$c_{ij} = c_{ji}$$

ossia il costo associato ad un arco non dipende dalla direzione dell'arco stesso. Quando il grafo è non orientato la famiglia di coppie non ordinate di elementi di V, ossia l'insieme degli archi, viene indicato con $E$.


Definito il problema forniamo ora una sua possibile formulazione in termini di PLI. Introducendo le seguenti variabili decisionali:

\[
x_{e}=
\begin{cases}
1 & \text{se il lato $e \in E$ viene scelto nel circuito ottimo} \\
0 & \text{altrimenti}
\end{cases}
\]

si ottiene il problema:

\begin{eqnarray}
& \text{min}\displaystyle\underbrace{\sum_{e \in E} c_e x_e}\_{\text{costo circuito}} \\[1.5ex]
&\displaystyle\underbrace{\sum_{e \in \delta(V)} x_e = 2}_{\text{due lati incidenti in }v}\text{,  }\forall v \in V \\[1.5ex]
&0\leq x_e \leq 1 \text{ intera , }\forall e \in E
\end{eqnarray}

L' insieme di vincoli definiti dalla (2) vengono chiamati vincoli di grado e impongono che in ogni vertice incidano esattamente due lati. In questa forma il modello è  compatto dato che il numero di vincoli è polinomiale rispetto alla dimensione dell'istanza ma non è completo poichè è sprovvisto dei vincoli di subtour che impediscono soluzioni il cui grafo risulta non connesso.


\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"subtour".jpg}
    \caption{Soluzione con due subtour}
\end{figure}

\vspace{2\baselineskip}

Una possibile formulazione per l'eliminazione dei subtour, detta appunto \textbf{subtour elimination}, risulta essere:

\begin{eqnarray}
&\displaystyle{\sum_{e \in E(S)}x_e \geq 1} \text{ , } \forall S \subsetneq V \text{ : } 1 \in S \text{ , } |S| \geq 2
\end{eqnarray}


Il vincolo (4) indica che se si considera un sottoinsieme $S \subsetneq V$, che includa il vertice numerato con il simbolo 1, allora il taglio di G indotto da S:

\begin{center}
$\delta(S) = $\{$ {[i,j]\in E : i \in S, j \notin S} $\} $ $
\end{center}

deve contenere almeno un lato appartenente ad $E$: poichè tutti i subtour violano tale vincolo la soluzione ottima non potrà contenerne al suo interno.  
Essendo il numero di questi vincoli pari ai sottoinsiemi $S$ distinti, il numero di tali vincoli risulta esponenziale rispetto alla dimensione dell'istanza. In particolare il valore di $S$, dato un numero $n$ di nodi, è $2^n$: questo perchè associando un bit ad ogni vertice (il cui valore definisce se appartiene o meno al sottoinsieme) un qualsiasi sottoinsieme risulta identificato da una sequenza di $n$ bit è quindi possibile definirne $2^n$ distinti. In realtà avendo noi imposto che il vertice 1 appartenga sempre ad ogni $S$ e che $S \subsetneq V$, si ha che il numero di vincoli di subtour risulti pari a  $2^{n-1} - 1$.

Una seconda formulazione equivalente per esprimere i vincoli di subtour è la seguente:

\begin{eqnarray}
&\displaystyle{\sum_{e \in E(S)}x_e \leq |S| - 1} \text{ , } \forall S \subsetneq V \text{ , } |S| \geq 2
\end{eqnarray}

La gestione di un numero esponenziale di vincoli implica in genere tempi di risoluzione troppo elevati. Nella pratica però non è necessario utilizzare tutti i vincoli di subtour elimination, è sufficiente considerarne un numero molto più ridotto. Non potendo conoscere in anticipo quali siano quelli essenziali sarà nostro compito progettare un opportuno separatore: ossia una funzione che fornita in ingresso una soluzione x* ottima per il modello corrente generi tutti i vincoli violati.

\subsection*{INPUT FILE}

Le istanze del problema del Commesso Viaggiatore fornite in input al programma sono state selezionata da un libreria presente al seguente indirizzo web: 

\begin{center}
\href{http://elib.zib.de/pub/mp-testdata/tsp/tsplib/tsp/index.html}{http://elib.zib.de/pub/mp-testdata/tsp/tsplib/tsp/index.html}
\end{center}

Ogni istanza è memorizzata in un file di testo in un formato ben preciso, è stato quindi possibile progettare un opportuno parser che automaticamente riesca a estrapolare le informazioni contenute e popolare le strutture dati da noi create\footnote{Nessun altro tipo di input è supportato}.

\subsection*{STRUTTURA DEL PROGETTO}

I file che compongono il programma realizzato sono stati organizzati nel modo seguente; all' interno della cartella radice, da noi chiamata TSPCsharp, si sono create le seguenti sottocartelle:

\begin{itemize}
\item \textbf{Src} contenente il progetto di Visual Studio;
\item \textbf{Data} include le istanze del problema del commesso viaggiatore appartenenti alla TSPlib;
\item \textbf{Concorde} contenente i file sorgenti in linguaggio C del programma Concorde\footnote{Concorde è un software freeware sviluppato da \textbf{William Cook} per la risoluzione di problemi TSP} la cui trattazione è rimandata al Capitolo X.
\end{itemize}

Il software sviluppato è composto da dieci classi, riportiamo di seguito il nominativo di ognuna di esse:

\begin{itemize}
\item Instances
\item ItemList
\item PathGenetic
\item PathStandard
\item Point
\item Program
\item Tabu
\item TSP
\item TSPLazyConsCallback
\item Utility
\end{itemize}

Per le classi Point, Instances, Program, TSP e Utility verrà fornita una descrizione in questo capitolo, le rimanenti classi verranno presentate nei capitoli successivi poichè una loro trattazione risulterebbe in questo momento prematura. 

\section*{SEZIONE TRE}

\subsection*{CLASSE POINT}

La classe Point è stata realizzate al fine di memorizzare le coordinate in due dimensioni di un singolo nodo $n$, a tal fine sono presenti due variabili private, accessibili attraverso i propri metodi get e set, di tipo \textbf{double} chiamate rispettivamente \textbf{x} e \textbf{y}. Il costruttore della classe non fa altro che ricevere in input i valori da assegnare a queste ultime. La classe presenta inoltre un ulteriore metodo pubblico e statico chiamato \textbf{Distance} che permette il calcolo della distanza tra due nodi:

\begin{lstlisting}
    public static double Distance(Point p1, Point p2, string pointType)
\end{lstlisting}

\begin{itemize}
\item \textbf{p1}: Rappresenta il primo nodo;
\item \text{p2}: Rappresenta il secondo nodo;
\item \textbf{pointType}: Rappresenta il modo con cui il costo relativo al lato che congiunge p1 con p2 viene calcolato; i valori che questo parametro può assumere sono i seguenti:
    \begin{itemize}
    \item EUC\char`\_2D
    \item ATT
    \item MAN\char`\_2D
    \item GEO
    \item MAX\char`\_2D    
    \item CEIL\char`\_2D
    \end{itemize}
\end{itemize}

A titolo di esempio riportiamo il codice eseguito nel caso in cui pointType risulti uguale a EUC\char`\_2D dove il costo del lato deve risultare pari alla distanza euclidea dei due nodi. 

\begin{lstlisting}

 double xD = p1.X - p2.X;
 double yD = p1.Y - p2.Y;
 
 if (pointType == "EUC\_2D")
 {
     return (int)(Math.Sqrt(xD * xD + yD * yD) + 0.5);
 }
 else if ...
            
\end{lstlisting}

Per quanto riguarda gli altri metodi di calcolo della distanza rimandiamo il lettore alla visione del codice.

\subsection*{CLASSE INSTANCE}

La classe Instance è stata creata per memorizzare tutti i dati caratterizzanti l'istanza del problema del Commesso Viaggiatore. La tabella sottostante fornisce un elenco di variabili ed array definite all'interno della classe assieme ad una loro breve descrizione. 


\begin{center}

    \begin{longtable}{ | p{4cm} | p{4cm} | p{7cm} |}
    \hline
    \begin{center} \textbf{Tipo di dato} \end{center} & \begin{center}  \textbf{Nome} \end{center}& 
    \begin{center} \textbf{Descrizione} \end{center}\\ \hline
    \begin{center} int \end{center} & \begin{center} nNodes \end{center}& \vfill Rappresenta il numero di nodi dell' istanza del problema del Commesso Viaggiatore.\vfill \\ \hline
    \begin{center} Point[ ] \end{center} & \begin{center} coord \end{center}& \vfill Vettore di Point contenente le coordinate di tutti i vertici del grafo.\vfill\\ \hline
    \begin{center} string \end{center} & \begin{center} edgeType \end{center}&\vfill Definisce la modalità con cui calcolare la distanza fra due nodi.\vfill \\ \hline
    \begin{center} double \end{center} & \begin{center} timeLimit \end{center}& \vfill Definisce la quantità massima di tempo che il programma dispone per il calcolo della soluzione.\vfill \\ \hline
    \begin{center} double \end{center} & \begin{center} inputFile \end{center}&\vfill Rappresenta il nome del file di input contenente l'istanza del problema del Commesso Viaggiatore. \vfill\\ \hline
    \begin{center} double \end{center} & \begin{center} tStart \end{center}& \vfill Rappresenta i secondi trascorsi dall'attivazione del cronometro al reale inizio delle operazioni di calcolo per la risoluzione del problema \vfill \\ \hline
    \begin{center} double \end{center} & \begin{center} xBest \end{center}& \vfill Rappresenta il costo della soluzione ottima restituira da cplex.\vfill \\ \hline
    \begin{center} double \end{center} & \begin{center} tBest \end{center}& \vfill Contiene la qantità di tempo impiegata per il calcolo della soluzione ottima. \vfill \\ \hline
    \begin{center} double \end{center} & \begin{center} bestSol \end{center}& \vfill Rappresenta la soluzione ottima ritornata da Cplex.\vfill \\ \hline
     \begin{center} double \end{center} & \begin{center} bestLb \end{center}& \vfill Rappresenta il miglior lower bound attualmente calcolato.\vfill \\ \hline
    \begin{center} double \end{center} & \begin{center} bestLb \end{center}& \vfill Rappresenta il miglior lower bound attualmente calcolato.\vfill \\ \hline
     \begin{center} double \end{center} & \begin{center} bestLb \end{center}& \vfill Rappresenta il miglior lower bound attualmente calcolato.\vfill \\ \hline
    \end{longtable}
\end{center}

\textit{xMin e yMin ... mi servivano per gnuplot ma dato che ho messo l'autoscale credo non servano più. per xBest ok}

L' unico metodo appartenente a questa classe, esclusi i vari getter e setter, è \textbf{Print}, la cui firma risulta essere:

\begin{lstlisting}
                  static public void Print(Instance inst)
\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{inst}: oggetto della classe Instance contente tutti dati che descrivono l'istanza del problema del Commesso Viaggiatore fornita in ingresso dall' tente;
\end{itemize}

Tale metodo stampa a video le coordinate di tutti i nodi memorizzati dentro \textbf{inst}. Viene di seguito riportato il codice:

\begin{lstlisting}
for (int i = 0; i < inst.NNodes; i++)
    Console.WriteLine("Point #" + (i + 1) + "= (" + inst.Coord[i].X + "," + inst.Coord[i].Y + ")");
\end{lstlisting}

\subsection*{CLASSE PROGRAM}

La classe Program contiene il metodo Main che, come noto, rappresenta il punto di inizio del programma: attraverso le funzionalità di Visual Studio esso riceve in input l'array \textbf{argv} di stringhe contenente i parametri di input forniti dall'utente come il nome del file contenente l'input ed il time limit per la sua risoluzione. Appartengono a questa classe anche i metodi \textbf{ParseInst} e \textbf{Populate}: rispettivamente forniscono il parser per \textbf{argv} ed il parser del file di ingresso indicato con conseguente inizializzazione delle coordinate dei nodi. Firma e implementazione di tali metodi è rimandata al successivo capitolo.\\
All'interno del metodo \textbf{Main} vengono eseguite in ordine le seguenti attività:
\begin{itemize}
    \item Creata una istanza della classe \textbf{Instance} ed invocati i due metodi precedentemente nominati.
    \item Creato un oggetto della classe \textbf{Stopwatch}. Questa classe è fornita direttamente da Visual Studio appartenente al Namespace \textbf{System.Diagnostics} è fornisce le funzionalità di un cronometro compatibile al multithreading.
    \item Invocato il metodo \textbf{TSPOpt} della classe \textbf{TSP} passandogli come parametri i due oggetti di tipo Instance e Stopwatch.
    \item In caso di risultato positivo (una soluzione del problema è stata trovata) viene mostrato a video il risultato ottenuto ed il tempo di calcolo trascorso.
    \item Viene effettuata una pulizia dei file creatisi durante l'esecuzione del problema.
\end{itemize}

In tutto il nostro progetto si è cercato di utilizzare il minor numero possibile di variabili globali, in particolare solo all'interno di questa classe ne sono state definite due di seguito descritte:

\begin{center}
    
    \begin{tabular}{ | p{1.5cm} | p{4cm} | p{2cm} | p{6.5cm} |}
        \hline
        \begin{center} \textbf{Tipo di dato} \end{center} & \begin{center}  \textbf{Nome} \end{center}& \begin{center} \textbf{Valore} \end{center} & \begin{center} \textbf{Descrizione} \end{center}\\ \hline
        \begin{center} int \end{center} & \begin{center} VERBOSE \end{center}& \begin{center} 5 \end{center} & Regola quanto output il programma mostra a video: si è scelto di condizionare l' esecuzione di molte righe di codice che producevano una stampa a video in base al valore assunto da questa variabile. Si è deciso di ristringere il suo valore da 1 a 9, quando assume il valore 9 viene riportato a video il maggior numero possibile di stampe. \\ \hline
        \begin{center} int \end{center} & \begin{center} TICKS\char`\_PER\char`\_SECOND \end{center} &  \begin{center}1000  \end{center}& Cplex utilizza i così detti ticks come unità di misura per il tempo di calcolo, questa costante indica quanti ne trascorrono in un secondo.\\ \hline
        
    \end{tabular}
\end{center}

\subsection*{CLASSE TSP}

La classe \textbf{TSP} è stata pensata come il cuore del programma in quanto lo scheletro di tutti i metodi di risoluzione implementatisi trova al suo interno. Contiene un unico metodo pubblico che rappresenta quindi l'unico entry point per utilizzare questa classe: \textbf{TSPOpt}.

\begin{lstlisting}
static public bool TSPOpt(Instance instance, Stopwatch clock)
\end{lstlisting}

Come già specificato nella descrizione della classe Program, TSPOpt è invocato dal metodo Main e pertanto maggiori dettagli riguardanti i suoi parametri di ingresso possono essere trovati nella sezione precedente.\\
TSPOpt si preoccupa di istanziare i vari elementi utilizzati da tutti i metodi di risoluzione\footnote{Fatta eccezione per l'UserCutCallBack che è gestita esternamente da una DLL}, fornire all'utente un'interfaccia grafica che gli permetta di scegliere quale di questi ultimi voglia utilizzare e di conseguenza invoca il metodo privato della classe associato alla scelta effettuata.\\
Entrando nello specifico per quanto riguarda gli elementi inizializzati troviamo un oggetto della classe \textbf{Cplex} che come già accennato in precedenza ci permetterà di stabilire una connessione con il programma Cplex ed utilizzarlo per la risoluzione del modello matematico, ed un oggetto \textbf{Process} che sostanzialmente viene da noi utilizzato per inizializzare e comunicare con il programma \textbf{GNUPlot}\footnote{Per maggiori dettagli si veda la sezione dedicata a GNUPlot}.

\subsection*{CLASSE UTILITY}

La classe Utility può essere considerata come una libreria: contiene al suo interno solamente metodi \textbf{statici} che si è deciso di raggruppare al suo interno per rendere il codice il più compatto e leggibile possibile.

\subsection{CLASSE PATHGENETIC}

La classe \textbf{PathGenetic} utilizzata per memorizzare i dati di una soluzione generica, estende \textbf{PathStandard} già discussa nel paragrafo X.Y. aggiungendo due campi utili solamente per gli algoritmi genetici: il primo di tipo \textit{double} memorizza la fitness associata alla soluzione, il secondo di tipo intero identifica il circuito all'atto dell'estrazione dei percorsi che formeranno la generazione successiva\footnote{I suddetti parametri prendono nome \textbf{fittness} e \textbf{nRoulette}}.
La classe è dotata del metodo privato \textbf{CalculateFitness} il quale semplicemente setta la variabile fitness come descritto in precedenza:


\begin{lstlisting}

private void CalculateFitness()
{
fitness = 1 / cost;
}

\end{lstlisting}

La variabile \textbf{cost} e l’array \textbf{path} sono ereditati da PathStandard e vengono settati utilizzando uno dei tre costruttori a disposizione

\begin{lstlisting}

public PathGenetic(int[] path, double cost) : base()
{
this.path = path;
this.cost = cost;
CalculateFitness();
nRoulette = -1;
}

public PathGenetic(int[] path, Instance inst) : base(path, inst)
{
CalculateFitness();
nRoulette = -1;
}


public PathGenetic(): base()
{
fitness = -1;
nRoulette = -1;
}

ANDREBBE UN COMMENTINO SU OGNUNO

\end{lstlisting}

\section*{SEZIONE TRE}

\subsection*{LETTURA INPUT FILE}

Lo sviluppo del programma è iniziato realizzando una opportuna funzione per interpretare correttamente i parametri di ingresso forniti dall'utente. Oltre al nome del file di testo contenente i dati relativi  all'istanza del problema che si vuole risolvere, all'utente è richiesto di fornite un time limit(espresso in secondi) e di scegliere con quale algoritmo risolvere l'istanza da esso fornita. Si è deciso di ricevere da riga di comando il nome del file e il time limit; per quanto riguarda la scelta dell'algoritmo risolutore ed eventuali parametri da esso richiesti si è preferito realizzare una semplice interfaccia grafica per favorire l'utente. 
Visual Studio, all'interno delle proprietà del progetto, permette di definire una stringa come parametro di ingresso per il programma. Questa viene automaticamente separata in sottostringhe utilizzando come separatore il carattere di spazio e fornito in ingresso al metodo Main. Allo stato attutale è gestita solamente la possibilità di fornire in ingresso il nome del file contenente i dati ed il timelimit per la ricerca della soluzione. Per ottenere una migliore organizzazione e chiarezza per il nostro lavoro è stato deciso di utilizzare questa regola per la costruzione della stringa di ingresso: ogni parametro inseritovi deve essere preceduto da una parola chiave che lo identifica il cui primo carattere deve essere '-'. Questa tecnica si rileverà utile anche in futuro nel caso si decidesse di ampliare la lista di parametri di ingresso.\\
La funzione che interpreta correttamente gli argomenti forniti in input dalla riga di comando è stata chiamata ParseInst ed ha la seguente intestazione:

\begin{lstlisting}
      static void ParseInst(Instance inst, string[] input) 
\end{lstlisting}


\begin{itemize}
\item \textbf{inst}: rappresenta il riferimento all'istanza della classe Instance dichiarata nel metodo Main, i valori letti vengono memorizzati al suo interno.
\item \textbf{input}: rappresenta un vettore contenente i parametri di input forniti da riga di comando dall'utente.
\end{itemize}


Il metodo è composto da un semplice ciclo for che scandisce il vettore \textbf{input} cercando una parola chiave, se trovata la stringa successiva viene memorizzata correttamente dentro \textbf{inst}: 

\begin{lstlisting}

for (int i = 0; i < input.Length; i++)
{
   if (input[i] == "-file")
   {
     //Expecting that the next value is the file name
       inst.InputFile = input[++i];
       continue;
    }
    if (input[i] == "-timelimit")
    {
      //Expecting that the next value is the time limit in seconds
       inst.TimeLimit = Convert.ToDouble(input[++i]);
       continue;
    }
}               
\end{lstlisting}

Nel caso in cui l' utente non fornisca il nome del file di input oppure il time limit viene lanciata una eccezione:

\begin{lstlisting}

if (inst.InputFile == null || inst.TimeLimit == 0)
     throw new Exception("File input name and/or timelimit are missing");

\end{lstlisting}

\subsection*{METODO POPULATE}

Il metodo Populate è utilizzato per la lettura dei dati contenuti all'interno del file di input e soprattutto alla loro memorizzazione all'interno di un oggetto di tipo \textbf{Instance} in modo tale che una volta conclusosi il metodo questo contenga tutte le informazioni necessarie per la creazione del modello matematico.\\
I file di input presenta una struttura pressoché identica tra loro e cioè una divisione in sezioni identificate da parole chiave. Fatta eccezione per la sezione che descrive le coordinate dei nodi, tutte le altre si sviluppano in una sola riga la cui struttura è del tipo:

\begin{center}
<parolaChiave> : < valore> 
\end{center}

Di seguito sono riportati i valori che possono essere assunti dalle parole chiavi e il significato del contenuto della relativa sezione: 

\begin{itemize}
    \item NAME:<string> 
    \begin{itemize}
    \item nome con cui l' istanza è nota in letteratura.
    \end{itemize}
    \item TYPE:<string>
    
    \begin{itemize}     
    \item indica il tipo dell' istanza. Nel nostro ambito sarà sempre TSP.    
    \end{itemize}    
     
    \item \textbf{COMMENT:<string>} 
    \begin{itemize}    
    \item include informazioni aggiuntive, solitamente contiene il nome deli gli autori che hanno proposto l'                  istanza.
    \end{itemize}    
    
        
    \item \textbf{DIMENSION:<integer>} 
    \begin{itemize}
    \item indica il numero di nodi.
    \end{itemize}    
    
    \item \textbf{EDGE WEIGHT TYPE:<string>}
    \begin{itemize} 
    \item Definisce il modo con cui il costo del lato deve essere calcolato, i possibili valori  che può assumere                 il contenuto di questa sezione sono stati già presentati a pagina 7 durante la descrizione del metodo Distance.
    \end{itemize}    
    
    \item \textbf{NODE COORD SECTION}: 
    \begin{itemize}    
    
    \item Il contenuto di questa sezione si sviluppa in più righe; in ogni riga troviamo nell' ordine:
    \begin{itemize}
    \item Un numero progressivo intero positivo che comincia da 1 e che identifica il nodo. Osserviamo che anche se in input il primo nodo è numerato a partire da 1, nel vettore Point di inst le coordinate saranno memorizzate a partire dall'indice 0\footnote{Tale scelta è per mantenere una conformità con la metrica adottata dal linguaggio C\# per l'enumerazione degli elementi dei vettori, nel caso in cui le coordinate vengano visualizzate a video il loro indice viene comunque incrementato di uno}.
    \item Un numero reale positivo che definisce la coordinata x del nodo.
    \item Un numero reale positivo che identifica la coordinata y del nodo.
    \end{itemize}        
    \end{itemize}    
\end{itemize}

Il file di testo termina sempre con la stringa \textbf{EOF} che indica la fine del file di testo.

Per poter leggere il contenuto di un file è necessario inizializzare una nuova istanza della classe StreamReader passando come parametro al costruttore il percorso ove tale file è  collocato.


\begin{lstlisting}

StreamReader sr = new StreamReader("..\\..\\..\\..\\Data\\" + inst.InputFile)

\end{lstlisting}


Il metodo ReadLine() della classe StreamReader ritorna, come stringa, il contenuto di una intera riga del file la quale viene memorizzata all'interno di una variabile di tipo string chiamata \textbf{line}. Poichè si vuole leggere tutto il contenuto del file, è necessario invocare ReadLine() ciclicamente sull' oggetto \textbf{sr} finchè line risulta diversa da null oppure viene incontrata la parola chiave \textbf{EOF}.

\begin{lstlisting}

while ((line = sr.ReadLine()) != null)
{
    ...
    
    //This line signals the end of the file
    if (line.StartsWith("EOF"))
    {
    Instance.Print(inst);
    Console.WriteLine(line);
    //Correct end of the file
    break;
    }
    
    ...
}
\end{lstlisting}


Poichè ogni riga inizia con una nota parola chiave, per prelevare il contenuto di una sezione e memorizzarlo in un opportuno campo di inst, è sufficiente confrontare la prima stringa di ogni riga con una delle noti parole chiavi. Per far ciò si è  usato il metodo StartWith della classe String, la cui firma è:

\begin{lstlisting}

                    public bool StartWith(string value)

\end{lstlisting}

Questo metodo, applicato alla variabile line, determina se la prima stringa di line corrisponde alla stringa value specificata all'atto dell' invocazione del metodo. Nel caso in cui il confronto dia esito positivo, per prelevare il contenuto della sezione è necessario applicare i metodi IndexOf e Remove sempre alla variabile line; l'intestazione di tali metodi è riportata di seguito:


\begin{lstlisting}

               public int IndexOf(string value,int startIndex)

\end{lstlisting}

dove:

\begin{itemize}
    \item \textbf{value}: stringa da cercare.
    \item \textbf{startIndex}: posizione iniziale della ricerca.
\end{itemize}

\begin{lstlisting}

                public string Remove(int startIndex, int count)

\end{lstlisting}


dove:

\begin{itemize}
    \item \textbf{startIndex}: posizione da cui iniziare l'eliminazione dei caratteri.
    \item \textbf{count}: numero di caratteri da eliminare.
\end{itemize}

Per quanto detto, risulta immediata la comprensione del codice necessario per prelevare il contenuto della sezione e memorizzarlo dentro un oggetto di tipo \textbf{Instance} chiamando il metodo setter adeguato:

\begin{lstlisting}

                inst.SetterName = (line.Remove(0, line.IndexOf(:) + 2));

\end{lstlisting}

Il codice riportato deve chiaramente effettuare un cast per i tipi diversi da string, i metodi necessari sono già disponibili all'interno della classe \textbf{Convert} di C\#.

Una volta che ci troviamo all'interno della sezione \textbf{NODE COORD SECTION} la lettura delle coordinate viene eseguita eseguendo ciclicamente il seguente codice:

\begin{lstlisting}

string[] elements = line.Split(new[]{ ' ' } , StringSplitOptions.RemoveEmptyEntries);

int i = Convert.ToInt32(elements[0]);

inst.Coord[i - 1] = new Point(Convert.ToDouble(elements[1].Replace(".", ",")), Convert.ToDouble(elements[2].Replace(".",",")));
\end{lstlisting}

Il metodo Split della classe String ritorna un array contenente in ogni elemento una sottostringa della stringa a cui tale metodo è applicato. Le sottostringhe vengono estratte dalla stringa in base ai caratteri delimitatori specificati all'atto dell'invocazione del metodo, quest'ultimo ha diversi overload: quello di nostro interesse è riportato di seguito.

\begin{lstlisting}

     public string[] Split(char[] separator, StringSplitOptions options)

\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{separator}: array i cui elementi definiscono i separatori della stringa. Nel nostro caso è un array con un solo elemento contenente il carattere \textipa{"}   \textipa{"}.
\item \textbf{options}: A questo parametro possono essere passate solo i seguenti due valori dell' enumerazione StringSplitOptions:

\begin{itemize}

\item \textbf{StringSplitOptions.RemoveEmptyEntries}: indica che gli elementi dell'array ritornato non possono essere stringhe vuote. Questo è l'opzione da noi selezionata.
\item \textbf{StringSplitOptions.None}: indica che gli elementi dell'array ritornato possono essere stringhe vuote.

\end{itemize}

\end{itemize}

Ogni coordinata letta viene tradotta in un oggetto di tipo \textbf{Point} il quale è a sua volta memorizzato all'interno del vettore \textbf{Coord} dell'oggetto di tipo \textbf{Instance} nella posizione indice letta.

Come nota conclusiva specifichiamo che C\# utilizza come separatore tra parte intere e parte decimale di un numero il carattere \textipa{"},\textipa{"} e non il carattere \textipa{"}.\textipa{"} utilizzato per nei file di input. E' quindi necessaria una modifica delle stringhe lette attraverso il metodo non statico della classe string:

\begin{lstlisting}

     public string Replace(string oldValue, string newValue)
)

\end{lstlisting}
dove:
\begin{itemize}
    \item \textbf{oldValue}: stringa sa sostituire;
    \item \textbf{newValue}: stringa con cui sostituire tutte le occorrenze di oldValue.
\end{itemize}

\section*{SEZIONE QUATTRO}

In questo paragrafo vedremo come è possibile creare da programma un modello matematico attraverso l'uso di alcune routine appartenenti alla libreria di Cplex. Esula dallo scopo di questa tesi fornire al lettore una descrizione del funzionamento di Cplex da iterativo.


\subsection*{COSTRUZIONE MODELLO IN LINGUAGGIO C}

Per istanziare un nuovo modello di programmazione lineare è necessario inizializzare un \textbf{environment} di Cplex utilizzando la funzione \textbf{CPXopenCPLEX} la quale ritorna un puntatore all'environment creato, la firma di tale funzione è:


\begin{lstlisting}

                CPXENVptr CPXopenCPLEX(int* status\_p)

\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{status\char`\_p}: puntatore ad una variabile di tipo intero usato per ritornare un eventuale codice di errore.
\end{itemize}


Ad un enviroment è possibile associare uno o più modelli attraverso il comando \textbf{CPXcreateprob}, la cui intestazione è:

\begin{lstlisting}

    CPXLPptr CPXcreateprob(CPXCENVptr env, int * status\_p, const char * probname\_str

\end{lstlisting}


dove:

\begin{itemize}
    \item \textbf{env}: puntatore all'environment sul quale si è deciso di creare il modello;
    \item \textbf{status\char`\_p}: puntatore ad una variabile di tipo intero usato per ritornare un eventuale codice di errore;
    \item \textbf{probname\char`\_str}: rappresenta un array di caratteri che definisce il nome del modello creato.
\end{itemize}

Tale funzione ritorna un puntatore al modello creato: questo risulta vuoto poichè privo di funzione obbiettivo, variabili e vincoli.\\

Procediamo quindi al loro inserimento partendo definendo contemporaneamente le variabili e il loro coefficiente nella funzione obiettivo; è possibile procedere in più modi, quello da noi scelto è di utilizzare la funzione \textbf{CPXnewcols} la cui firma è:


\begin{lstlisting}

int CPXnewcols (CPXENVptr env,CPXLPptr lp,int ccnt,double *obj, double *lb, double *ub, char *ctype, char **colname);

\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{env} : puntatore all'enviroment di Cplex nel quale vuole essere inserito il modello.
\item \textbf{lp} : puntatore al problema di programmazione lineare.
\item \textbf{ccnt} : intero che indica il numero delle nuove variabili che vengono aggiunte al problema.
\item \textbf{obj} : array contenente per ogni variabile il relativo coefficiente 
\item \textbf{lb} : array di lunghezza ccnt contenente il lower bound di ogni variabile aggiunta.
\item \textbf{ub} : array contenente l'upper bound di ogni variabile aggiunta.
\item \textbf{ctype} : array di lunghezza ccnt contenente il tipo di ogni variabile. I valori che un elemento di questo array può assumere sono:
\begin{itemize}
    \item \textbf{\textipa{"}C\textipa{"}}: variabile continua
    \item \textbf{\textipa{"}B\textipa{"}}: variabile binaria
    \item \textbf{\textipa{"}I\textipa{"}}: variabile intera
\end{itemize}
\item \textbf{colname} : array di lunghezza ccnt contenente puntatori ad array di char, a sua volta ognuno di essi deve contenere il nome della variabile aggiunta al modello.
\end{itemize}

Per motivi di semplicità non andremo ad inserire tutte le variabili contemporaneamente ma una ad una.\\

E' giunto quindi il momento di parlare di quali variabili vogliamo aggiungere al nostro modello tenendo presente che il medesimo discorso sarà applicato anche per la parte in C\#. Sappiamo che per ogni coppia di nodi (i,j)\footnote{Ricordiamo che i deve essere diverso da j in quanto per i problemi da noi considerati i cappi non sono ammessi} esiste un unico lato che li collega e che quest'ultimo è privo di direzione. Si presenta quindi la necessità di definire una convenzione per l'assegnazione del nome ai vari lati. La scelta adottata è la seguente: considerando due generici nodi \textbf{i} e \textbf{j} allora il loro lato sarà chiamato \textbf{x(i,j)} se $i<j$ oppure \textbf{x(j,i)} se $j<i$\footnote{Notiamo che per quanto espresso nella nota precedente non ha senso considerare il caso $i=j$}.\\
Questa convenzione offre anche un importante spunto per decidere con quale ordine memorizzare i vari parametri delle variabili (nome, coefficiente, lower bound ecc..): date due coppie distinti di nodi (i,j) e (v,w)\footnote{dove assumiamo $i<j \& v<W$} la posizione di memoria in cui viene memorizzata l'informazione riguardante la prima coppia è \textbf{inferiore} rispetto alla seconda se e solo se $(i<v) || (i==v \& j<w)$. In altre parole saranno memorizzate in ordine le informazioni per i nodi (1,2), (1,3), ..., (2,3), (2,4), ..., (n-1,n).\\
Una ulteriore considerazione necessaria è la seguente: come mostrato poco fa il metodo \textbf{CPXnewcols} si aspetta il passaggio di diversi array mentre noi vorremmo utilizzare semplici variabili. La soluzione è molto semplice e consiste nell'anteporre il carattere \& prima di ogni variabile in questo modo stiamo in realtà passando un puntatore alla sua locazione di memoria.\\

Le operazioni descritte sono state realizzate tramite il seguente codice:

\begin{lstlisting}

double zero = 0.0; // one = 1.0;     
char binary = 'B';

char **cname = (char **)calloc(1, sizeof(char *));        // (char **) required by cplex...
cname[0] = (char *)calloc(100, sizeof(char));

// add binary var.s y(i,j)      

for (int i = 0; i < inst->nNodes; i++)
{
    for (int j = i + 1; j < inst->nNodes; j++)//Mi interessano solo le coppie con i<j
    {
        sprintf(cname[0], "x(%d,%d)", i + 1, j + 1);
        double obj = dist(inst->coord[i], inst->coord[j], inst->edgeType);
        double ub = 1.0;
        if (CPXnewcols(env, lp, 1, &obj, &zero, &ub, &binary, cname)) printError(" ... errato CPXnewcols su x");//Aggiugo una variabile al modello
        if (CPXgetnumcols(env, lp) - 1 != xPos(i, j, inst)) printError(" ... errata posizione per x");//Serve solo per controllare se la funzione xPos è corretta
    }
}

\end{lstlisting}

La funzione chiamata xPos  riceve in ingresso un lato (i,j) del grafo e restituisce l'indice della variabile Cplex associata a quest'ultimo. Dato che risulta possibile effettuare errori nella realizzazione di questa funzione, in questo punto del codice è  utile effettuare un controllo se il valore ritornato da xPos coincide con quello aspettato,in caso contrario viene sollevata una eccezione. Firma e dettagli implementativi di xPos saranno forniti nel paragrafo successivo in quanto è definita anche in C\#.\\

Una volta definite le variabili è necessario creare i vincoli: per far ciò si è utilizzata la funzione \textbf{CPXnewrows}, la cui firma è:

\begin{lstlisting}
int CPXnewrows(CPXCENVptr env, CPXLPptr lp, int rcnt, const double * rhs, const char * sense, const double * rngval, char ** rowname)
\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{env}: puntatore all'enviroment di Cplex nel quale vuole essere inserito il modello.
\item \textbf{lp}: puntatore al problema di programmazione lineare.
\item \textbf{rcnt}: intero che definisce il numero di nuovi vincoli aggiunti al modello.
\item \textbf{rhs}: array di lunghezza rcnt contenente il termine noto di ogni vincolo.
\item \textbf{sense}: array di lunghezza rcnt i cui elementi possono assumere i seguenti valori:

\begin{itemize}
\item \textbf{\textipa{"}L\textipa{"}}: indica che il vincolo è una disuguaglianza il cui segno è  $\leq$
\item \textbf{\textipa{"}E\textipa{"}}: indica che il vincolo è una uguaglianza
\item \textbf{\textipa{"}G\textipa{"}}: indica che il vincolo è una disuguaglianza il cui segno è $\geq$
\item \textbf{\textipa{"}R\textipa{"}} : indica che il vincolo è limitato 
\end{itemize}

\item \textbf{rngval}: variabile di tipo double contenente il valore 1.0;
\item \textbf{rowname}: variabile di tipo char che assume il valore costante \textipa{"}B\textipa{"};
\end{itemize}

Anche in questo caso anzichè aggiungere tutti i vincoli in una singola iterazione, risulta più semplice aggiungere un vincolo per volta invocando il metodo tante volte quante sono i vincoli da aggiungere.

\subsection*{COSTRUZIONE E RISOLUZIONE DEL MODELLO MATEMATICO IN C\#}

Per poter creare un modello matematico in Cplex, utilizzando come linguaggio di programmazione C\# è necessario creare inizialmente una istanza della classe \textbf{Cplex}:

\begin{lstlisting}
                           Cplex cplex = new Cplex();
\end{lstlisting}

Per creare il modello si associano, tramite opportune funzioni che descriveremo in questo paragrafo, all'istanza creata la funzione obbiettivo,le variabili e i vincoli del modello. 

In C\# le variabili del modello sono oggetti il cui tipo deve implementare l'interfaccia \textbf{INumVar}. Non è necessario creare da noi una nuova classe infatti ci viene fornito il metodo \textbf{NumVar} della classe \textbf{Cplex}:

\begin{lstlisting}
public virtual INumVar NumVar(double lb, double ub, NumVarType type, string name)
\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{lb}: Rappresenta il lower bound della variabile creata;
\item \textbf{ub}: Rappresenta l' upper bound della variabile creata;
\item \textbf{type}: Questo campo determina il tipo della variabile, può assumere i seguenti valori:
\begin{itemize}
\item \textbf{NumVarType.Int}: Nel caso di variabile intera;
\item \textbf{NumVarType.Int}: Nel caso di variabile binaria;
\item \textbf{NumVarType.Float}: Nel caso di variabile continua;
\end{itemize}
\item \textbf{name}: Nome identificativo della variabile.
\end{itemize}

Che come si può notare nella firma ha come tipo di ritorno un tipo di oggetto che implementa l'interfaccia da noi desiderata. Vedremo nel seguito della trattazione quanto utili risultano essere le funzionalità offerta de quest'ultima.\\
Introduciamo ora una seconda interfaccia \textbf{ILinearNumExpr} che come si può intuire viene implementata da oggetti che vogliono definire una espressione lineare. Anche in questo caso ci viene incontro la classe \textbf{Cplex} attraverso il metodo \textbf{LinearNumExpr}:
\begin{lstlisting}
                ILinearNumExpr expr = cplex.LinearNumExpr();
\end{lstlisting}

La variabile \textbf{expr} rappresenta quindi una espressione lineare che deve essere definita come:

$$\displaystyle{\sum_{i = 1}^n a_i x_i} $$

dove \textbf{$x\_i$} sono variabili di tipo \textbf{INumVar} mentre \textbf{$a\_i$} è un coefficiente di tipo \textbf{double}. Per aggiungere all'oggetto \textbf{expr} una variabile del modello è necessario utilizzare il metodo \textbf{AddTerm} la cui intestazione è:

\begin{lstlisting}
                   void AddTerm(INumVar var,double coef)
\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{var}: variabile da aggiungere all'espressione;
\item  \textbf{coeff}: coefficiente della variabile aggiunta all'espressione.
\end{itemize}

L'implementazione da noi fornita per quanto riguarda la funzione obiettivo è la seguente:

\begin{lstlisting}
//Populating objective function

for (int i = 0; i < instance.NNodes; i++)
{
  //Only links (i,j) with i < j are correct
  
  for (int j = i + 1; j < instance.NNodes; j++)
  {
      //zPos returns the correct position where to store the variable corresponding to the actual link (i,j)
           
     int position = zPos(i, j, instance.NNodes);
           
     z[position] = cplex.NumVar(0, 1, NumVarType.Int, "x(" + (i + 1) + "," + (j + 1) + ")");
         
     expr.AddTerm(z[position], Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType));      
   }
}

\end{lstlisting}

Espressioni lineari definite in questo modo possono essere utilizzate sia per definire la funzione obiettivo del modello ma anche per i suoi vincoli.\\
Nel primo caso risulta sufficiente invocare i metodi non statici \textbf{AddMinimize} oppure \textbf{AddMaximize} della classe \textbf{Cplex} che rispettivamente definiscono una funzione obiettivo da minimizzare o da massimizzare, nel nostro caso:            


\begin{lstlisting}
                         cplex.AddMinimize(expr);         
\end{lstlisting}

Per quanto riguarda i vincoli è necessario utilizzare i metodi \textbf{AddEq}, \textbf{AddLe}, \textbf{AddGe} che rispettivamente aggiungono al modello una equazione, una disequazione avente segno $\leq$, una disequazione avente segno $\geq$.\\
Nel nostro caso poichè ogni vincolo è una equazione riportiamo di seguito la firma della relativa funzione:

\begin{lstlisting}
public virtual IRange AddEq(INumExpr e,double v,string name)
\end{lstlisting}

dove:

\begin{itemize}
    \item \textbf{e}: Espressione contenente le variabili del vincolo;
    \item \textbf{v}: Termine noto del vincolo;
    \item \textbf{name}: Nome identificativo del vincolo.
\end{itemize}

Il codice completo diventa quindi:

\begin{lstlisting}

for (int i = 0; i < instance.NNodes; i++)
{
 //Resetting expr
  expr = cplex.LinearNumExpr();

  for (int j = 0; j < instance.NNodes; j++)
  {
   //For each row i only the link (i,j) or (j,i) has coefficent 1
   //xPos return the correct position where link is stored inside the vector x
    
    if (i != j)//No loops with only one node
       expr.AddTerm(x[xPos(i, j, instance.NNodes)], 1);               
  }

//Adding to the model the current equation with known term 2 and name degree(<current i node>)
cplex.AddEq(expr, 2, "degree(" + (i + 1) + ")");
}

\end{lstlisting}

Spiegato come è possibile creare un modello C\# risulta comprensibile la scelta di realizzare un'opportuna funzione, chiamata \textbf{BuilModel} appartenente alla classe \textbf{Utility}, che produce il modello matematico del Commesso Viaggiatore risolubile da Cplex:

\begin{lstlisting}
public static INumVar[] BuildModel(Cplex cplex, Instance instance, int nEdges)
\end{lstlisting}

dove:

\begin{itemize}
\item \textbf{cplex}: oggetto sul quale si definirà il modello matematico(funzione obbiettivo,variabili e vincoli)
\item \textbf{instance}: oggetto contenente tutti i dati inerenti all'istanza del Commesso Viaggiatore fornita in ingresso dall' utente.
\item \textbf{nEdges}: Parametro la cui spiegazione è rimandata al capitolo...
\end{itemize}

Passiamo infine a descrivere i metodi necessari per risolvere il modello, ottenere il costo e la soluzione ottima calcolata da Cplex.\\

Per risolvere il modello è sufficiente invocare, sull'oggetto di classe Cplex dove è stato definito, il metodo \textbf{Solve}:

\begin{lstlisting}
                         cplex.Solve();
\end{lstlisting}

Una volta avviata la risoluzione, Cplex fornisce in automatico informazioni sul processo stampate nello standard output da noi definito\footnote{Se non viene modificato di default risulta essere la classica console del progetto C\#}: inizialmente troviamo le impostazioni di risoluzione selezionate come ad esempio il numero di Thread .., successivamente ..  .\\
Terminata l'operazione il costo della soluzione è memorizzato all'interno della variabile \textbf{ObjValue} di tipo \textbf{double} del solito oggetto \textbf{cplex}:

\begin{lstlisting}
                        cplex.ObjValue; 
\end{lstlisting}

Naturalmente è anche possibile conoscere il valore assunto da ogni variabile nella soluzione fornitaci da Cplex tramite il metodo \textbf{GetValues} della classe \textbf{Cplex}:

\begin{lstlisting}
                public virtual double GetValues(INumVar[] var)
\end{lstlisting}

dove:

\begin{itemize}
\item \textbf: rappresenta il vettore contenente tutte le variabile appartenenti al modello.
\end{itemize}

\'E presente anche l'analogo metodo per accedere al valore di una sola variabile \textbf{GetValue}. Il suo utilizzo è da noi altamente sconsigliato in quanto sperimentalmente è stato da verificato che ciclare quest'ultimo metodo impiega un tempo molto maggiore rispetto al semplice \textbf{getValues}.



------------------------------------------------------------------
Qui bisogna aprire un capitolo nuovo con una breve introduzione, dire che si passa ora ad esporre i metodi utilizzati per gestire i vincoli di subtour elimination
------------------------------------------------------------------

\section*{SEZIONE CINQUE}

\subsection*{METODO LOOP}

Il primo metodo sperimentato prende il nome di \textbf{LOOP}.
-------------------------------------------------------------
Va messa un pò di storia!!!!!!
-------------------------------------------------------------
L'idea alla sua base è molto semplice ed è la seguente: inizialmente il modello fornito non deve contiene alcun vincolo di subtour elimination ed una volta risolto si procedere ad analizzare la soluzione ottima trovata. Se questa presenta dei subtour il modello viene ampliato inserendovi gli appositi vincoli per eliminarli e si procede ad una sua nuova risoluzione. Viene da se che quest'ultimo passo va ripetuto fino a quando la soluzione proposta non risulta accettabile e quindi priva di subtour\footnote{Da qui deriva il nome del metodo in quanto la soluzione consiste in un loop delle stesse operazioni}.\\\'E importante far notare che ogni iterazione del loop i vincoli aggiunti nella precedente sono ovviamente mantenuti.\\
In questo modo siamo sicuri di aver aggiunto al nostro modello solo i vincoli strettamente necessari il che non assicura che essi non siano un numero esponenziale.\\

Per poter implementare il metodo Loop risulta quindi evidente la necessità di sviluppare un'opportuna funzione in grado di individuare la presenza di subtour all'interno di una generica soluzione proposta e di generarne gli opportuni vincoli per eliminarli.\\
In letteratura esistono molteplici modi per eseguire tali operazioni, quella da noi adottata si rifà all'algoritmo di \text{Kruskal} per trovare un albero a costo minimo in un grafo connesso con lati non orientati\footnote{Nello specifico la parte di nostro interesse è quella che impedisce la formazione di più componenti connesse}.\\
La tecnica da noi adottata è stata quella di creare due metodi chiamati \textbf{InitCC} e \textbf{UpdateCC}: il primo serve solamente come inizializzazione per le strutture dati utilizzate dal secondo il quale, se invocato una volta per ogni lato appartenente alla soluzione attuale ne trova tutte le componenti connesse indicando anche quali lati sono a loro appartenenti. I dettagli riguardo le loro implementazioni sono visibili nella appendice di questo testo, per ora specifichiamo solamente che al termine dell'utilizzo del metodo \textbf{UpdateCC} i seguenti oggetti:

\begin{lstlisting}

        List<ILinearNumExpr> rcExpr = new List<ILinearNumExpr>();
        List<int> bufferCoeffRC bufferCoeffRC = new List<int>();

\end{lstlisting}

risultano essere costruiti, in particolare \textbf{rcExpr} contiene le espressioni dei subtour elimination mentre invece \textbf{bufferCoeffRC} contiene il numero di lati appartenenti ad ogni subtour e quindi il termine noto delle precedenti espressioni\footnote{Il codice assume che l'espressione di indice $i$ presente all'interno di \textbf{rcExpr} abbia il proprio termine noto nella posizione di indice $i$ dentro \textbf{bufferCoeffRC}}.\\
Se all'interno di \textbf{rcExpr} è presente una espressione sola significa che la soluzione attuale è valida e quindi ottima per il problema, al contrario si deve procedere all'inserimento dei vincoli con un semplice ciclo for:

\begin{lstlisting}
                
for (int i = 0; i < rcExpr.Count; i++)
  cplex.AddLe(rcExpr[i], bufferCoeffRC[i] - 1);
              
\end{lstlisting}

\subsection*{METODI UpdateCC e InitCC}

Come già specificato nella sezione riguardo il metodo \textbf{LOOP} questi due metodi di supporto appartenenti alla classe \textbf{Utility} hanno il compito di individuare tutte le componenti connesse (che da ora in avanti abbrevieremo con \textbf{cc}) di una generica soluzione proposta.\\
Prima di passare alla implementazione vera e propria introduciamoli ad alto livello: inizialmente si vuole assumere l'esistenza di $n$ \textbf{cc} distinte, ognuna di esse contenente un nodo della soluzione. Questo è il compito della dalla funzione \textbf{InitCC}.\\
Successivamente per ogni lato della soluzione si vuole analizzare a quali \textbf{cc} sono assegnati i due nodi che lo caratterizzano. Se queste sono differenti vanno unificate in modo tale che tutti i nodi appartenenti, ad esempio
, alla seconda ora appartengano tutti alla prima. Nel caso in cui invece le due \textbf{cc} coincidano significa che abbiamo trovato un subtour e il relativo vincolo di eliminazione deve essere definito. Tutte questo è invece compito del metodo \textbf{UpdateCC}.

Iniziamo quindi l'analisi del codice necessario. Per prima cosa si necessita di un vettore di interi che contenga all'indice $i-esimo$ l'identificativo della \textbf{cc} alla quale appartiene il nodo $i$\footnote{Per semplicità si è deciso di identificare ogni \textbf{cc} con un valore intero univoco}. L'inizializzazione di questo vettore viene fornita da \textbf{InitCC}:

\begin{lstlisting}

public static void InitCC(int[] cc)
{
    for (int i = 0; i < cc.Length; i++)
    {
        cc[i] = i;
    }
}

\end{lstlisting}

Passiamo ora al metodo \textbf{UpdateCC} che presenta la seguente firma:

\begin{lstlisting}

public static void UpdateCC(Cplex cplex, INumVar[] z, List<ILinearNumExpr> rcExpr, List<int> bufferCoeffRC, int[] relatedComponents, int i, int j)

\end{lstlisting}

dove:

\begin{itemize}
    \item \textbf{cplex}: oggetto contenente il modello matematico corrente, eventualmente necessario per la creazione del vincolo di subtour elimination;
    \item \textbf{z}: vettore contenente le variabili del modello, eventualmente necessario per la creazione del vincolo di subtour elimination;
    \item \textbf{rcExpr}: Lista all' interno della quale vengono memorizzate le espressioni contenenti le variabili del vincolo di subtour;
    \item \textbf{bufferCoeffRC}: Lista contenente i termini noti dei vincoli di subtour;
    \item \textbf{relatedComponents}: vettore che definisce per ogni nodo del grafo la relativa componente connessa;
    \item \textbf{i}: Nodo che con il parametro j forma il lato (i,j);
    \item \textbf{j}: Nodo che con il parametro i forma il lato (i,j).
\end{itemize}

La funzione UpdateCC viene invocata dal metodo Loop $n$ volte, alla k-esima invocazione riceve in ingresso il k-esimo lato appartenente alla soluzione ottima del modello corrente. Per verificare se il lato ricevuto genera un subtour nel grafo G=(V,T*), dove T* contiene i precedenti $k-1$ lati controllati, si verifica se i vertici del lato appartengono alla medesima componente connessa. Nel caso in cui i due vertici non appartengono alla medesima componente connessa, è necessario aggiornare le componenti connesse dei vertici per l' invocazione successiva del metodo, viceversa si è  individuato un subtour caratterizzato dai nodi aventi come componente connessa la medesima dei nodi i e j.

A livello implementativo si è utilizzato un array di interi chiamato relatedComponents, di dimensione pari al numero di vertici del grafo, come struttura dati necessaria per fotografare le componenti connesse del grafo G=(V,T*); relatedComponents contiene all' indice j la componente connessa del nodo j. La funzione InitCC, invocata ad ogni iterazione del metodo Loop, ha il compito di inizializzare relatedComponents associando ad ogni nodo una componente connessa diversa: in particolare si è  scelto di associare al nodo j la componente connessa j. Passiamo ora ad analizzare come è  stato nella pratica implementato il metodo UpdateCC, la sua intestazione è la seguente:

\begin{lstlisting}

public static void UpdateCC(Cplex cplex, INumVar[] z, List<ILinearNumExpr> rcExpr, List<int> bufferCoeffRC,int[] relatedComponents, int i, int j)

\end{lstlisting}

dove:
\begin{itemize}
\item cplex: oggetto contenente il modello matematico corrente;
\item z: vettore contenente le variabili del modello;
\item rcExpr: Lista all' interno della quale vengono memorizzate le espressioni contenenti le variabili del vincolo di subtour;
\item bufferCoeffRC: Lista contenente i termini noti dei vincoli di subtour;
\item relatedComponents: vettore che definisce per ongi nodo del grafo la relativa componente connessa;
\item i: Nodo che con il parametro j forma il lato [i,j];
\item j: Nodo che con il parametro i forma il lato [i,j].
\end{itemize}

Il caso in cui non si crei un subtour è gestito molto semplicemente in questo modo:

\begin{lstlisting}

if (relatedComponents[i] != relatedComponents[j])
{
    for (int k = 0; k < relatedComponents.Length; k++)
    {
        if ((k != j) && (relatedComponents[k] == relatedComponents[j]))
        {
            //Same as Kruskal
            relatedComponents[k] = relatedComponents[i];
        }
    }
    //Finally also the vallue relative to the Point i are updated
    relatedComponents[j] = relatedComponents[i];
}

\end{lstlisting}

Dove per convenzione si è deciso di inglobare la \textbf{cc} del nodo $j$ in quella del nodo $i$.\\
Il secondo caso è invece gestito nel seguente modo:

\begin{lstlisting}

else
{
    ILinearNumExpr expr = cplex.LinearNumExpr();

    //cnt stores the # of nodes of the current related components
    int cnt = 0;

    for (int h = 0; h < relatedComponents.Length; h++)
    {
        //Only nodes of the current related components are considered
        if (relatedComponents[h] == relatedComponents[i])
        {
            //Each link involving the node with index h is analized
            for (int k = h + 1; k < relatedComponents.Length; k++)
            {
                //Testing if the link is valid
                if (relatedComponents[k] == relatedComponents[i])
                {
                    //Adding the link to the expression with coefficient 1
                    expr.AddTerm(z[zPos(h, k, relatedComponents.Length)], 1);
                }
            }
            cnt++;
        }
    }
    //Adding the objects to the buffers
    rcExpr.Add(expr);
    bufferCoeffRC.Add(cnt);
}

\end{lstlisting}

Ripetere il metodo \textbf{UpdateCC} una ed una sola volta per ogni lato appartenente alla soluzione corrente ci assicura che le due liste \textbf{rcExpr} e \textbf{bufferCoeffRC} contengano tutti i dati per implementare i subtour elimination desiderati.

\subsection*{METODO LOOP CON PRIMA FASE EURISTICA}

Il metodo Loop, indipendente dalla implementazione che si decide di utilizzare, vuole essere un algoritmo esatto. In altre parole è necessario assicurarsi che il risultato finale da esso prodotto sia \textbf{sempre} il migliore possibile. Come vedremo nei paragrafi successivi, sono stati pensati molteplici algoritmi, detti euristici, che al contrario cercano solamente di avvicinarsi al risultato ottimo limitando al contempo i loro tempi di esecuzione.
\'E infatti quest'ultimo fattore a risultare cruciale per molti problemi di programmazione lineare, a maggior ragione per quelli che, come il \textit{commesso viaggiatore}, vogliono studiare situazioni \textbf{np-difficili}\footnote{In letteratura è noto infatti che i problemi appartenenti a quest'ultima categoria sono caratterizzati da tempi di risoluzione, al caso peggiore, esponenziali rispetto al numero di variabili che li caratterizzano. Nel caso in cui siano definiti nel tipico linguaggio della programmazione lineare, la caratteristica appena esposta è riscontrabile da un numero di vincoli anch'esso esponenziale.}.
Per quanto appena esposto si è pensato di progettare una variante del metodo \textbf{Loop} caratterizzata da una fase iniziale \textbf{euristica} i cui risultati vengono poi sfruttati da una seconda fase finale \textbf{esatta}. Durante la sua progettazione ci si accorge fin da subito che, come per ogni algoritmo euristico, non esistono specifici paletti che se fissati assicurano al \textbf{100\%} il raggiungimento dei propri obiettivi. Nel nostro caso ciò che desideriamo è chiaramente una fase \textit{euristica} più veloce di quella \textit{esatta} ma che produca anche risultati utili a quest'ultima. Abbiamo quindi deciso che, all'interno della nostra applicazione, sia l'utente stesso a poter settare alcuni parametri che rendono le due fasi più o meno differenti tra loro. In questo modo, basandosi sulle proprie esperienze e test, è possibile ottenere i risultati migliori per qualsiasi istanza del problema che si desidera risolvere.
Entriamo ora nel dettaglio delle due fasi chiarendo fin da subito che tutte e due devono sempre fornire soluzioni \textbf{valide} per il problema che andiamo a risolvere. In realtà ciò che è interessante discutere riguarda quasi solamente la fase \textit{euristica} in quanto quella \textit{esatta} è in tutto e per tutto il classico metodo \textbf{Loop} già esposto in precedenza\footnote{Ciò che varia è solamente che il modello matematico iniziale dato in pasto alla fase \textit{esatta} presenta già dei vincoli di \textbf{subtour elimination} individuati dalla fase \textit{euristica} dove però il modello matematico di partenza presenta già alcuni vincoli di \textit{subtour elimination}.}.
Esistono innumerevoli modi per rendere euristico il metodo \textbf{Loop}, possiamo suddividerli in tre grandi categorie: della prima fanno parte le tecniche che rendono la risoluzione stessa da parte di \textbf{Cplex} euristica, nella seconda ricadono i metodi che introducono nuovi vincoli al modello matematico ed infine la terza categoria è una semplice combinazione delle due precedenti. All'interno del nostro progetto sono state sviluppate tre varianti della fase \textit{euristica}, una per ogni categoria appena esposta:

\begin{itemize}
    \item \textbf{prima categoria}: durante la risoluzione del problema attraverso la tecnica del \textbf{Branch\&Cut}, Cplex, oltre al banale calcolo della soluzione ottima per ogni nodo dell'albero decisionale, sfrutta internamente algoritmi euristici per agevolare il processo. Durante quest'ultimo si hanno quindi a disposizione due parametri, il primo è il costo della soluzione euristica migliore (\textbf{$C_{eu}$}), mentre il secondo è il classico costo \textbf{lower bound}\footnote{Nel nostro caso sarà il costo della migliore soluzione intera trovato.} (\textbf{$L_{b}$}). \'E importate far notare che questi valori mutano mano a mano che si procede alla costruzione dell'albero decisione, in particolare \textbf{$C_{eu}$} cresce mentre \textbf{$L_{b}$} scende fino a che, teoricamente, non coincidano.
    La distanza \textbf{relativa} tra i due valori viene costantemente monitorata da Cplex e, se questa scende sotto la soglia minima del suo parametro interno \textbf{EpGap}, il processo di risoluzione viene considerato terminato e la miglior soluzione valida trovata viene restituita. Maggiori dettagli riguarda \textit{EpGap} sono forniti nel paragrafo ad esso dedicato LINK!!!!!!!, per ora ci basta dire che se di default è settato ad un valore vicino allo $0$, la sua variazione è proprio ciò che viene utilizzato nel nostro programma all'interno della fase \textit{euristica} del metodo \textit{Loop}.
    Risulta estremamente intuitivo e facilmente verificabile che per una specifica istanza non è possibile a priori determinare quanto velocemente verrà raggiunto un certo gap durante la fase di \textit{Branch\&Cut}. E\' quindi consigliabile eseguire inizialmente il normale metodo \textbf{Loop}, analizzare l'output fornito da Cplex durante la risoluzione ed osservare per quale gap soluzioni successive dell'albero decisionale non producono più miglioramenti sostanziali e\\o richiedono tempi di esecuzione eccessivi. Per quanto detto il valore di \textbf{EpGap} viene lasciato a discrezione dell'utente;
    \item \textbf{seconda categoria}: come precedentemente indicato ad inizio paragrafo, i tempi di risoluzione risultano esponenziali rispetto al numero di variabili che caratterizzano il problema in questione. Limitarne il numero ha pertanto un impatto notevole nella risoluzione del modello matematico ed a tale scopo è possibile decidere di settare a priori il valore assunto da alcune variabili. Tanto migliore risulta essere la previsione così introdotta, migliori saranno i tempi di risoluzione ottenibili sia per la fase \textit{euristica} che quella \textit{esatta} del metodo \textit{Loop}. La scelta da noi effettuata è di lasciare selezionabili per ogni nodo gli $m$ collegamenti a costo minore che lo vedono come un loro vertice. Il numero $m$ è lasciato selezionabile dall'utente e da risultati sperimentali non è consigliabile che si discosti troppo dal valore $10$;
    \item \textbf{terza categoria}: vengono semplicemente combinate le due precedenti;
\end{itemize}

Nei due paragrafi successivi vengono mostrati alcuni dettagli, tra cui quelli realizzativi, per l'utilizzo delle varianti euristiche esposte del metodo \textbf{Loop}.

\subsection*{EpGap}

EpGap risulta essere un parametro interno di Cplex, il cui valore di default è $1e^{-06}$. Indicando con \textbf{bestnode} il miglior valore della funzione obiettivo calcolata ad un nodo dell'albero decisionale attraverso metodi euristici propri di Cplex, e con \textbf{bestInteger} il costo della miglior soluzione intera trovata fino a quel momento, ossia il costo dell'incumbent, qualora la seguente quantità:

$$|bestNode - bestInteger|/(1e-10 + |bestInteger|)$$

risulti inferiore ad \textit{EpGap} il solver si arresta.

Il settaggio del parametro in questione è molto semplice, è sufficiente invocare il metodo \textbf{SetParam} sull'oggetto della classe \textbf{Cplex} che si sta utilizzando come riportato di seguito:

\begin{lstlisting}

cplex.SetParam(Cplex.DoubleParam.EpGap, newValue);

\end{lstlisting}

Essendo \textit{EpGap} un valore di distanza \textbf{relativo} e non \textbf{assoluto}, la variabile \textbf{newValue} deve essere compresa tra i valori $0$\footnote{La risoluzione termina fornendo sempre la soluzione ottima.} e $1$\footnote{La risoluzione termina alla prima soluzione ammissibile individuata.}.

Completato il settaggio di \textit{EpGap} è sufficiente procedere con il normale metodo risolutivo \textbf{Loop}. Al termine di quest'ultimo otteniamo una soluzione euristica ma soprattutto un insieme di vincoli di \textit{subtour elimination}. Entriamo quindi nella fase \textit{esatta} dell'algoritmo riportando al valore di default \textit{EpGap} e ripetiamo il metodo risolutivo \textbf{Loop} sul modello matematico originale ampliato dai nuovi vincoli appena citati.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"InterfacciaGrafica".jpg}
    \caption{Output}
\end{figure}

\subsection*{TITOLO DA CAMBIARE}

Nel paragrafo LINK!!!!!!!!!!!!!!!, è stato presentato il metodo \textbf{BuildModel} della classe \textbf{Utility} il cui compito è di creare il modello matematico, privo dei vincoli di subtour elimination, risolubile da Cplex. Durante la presentazione della sua firma, era stato lasciato in sospeso l'utilizzo del parametro \textit{nEdges} in quanto allora del tutto prematura.

Come specificato nel paragrafo LINK!!!!!!!!!! una variante euristica del metodo \textbf{Loop}, prevede di utilizzare solamente un numero massimo $m$ di lati incidenti in ogni nodo del problema in questione del commesso viaggiatore. Tale parametro è inoltre richiesto all'utente per i motivi già specificati e viene comunicato al metodo \textbf{BuildModel} proprio grazie alla variabile di ingresso \textbf{nEdges}\footnote{Come dettaglio implementativo specifichiamo inoltre che per convenzione si è deciso di settare $nEdges = -1$ nel caso in cui si voglia coistruire un modello con tutti i lati possibili abilitati}.

A livello implementativo, per rendere inutilizzabili certi collegamenti, è sufficiente non inserirli nel modello matematico oppure farlo ma fissandone sia il \textbf{lower} che l'\textbf{upper bound} a 0. Quest'ultima opzione è quella più comoda da utilizzare in quanto nella successiva fase \textit{esatta} dell'algoritmo il modello matematico deve comunque aver disponibili al suo interno tutte le variabili.

L'individuazione algoritmica di quali collegamenti debbano essere abilitati risulta l'operazione più complessa da un punto di vista computazionale. Come vedremo nel corso di questa tesi, diversi algoritmi necessitano di conoscere per ogni nodo l'ordinamento completo dei lati ad esso incidenti basato sul loro costo e per tanto si è definita una unica funzione \textbf{BuildSL} adibita a tale scopo\footnote{In realtà il costo computazionale per trovare gli $m$ lati meno costosi incidenti in un nodo, ripetuto per tutti gli $n$ nodi disponibili, è il medesimo del metodo \textit{BuildSL} e quindi l'utilizzo di quest'ultimo non porta alcuno svantaggio.}.

I dettagli riguardanti al metodo \textbf{BuildSL} sono riportati al seguente paragrafo della appendice LINK!!!!!!!!!!!!!!!, in questo contesto ci basta indicare che essa restituisce una lista di vettori di interi, chiamata \textbf{listArray}, in cui $i-esimo$ elemento contiene, in ordine crescente, la sequenza dei restanti $n-1$ vertici basandosi sulla loro distanza rispetto al nodo $i$. In altre parole, una volta invocato \textit{BuildSL}, i lati il cui \textbf{upper bound} deve essere posto pari ad $1$ sono individuabili dagli estremi $[0,(listArray[0])[0]], [0,(listArray[0])[1]], ..., [0,(listArray[0])[m]], ..., [i,(listArray[i])[0]], ..., [i,(listArray[i])[m]], ..., [n-1,(listArray[n-1])[0]], ..., [n-1,(listArray[n-1])[m]]$.

Di seguito è riportato per completezza il codice all'interno della funzione \textbf{BuildModel} che nel caso di $nEdges \geqslant 1$ sfrutta le informazioni presenti in \textit{listArray} per il settaggio delle variabili del modello matematico:

\begin{lstlisting}

if (nEdges > 0)
{
    List<int>[] listArray = BuildSLComplete(instance);

    for (int i = 0; i < instance.NNodes; i++)
    {
        for (int j = 0; j < nEdges; j++)
        {
            int position = xPos(i, listArray[i][j], instance.NNodes);

            x[position].UB = 1;
        }
    }
}

\end{lstlisting}

Dove chiaramente in precedenza era stato necessario inizializzare tutte le variabili contenute in \textbf{x} come:

\begin{lstlisting}

ILinearNumExpr expr = cplex.LinearNumExpr();


//Populating objective function
for (int i = 0; i < instance.NNodes; i++)
{
    for (int j = i + 1; j < instance.NNodes; j++)
    {
        ////xPos return the correct position where to store the variable corresponding to the actual link (i,i)
        int position = xPos(i, j, instance.NNodes);

        if (nEdges > 0)
            x[position] = cplex.NumVar(0, 0, NumVarType.Bool, "x(" + (i + 1) + "," + (j + 1) + ")");
        else
            ...

        expr.AddTerm(x[position], Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType));
        }
    }
}

\end{lstlisting}

Terminata la costruzione del modello matematico si procede alla sua risoluzione attraverso il classico metodo \textbf{Loop}. Al suo termine, otteniamo una soluzione euristica e soprattutto una lista di vincoli di \textit{subtour elimination}. Per passare alla risoluzione esatta del problema in analisi, manteniamo questi ultimi e settiamo l'\textbf{upper bound} di ogni variabile ad $1$. Questa ultima operazione è ottenibile invocando il metdo \textbf{ResetVariables} appartenente alla classe Utility:


\begin{lstlisting}

public static void ResetVariables(INumVar[] x)
{
    for (int i = 0; i < x.Length; i++)
        x[i].UB = 1;
}

\end{lstlisting}

Dove chiaramente \textbf{x} è il vettore contenente i riferimenti alle variabili utilizzate dal modello matematico da noi definito.

\section*{SEZIONE SEI}

In questa sezione esponiamo una tecnica alternativa per l'inserimento delle espressioni di subtour elimination all'interno di un sistema. Ciò che varia rispetto al metodo \textbf{Loop} presentato in precedenza è il \textbf{momento} in cui tali espressioni vengono definite.\\
L'idea è di sfruttare il fatto che Cplex come metodo di risoluzione per i problemi di \textbf{PLI} utilizza la tecnica del \textbf{Branch\&Cut}\footnote{Da ora in avanti sarà abbreviato con la sigla \textbf{B\&C}}. Viene inoltre offerta la possibilità di conoscere la soluzione trovata, sia essa frazionaria o intera, per ogni nodo dell'albero decisione ma soprattuto la possibilità di ampliare il modello matematico come meglio crediamo.\\
Quello che vogliamo fare risulta a questo punto molto chiaro: se alla analisi della soluzione di un nodo sono presenti subtour il modello matematico deve essere modificato per eliminarli.\\
A livello pratico Cplex permette l'implementazione distinta di callback che vengono eseguite nel momento in cui viene trovata una soluzione intera oppure frazionaria\footnote{In informatica una callback è una funzione definita dall'utente che viene eseguita in automatico dal sistema ogniqualvolta scatta un particolare evento.}: nel primo caso è necessario implementare una \textbf{"lazy constraint callback"} mentre nel secondo caso una \textbf{"user cut callback"}. Da notare che in realtà solo soluzioni valide per i criteri di fathoming possono far scattare una callback, ciò non avviene ad esempio se il valore della soluzione di un nodo risulta maggiore rispetto a quello dell'incumbent\footnote{Per incumbent si intende il valore migliore trovato fino a questo momento relativo ad un soluzione accettabile.}.\\
In generale i tagli possono essere definiti \textbf{locali} o \textbf{globali}: mentre i primi hanno validità esclusiva all'interno del sottoalbero avente come radice il nodo per la quale sono stati generati, i secondi hanno validità per tutti i nodi dell'albero decisionale e vengono memorizzati in una struttura globale detta \textbf{pool di tagli}. Cplex inoltre fornisce la possibilità di definire un taglio \textbf{purgeable} o meno: nel primo caso significa che può essere rimosso in un secondo momento poiché ritenuto inefficace. Durante il proseguo della tesi i tagli saranno da considerarsi sempre globali e non purgeable.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"Callback".jpg}
    \caption{Soluzione frazionaria}
\end{figure}

Prima di procedere con l'esposizione dei dattagli riguardanti l'implementare di tali procedure, è possibile effettuare le seguenti considerazioni:\\

\begin{itemize}
    \item La soluzione ottima fornita da Cplex risulta per costruzione priva di subtour: non è quindi più necessario, al contrario del metodo \textbf{Loop}, lanciare molteplici risoluzioni. A livello pratico è sufficiente invocare solo una volta il metodo \textbf{Cplex.Solve()}.
    \item Maggiore è il numero di vincoli che andiamo ad inserire, maggiore diventa il tempo di risoluzione per i vari nodi successivi dell'albero decisionale.
    \item Il numero di nodi che forniscono soluzioni frazionarie risulta di molto superiore rispetto a quelli con soluzione intera. Tenendo conto di quanto detto al punto precedente, non è quindi saggio andare ad analizzare tutte le soluzioni frazionarie ma solo una loro minima percentuale. Senza questo accorgimento si andrebbe inevitabilmente ad inserire innumerevoli vincoli superflui per l'ottenenimento della soluzione ottima con conseguenti tempi di risoluzione eccessivamente elevati.
    \item I moderni processori hanno a disposizione molteplici core sia reali che virtuali e quindi sfruttare tecniche di multi-threading. In particolare Cplex permette di settare il numero di thread utilizzabili, in modo tale che ognuno di essi si occupi dalla risoluzione di un nodo dell'albero decisionale: in questo modo, in linea teorica, si drovrebbe ottenere un boost delle prestazioni con conseguente riduzione dei tempi di calcolo. D'altro canto, come per qualsiasi applicazione informatica, l'utilizzo del multi-threading risulta rischioso in quanto l'accesso contemporaneo ai medesimi dati può portare ad una loro inconsistenza. Nel nostro caso può capitare che più callback eseguite contemporaneamente vadano a modificare variabili condivise andando così incontro ad eccezioni o anomalie tali da non garantire più la correttezza della soluzione prodotta da Cplex.\\
    Per evitare queste problematiche, i progettisti di Cplex hanno preferito settare il numero di thread al valore \textbf{1} dopo l' installazione di una callback. \'E quindi nostro compito modificare tale parametro così da renderlo pari al numero di processori virtuali a nostra disposizione e di conseguenza assicurarci che le callback risultino \textbf{thread-safe}. Maggiori dettagli sono riportati nei successivi paragrafi.
\end{itemize}

\subsection*{LAZYCONSTRAINT CALLBACK C\#}

Per poter utilizzare una \textbf{lazy constraint callback} in \textbf{C\#} Cplex fornisce all'interno delle proprie librerie la classe astratta \textbf{LazyConstraintCallback} che a sua volta estende \textbf{ControlCallback}. \'E quindi necessario creare una propria classe che estenda quest'ultima, nel nostro caso è stato deciso di chiamarla \textbf{TSPLazyConsCallback}, in questo modo è necessario definire al suo interno il metodo \textbf{Main} che verrà invocato automaticamente dal sistema ogniqualvolta scatta la callback\footnote{Rocordiamo che tutti i metodi astratti presenti all'interno di una classe astratta devono essere obbligatoriamente definiti da tutte le classi che estendono quest'ultima}.\\
Una volta terminato questo processo l'installazione della callback viene eseguita nel seguente modo:

\begin{lstlisting}

cplex.Use(new TSPLazyConsCallback(...));

\end{lstlisting}

Dove, come al solito, cplex è l'instanza della classe \textbf{Cplex} sulla quale definiamo il modello matematico privo dei vincoli di subtour elimination.\\
Mostriamo ora la firma del costruttore della classe \textbf{TSPLazyConsCallback} riportando una breve descrizione dei parametri di ingresso:

\begin{lstlisting}

public TSPLazyConsCallback(Cplex cplex, INumVar[] z, Instance instance, Process process, bool BlockPrint)

\end{lstlisting}

\begin{itemize}
    \item \textbf{cplex}: necessario per l'individuazione dei vincoli di subtour elimination, contiene i dati del modello matematico utilizzato;
    \item \textbf{z}: identico al punto precedente, contiene i riferimenti alla variabili del modello matematico;
    \item \textbf{instance}: necessario nel caso in cui si desideri stampare attraverso GNUPlot le soluzioni intere che hanno fatto scattare la callback;
    \item \textbf{process}: identico al punto precedente;
    \item \textbf{BlockPrint}: è il parametro booleano che determina se procedere o meno con le stampe delle soluzioni intere (se \textbf{true} si procede con la stampa);
\end{itemize}

Come accennato nel paragrafo precedente, l'installazione di una callback setta automaticamente il numero di thread ad uno. Per modificare tale valore, ponendolo pari al numero logico di cores messi a disposizione dal processo in uso, è sufficiente eseguire la seguente riga di codice:

\begin{lstlisting}

cplex.SetParam(Cplex.Param.Threads, cplex.GetNumCores());

\end{lstlisting}

Come sarà possibile vedere più avanti, la tecnica da noi utilizzata per l'individuazione di subtour risulta thread-safe in quanto non vengono utilizzate variabili condivise da più threads se non nella sola modalità di lettura. L'aggiunta di eventuali tagli, d'altro canto, viene gestita in modo automatico da Cplex assicurandoci, anche in questo caso, una procedura thread-safe. Un discorso apparte deve invece essere fatto nel caso in cui la variabile \textbf{BlockPrint} descritta in precedenza sia stata posta a \textbf{true}. Come era logico aspettarsi, abbiamo verificato che spesso la procedura di stampa attraverso GNUPlot di una qualsiasi soluzione richiede un tempo di esecuzione maggiore rispetto la frequenza con cui le callback sono effettuate. Ricordando inoltre che, il metodo da noi utilizzato per comunicare a GNUPlot le coordinate cartesiane dei punti del grafo cartesiano prevede la scrittura di queste ultime in un apposito file di testo, è stato necessario individuare un modo per evitare problemi riguardanti il multi-threading: utilizzare sempre lo stesso file di testo causa infatti errori nella stampa dei grafi, in particolare la lettura delle coordinate da parte di GNUPlot risulta troppo lenta e durante questo processo più thread rischiano di modificare il file con le proprie coordinate.\\
Per evitare questo problema è stato quindi necessario stampare le coordinate prodotte dai vari nodi dell'albero decisionale in differenti files. A tal proposito la tecnica da noi scelta è stata quella di inserire nel nome di questi ultimi anche l'id numerico del nodo a loro associato che viene fornito dirretamente da Cplex:


\begin{lstlisting}

string nodeId = GetNodeId().ToString();

...

string fileName = instance.InputFile + "_" + nodeId;

\end{lstlisting}

La funzione \textbf{GetNodeId} risulta disponibile in quanto ereditata dalla classe \textbf{ControlCallback}.\\
Dopo i dovuti chiarimenti riguardanti il multi-threading passiamo ora a descrivere nei dettagli come è stata realizzato il metodo Main della classe TSPLazyConsCallback. Prima di tutto per verificare l'eventuale presenza di subtour bisogna naturalmente accedere alla soluzione fornita per il nodo dell'albero decisionale in questione: a tal fine si possono utilizzare i metodi \textbf{GetValues} e \textbf{GetValue}, ereditati entrambi dalla classe ControlCallback, che ricevono in input rispettivamente un vettore di riferimenti per variabili del modello matematico e un singolo riferimento ad una variabile di quest'ultimo. Dopo pochi test ci si accorge immediatamente che invocare più volte il metodo \textbf{GetValue}, ad esempio dentro un ciclo for, risulta molto più oneroso in termini temporali rispetto una singola evocazione del metodo \textbf{GetValues}: si può quindi dedurre che è molto più dispendioso effettuare multiplici accessi all'interfaccia fornita da Cplex rispetto alla quantità di dati che ad essa richiediamo.\\
Per quanto appena detto la nostra scelta è ricaduta nel metodo \textbf{GetValues} che restituisce un vettori di \textbf{double} contenente il valore dell variabili (il cui riferimento è ricevuto come ingresso) nella soluzione corrente del modello matematico. Da notare che anche in questo caso anche se ci aspettiamo tutti valori interi, in particolare pari a 0 oppure 1, è possibile che ci siano in realtà discostamenti infinitesimi pertanto quando controlliamo il valore di una variabile verifichiamo semplicemente se è maggiore o minore del valore 0,5.\\
I metodi utilizzati per l'individuazione di eventuali subtour e la eventuale stampa del grafo attraverso GNUPlot sono identici a quelli utilizzati per il metodo \textbf{Loop} pertanto non sono qui riportarti.\\
Una volta ottenute tutte le informazioni riguardanti i subtour, al contrario di quanto viene fatto nel metodo Loop non è richiesto di ampliare direttamente il modello con nuovi vincoli ma, come era già stato accennato in precedenza, deve essere popolato il pool di tagli associato al modello matematico:

\begin{lstlisting}

IRange[] cuts = new IRange[ccExprLC.Count];

//if cuts.Length is 1 the graph has only one tour then cuts aren't needed
if (cuts.Length > 1)
{
    for (int i = 0; i < cuts.Length; i++)
    {
        cuts[i] = cplex.Le(ccExprLC[i], bufferCoeffCCLC[i] - 1);
        Add(cuts[i], 1);
    }
}

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{cuts}: è un vettore di \textbf{IRange} che sono la struttura di dati base fornita da Cplex per memorizzare espressioni lineari;
    \item \textbf{ccExprLC[i]}: analogamente per quanto avviene nel metodo Loop, contiene i dati delle variabili dell'i-esimo taglio memorizzati come \textbf{ILinearNumExpr} (struttura dati fornita da Cplex);
    \item \textbf{bufferCoeffCCLC[i]}: analogamente per quanto avviene nel metodo Loop, contiene il numero di variabili che definiscono l'i-esimo taglio;
    \item \textbf{cplex.Le}: è la funzione definita da Cplex che restituisce una espressione lineare che impone le variabili, ricevute come primo parametro, minori oppure uguali del secondo parametro ricevuto;
    \item \textbf{Add}: è la funzione eraditata dalla classe \textbf{LazyConstraintCallback} che permette di aggiungere un taglio \textbf{globale}. Come parametri riceve quindi il taglio stesso ed un valore intero che indica a Cplex come debba gestire quest'ultimo:
    \begin{itemize}
        \item \textbf{0}: il taglio è aggiunto al pool in maniera permanente;
        \item \textbf{1}: il taglio è definito come \textbf{purgeable} quindi eliminabile nel caso in cui non risulti più efficiente;
        \item \textbf{2}: il taglio viene trattato come se fosse stato generato da Cplex, quindi ad esempio prima di essere aggiunto al pool viene analizzata la sua efficacia e di conseguenza l'operazione va quindi a buon fino o meno;
    \end{itemize}

\end{itemize}

\subsection*{CONCORDE}

L'utilizzo di una \textbf{user cut callback} risulta molto più complicato rispetto a quanto appena visto per la \textbf{lazy constraint callback}: dato che tali callback scattano nel momento in cui viene trovata una soluzione frazionaria, l'individuazione di eventuali subtour non può essere eseguita con le tecniche esposte fino ad ora.\\
Per effetturare tale operazione si necessita di un separatore che, ricevendo in ingresso la soluzione x* con almeno una componente frazionaria, fornisca in uscita un insieme $S\subsetneq{V}$, $|S|\geq{2}$ tale per cui:

\begin{equation}\label{eq:concorde1}
\displaystyle{\sum_{\left ( i,j \right )\in E\left ( S \right )} x_{i,j}^{*}\nleqslant \left | \widehat{S} \right |-1}
\end{equation}

Tale sottoinsieme non è facilmente individuabile come nel caso di soluzione intere in cui era sufficiente individuare le componenti connesse. Per esempio in Figura 3 si è riportato il supporto di una soluzione x* frazionaria ove i lati colorati di rosso, blu e grigio indicano che la corrispondente variabile assumme rispettivamente i valori 1, 0.5 , 1.5.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"SoluzioneFrazionaria".jpg}
    \caption{Soluzione frazionaria}
\end{figure}

Tale grafo risulta connesso; tuttavia è presente un sottoinsieme S = {1,2,3} per cui vale \eqref{eq:concorde1}.\\
Una seconda formulazione equivalente alla \eqref{eq:concorde1} risulta essere la seguente:

\begin{equation}\label{eq:concorde2}
\displaystyle{\sum_{\left ( i,j \right )\in \delta \left ( S \right )} x_{i,j}^{*}\ngeqslant 2}
\end{equation}

Si osserva che il primo membro di \eqref{eq:concorde2} può essere visto come la capacità di una sezione di una rete di flusso se si interpretano le x* come le capacità della rete.
E' possibile calcolare una sezione di capacità minima risolvendo un problema di max flow che sappiamo essere di programmazione lineare e quindi risolubile attraverso un algoritmo polinomiale.\\
Poichè però la sezione di capacità minima dipende dal nodo sorgente \textit{s} e dal nodo di destinazione \textit{t}, si devono in realtà risolvere \textbf{n-1} problemi di max flow: per tale ragione è stato preferito utilizzare una porzione del software \textbf{Concorde} che offre, attraverso le proprie librerie, la possibilità di risolvere tale problema con tempi di esecuzione molto brevi ed allo stesso tempo di alleggerire il nostro carico di lavoro che in ogni caso non avrebbe prodotto risultati migliori.\\
Concorde è un software, sviluppano in linguaggio \textbf{C} da David Applegate, Robert E. Bixby, Vašek Chvátal, e William J. Cook, specializzato nella risoluzione ottimizzata di istanze del problema del commesso viaggiatore. Per fini accademici la distribuzione e l'utilizzo è fornita in modo gratuito e le librerei possono essere scaricate direttamente dal seguente indirizzo:
\begin{center}
\href{http://www.math.uwaterloo.ca/tsp/concorde/downloads/downloads.htm}{http://www.math.uwaterloo.ca/tsp/concorde/downloads/downloads.htm}
\end{center}

Come accennato poco fa il linguaggio utilizzato da Concorde non è \textbf{C\#} bensì \textbf{C} pertanto una implementazione diretta del software non è possibile. La soluzione da noi adottata è la seguente: abbiamo creato un nuovo progetto Visual Studio in linguaggio \textbf{C/C++} ed al suo interno abbiamo creato un codice che soddisfacesse unicamente alla funzionalità ambedue i tipi di callback proposti interfacciandosi alle librerie di Concorde per trovare i vincoli di subtour elimination ed aggiungerli al modello matematico. Successivamente il tutto è stato impachettato all'interno di una \textbf{DLL} compatibile con il linguaggio \textbf{C\#}. Il processo di creazione della DLL è stato spiegato nel seguente paragrafo LINK!!!!!!!!!!!!!!!!!!!!, d'ora in avanti quindi ci focalizzeremo unicamente nel contenuto della libreria dinamica da noi creata.\\

Per poter utilizzare Concorde in ambiente Windows è necessario importare ogni singolo file .c e .h che appartiene alla distribuzione: nel nostro caso però solo una minima parte delle sue funzionalità è di nostro interesse e pertanto solamente i seguenti file sono stati da noi utilizzati:


\begin{itemize}
    \item \textbf{allocrus.c}
    \item \textbf{connect.c}
    \item \textbf{cut\_st.c}
    \item \textbf{mincut.c}
    \item \textbf{shrink.c}
    \item \textbf{sortrus.c}
    \item \textbf{urandom.c}
    \item \textbf{cut.h}
    \item \textbf{machdefs.h}
    \item \textbf{macrorus.h}
    \item \textbf{util.h}
    \item \textbf{end}
\end{itemize}

Dove affinché il programma compili correttamente, è necessario effettuare le seguenti modifiche:

\begin{itemize}
    \item All'interno dei file \textbf{allocrus.c} e \textbf{util.h} è necessario importare tramite il comando \textbf{import} l'header \textbf{malloc.h}.
    \item All' interno del file \textbf{machdefs.h} è necessario eliminare l'inclusione di \textbf{config.h}.
\end{itemize}

\subsection*{LAZYCONSTRAINTCALLBACK IN C}

In questa mostreremo solamente i dettagli per l'installazione e l'utilizzo delle \textbf{lazyconstraint callback} in linguaggio \textbf{C} in quanto un discorso più ampio è stato precedentemente in LINK!!!!!!!!!.
L'installazione di questo tipo di callback avviene attraverso l'invocazione della routine \textbf{CPXsetlazyconstraintcallbackfunc} la cui firma è:

\begin{lstlisting}

CPXsetlazyconstraintcallbackfunc(CPXENVptr env,int(*)(CALLBACK\_CUT\_ARGS) lazyconcallback, void * cbhandle)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{env}: Espressione contenente una combinazione lineare delle variabili del vincolo; SIAMO SICURI!!!!???!??!
    \item \textbf{lazyconcallback}: Rappresenta il nome, attribuito dal programmatore esterno, della funzione che viene invocata da Cplex qualora la soluzione del rilassamento continuo di un nodo abbia valore intero ed inferiore all'incumbent. Nel nostro caso il nome assunto è \textbf{myLazyCallBack};
    \item \textbf{cbhandle}: Puntatore ad una struttura dati passata dall'utente contenente le informazioni che devono essere visibili all'interno della callback \textit{myLazyCallBack}. Come parametro si è passato il puntatore all'istanza;
\end{itemize}

In modo del tutto analogo a quanto fatto per \textbf{C\#}, per impostare il numero di thread pari ai core virtuali offerti dalla macchina in utilizzo si sono utilizzati i metodi \textbf{CPXsetintparam} e \textbf{CPXgetnumcores}:

\begin{lstlisting}

CPXgetnumcores(env, int * nCore);
CPXsetintparam(env, CPXPARAM\_Threads, nCore);


\end{lstlisting}

Passiamo ora a descrivere la funzione \textit{myLazyCallBack} che identifica i subtour ed aggiunge i relativi vincoli al modello, ricordando che la sua firma deve rispettare specifici parametri definiti da Cplex stesso\footnote{Essendo tali funzioni invocate automaticamente da Cplex i tipi di parametri che esse ricevono sono stati definiti a priori e non risultano modificabili}:

\begin{lstlisting}

static int CPXPUBLIC myLazyCallBack(CPXCENVptr env, void *cbdata, int wherefrom, void *cbhandle, int *useraction\_p)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{env}: rappresenta l’istanza dell’ enviroment con il quale stiamo lavorando. DIVERSO DA SOPRA!!!!!!!!
    \item \textbf{cbdata}: come accennato poco fa questo parametro è quello specificato dall'utente durante l'installazione della callback, non essendo noto a priori il tipo di dato che l'utente desidera ricevere si utilizza \textbf{void};
    \item \textbf{wherefrom}: definisce da che punto del \textit{B\&C} è stata invocata la funzione, ai fini pratici tale parametro, per la lazy callback è risultato irrilevante;
    \item \textbf{cbhandle}: puntatore a dati privati utilizzato da Cplex;
    \item \textbf{useraction\_p}: puntatore ad un intero utilizzato dall'utente per comunicare a Cplex diverse informazioni. Tale parametro può assumere i seguenti tre valori:
    \begin{itemize}
    \item \textbf{0}: avente come costante simbolica CPX\_CALLBACK\_DEFAULT comunica a Cplex che fino a quel punto la callback non ha aggiunto tagli al modello;
    \item \textbf{1}: avente come costante simbolica CPX\_CALLBACK\_FAI impone a Cplex di uscire dall'ottimizzazione;
    \item \textbf{2}: avente come costante simbolica CPX\_CALLBACK\_SET comunica a Cplex che sono stati aggiunti tagli;
    \end{itemize}

\end{itemize}

La prima operazione da compiere consiste nell effettuare un cast al puntatore \textbf{cbhandle} il cui tipo è noto solo al programmatore che ha installato la callback: nel nostro caso il puntatore è di tipo \textbf{instance} per cui:


\begin{lstlisting}

instance *inst = (instance*)cbhandle;

\end{lstlisting}

Successivamente è necessario assegnare al parametro \textbf{*useraction\_p} il valore \textbf{CPX\_CALLBACK\_DEFAULT}.

Per ottenere la soluzione del rilassamento continuo è necessario utilizzare il metodo \textbf{CPXgetcallbacknodex} avente come intestazione:

\begin{lstlisting}

int CPXgetcallbacknodex(CPXCENVptr env, void * cbdata, int wherefrom, double * x, int begin, int end) 

\end{lstlisting}

Dove:

\begin{itemize}
    \item Per quanto riguarda env, cbdata, wherefrom vale la descrizione vista per il metodo myLazyCallBack;
    \item \textbf{x}: array che al termine del metodo conterrà la soluzione intera del rilassamento continuo;
    \item \textbf{begin}: indica l’indice della prima variabile di cui si vuole conoscere il valore;
    \item \textbf{end}: indica l’indice dell’ultima variabile di cui si vuole conoscere il valore;
\end{itemize}

Nel nostro caso dato che vogliamo conoscere tutte le variabili, assegniamo i valori \textbf{$0$} e \textbf{$[n*(n-1)/2] – 1$} rispettivamente ai parametri \textbf{begin} ed \textbf{end}.

All'atto dell'invocazione del metodo \textit{CPXgetcallbacknodex} non viene passato come parametro l'array \textbf{bestLb} contenuto in \textit{inst} ma viene creato un opportuno array chiamato \textbf{xstar}:

\begin{lstlisting}

double *xstar = (double*)malloc(inst->nCols * sizeof(double));

\end{lstlisting}

Questa operazione risulta necessaria al fine di realizzare un codice che risulti thread-safety: poiché \textit{inst} è un puntatore accessibile da tutti i thread esiste il rischio di accessi multipli sia in modalità di lettura popolando così \textit{bestLb} con valori appartenti a soluzioni differenti.
A questo punto entra in gioco Concorde per l'individuazione e l'introduzione dei vincoli di subtour elination, dato che il metodo da utilizzare è il medesimo che vedremo per le \textit{usercut callback} rimandiamo al paragrafo seguente per maggiori dettagli.
Una volta completato tale passaggio non rimane altro che impostare il parametro \textbf{*useraction\_p} al valore \textbf{CPX\_CALLBACK\_SET} al fine di comunicare a Cplex che sono stati aggiunti tagli.

\subsection*{USERCUT CALLBACK IN C}

Come già anticipato nei precedenti paragrafi questo tipo di callback sono utilizzate per gestire soluzioni frazionarie ottenute per i vari nodidell'albero decisionale durante una risoluzione di tipo \textit{B\&C} per problemi di programmazione lineare da parte di Cplex. A livello concettuale sono del tutto simili a quanto visto nel paragrafo precedente per le \textit{lazy callback} in linguaggio \textbf{C}, è raccomandata una lettura del paragrafo precedente a loro dedicato in quanto di seguito saranno esposti estensivamente solamente i dettagli riguardanti la gestione dei tagli.\footnote{Notiamo in realtà che l'implementazione delle \textit{usercut callback} avviene sempre in concomitanza all'implementazione delle \textit{lazy callback} per tanto il settaggio del numero di thread è necessario solamente una volta}.

L'installazione delle callback avviene tramite la funzione \textbf{CPXsetusercutcallbackfunc}:

\begin{lstlisting}

int CPXsetusercutcallbackfunc (CPXENVptr env, int(*)(CALLBACK\_CUT\_ARGS) lazyconcallback, void * cbhandle)

\end{lstlisting}

La funzione invocata da Cplex in corrispondenza di una soluzione frazionaria è stata da noi chiamata \textbf{myUserCutCallBack} la cui firma, che anche in questo caso viene imposta dai progettisti di Cplex, risulta essere:

\begin{lstlisting}

int CPXPUBLIC myUserCutCallBack(CPXCENVptr env, void *cbdata, int wherefrom, void *cbhandle, int *useraction\_p)

\end{lstlisting}

Cplex, una volta calcolata una soluzione frazionara, genera in automatico dei propri tagli\footnote{Ad esempio taglio di \textit{Gomory}}. Quando il parametro \textit{wherefrom} risulta pari a \textbf{CPX\_CALLBACK\_MIP\_CUT\_LAST} significa che l'iterazione successiva da parte di Cplex consisterebbe nell'operazione di branching sul nodo in questione: solo in questa condizione risulta conveniente generare i propri vincoli caratteristici del problema che si sta risolvendo. Qualora il parametro \textit{wherefrom} assuma invece altri valori, si effettua una semplice \textbf{return 0} senza eseguire alcuna operazione, altrimenti come già discusso per le lazy, è necessario recuperare il puntate all’istanza.
Riprendendo quanto detto nel paragrafo LINK PARAGRAFO CALLBACK||||| è sconsigliato aggiungere \textit{manualmente} ad ogni nodo dell’albero decisionale dei tagli in quanto il loro numero complessivo risulterebbe troppo elevato andando quindi a \textbf{peggiorare} le prestazioni di Cplex. Per tale ragione, dopo alcuni test e secondo le linee guida discusse durante il corso, si è deciso che solamente con una probabilità del \textbf{$10\%$} la \textit{usercut callback} da noi definita entra in gioco. Dato che l'id numerico assegnato ai nodi dell'albero decisionale, ottenuto attraverso al funzione \textbf{CPXgetcallbacknodeinfo}, non ha alcuna relazione diretta alla probabilità che venga generata una soluzione intera oppure frazionaria, è sufficiente effettuare una operazione di modulo dieci a tale valore: nel caso in cui il risultato sia pari a zero si procede con il calcolo dei tagli. Successivamente, invocando la nota funzione \textbf{CPXgetcallbacknodex} si ottiene la soluzione frazionaria. Prima di procedere con la parte principale di questo metodo, per ragioni di chiarezza riportiamo il codice che esegue quanto finora descritto:


\begin{lstlisting}

*useraction\_p = CPX\_CALLBACK\_DEFAULT;
    
int nodecount = 0;
CPXgetcallbacknodeinfo(env, cbdata, wherefrom, 0, CPX\_CALLBACK\_INFO\_NODE\_DEPTH, &nodecount);
    
if (wherefrom == CPX\_CALLBACK\_MIP\_CUT\_LAST)
{
    instance *inst = (instance*)cbhandle;
        
    double *xstar = (double*)malloc(inst->nCols * sizeof(double));

     if ((nodecount % 10) != 0)
        return 0;

    if (CPXgetcallbacknodex(env, cbdata, wherefrom, xstar, 0, inst->nCols - 1))
    {
        free(comps);
        free(compscount);
        free(xstar);
        free(elist);
        return 1; 
    }
}

\end{lstlisting}


Da questo momento inizieremo ad utilizzare le funzionalità offerta da \textit{Concorde}, tutte le funzioni il cuo nome inizia con la sigla \textbf{"CC"} sono importate da quest'ultimo.
L'aggiunta di eventuali vincoli di \textit{subtour elimination} avviene tramite l'invocazione in un primo momento della funzione \textbf{CCcut\_connect\_components} la quale identifica le componenti connesse della soluzione ricevuta come parametro indipendentemente dal fatto che sia intera o frazionaria.

Di seguito sono riportati nel dettaglio tutti i parametri che tale funzione vuole ricevere in ingresso, si osserva che mentre i primi 4 costituiscono l'effettivo input della funzione i rimanenti 3 sono in realtà settata al suo interno e quindi possono essere visti come parametri di output:

\begin{itemize}
    \item \textbf{ncount}: rappresenta il numero di nodi del grafo;
    \item \textbf{econut}: rappresenta il numero di lati del grafo, ossia ncount*(ncount-1)/2;
    \item \textbf{*elist}: vettore di dimensione $2*econut$, contiene al suo interno tutti i lati del grafo caratterizzati dai nodi sul quale esso incide memorizzati in locazioni consecutive dell’array, è stato da noi realizzato nel seguente modo:
    
    \begin{lstlisting}
    
    int loader = 0;
    for (int i = 0; i < inst->nNodes;  i++)
    {
        for (int j = i + 1; j < inst->nNodes;  j++) 
        {
            elist[loader++] = i;
            elist[loader++] = j;
        }
    }
    
    \end{lstlisting}
    
    \item \textbf{*x}: soluzione per la quale si desiderano individuare le componenti connesse;
    \item \textbf{*ncomp}: rappresenta il numero di componenti connesse;
    \item \textbf{**compscount}: vettore di vettori contenenti il numero di nodi per ciascuna componente connessa, è strutturato in modo che compscount[i] contenga il numero di nodi presente nell’i-esima componente connessa;
    \item \textbf{**comps}: vettore di vettori contenenti gli indici dei nodi presenti all'interno delle componenti;
\end{itemize}

Nonostante non risulti necessario, al fine di rendere il codice maggiormente leggibile, si è deciso di assegnare sia alle variabili che ai puntatori il medesimo nome che assumono all’interno di \textit{CCcut\_connect\_components}.

\begin{lstlisting}

int *compscount = (int*)malloc(inst->nMaxCuts * sizeof(int));
int *comps = (int*)malloc(inst->nNodes * sizeof(int));
int nLati = ((inst->nNodes - 1)*inst->nNodes / 2);
int *elist = (int*)malloc((nLati * 2) * sizeof(int));
int ncomp; 

\end{lstlisting}

La chiamata alla funzione risulta quindi essere:

\begin{lstlisting}
if (CCcut\_connect\_components(inst->nNodes, nLati, elist, xstar, &ncomp, &compscount, &comps))
    printError(" error in CCcut\_connect\_components() inside fractcutusercallback");
\end{lstlisting}

Al suo termine, in modo del tutto trasparente, otteniamo le tre variabili \textbf{ncomp}, \textbf{compscount} e \textbf{comps} che forniscono tutte le informazioni necessarie all'aggiunta dei tagli all'interno dell'apposito pool fornito da Cplex.
Completiamo quest'ultima operazione tramite la routine fornita da Cplex \textbf{CPXcutcallbackadd} la cui firma è:

\begin{lstlisting}

CPXcutcallbackadd(CPXCENVptr env,void * cbdata,int  wherefrom,int  nzcnt, double  rhs,int sense,int cutind,double const *  cutval, int purgeable);

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{env,cbdata,wherefrom}: parametri noti già discussi nella callback myLazyCallback;
    \item \textbf{nzcnt}: numero di coefficienti diversi da zero del vincolo;
    \item \textbf{rhs}: definisce il termine noto del vincolo;
    \item \textbf{sense}: può assumere i seguenti valori:
    
    \begin{itemize}
    \item \textbf{cutind}: array di \textit{nzcnt} elementi contenenti gli indici delle variabili presenti nel vincolo;
    \item \textbf{cutval}: array di \textit{nzcnt} elementi contenenti i corrispondenti valori dei coefficienti;
    \item \textbf{purgeable}: valore intero che specifica come Cplex deve trattare il taglio:
    
        \begin{itemize}
        \item \textbf{CPX\_USECUT\_FORCE}: il taglio una volta aggiunto al rilassamento non può essere più rimosso;
        \item \textbf{CPX\_USECUT\_PURGE}: il taglio è aggiunto al rilassamento ma può essere eliminato in un secondo momento se giudicato inefficiente;
        \item \textbf{CPX\_USECUT\_FILTER}: il taglio deve essere trattato come se generato da Cplex il quale prima di aggiungerlo al rilassamento lo analizza e può quindi decidere di abortire l'operazione di aggiunta.
        nel rilassamento(per esempio è già presente un taglio più efficiente);
        \end{itemize}
    \end{itemize}
\end{itemize}

Per aggiungere un taglio per ogni componente connessa è necessario popolare i vettori \textbf{cutval}, \textbf{cutind} e la variabile \textbf{nzcnt} opportunamente sfruttando le informazioni fornite da \textit{Concorde}. Per stabilire quali nodi appartengono alla t-esima componente connessa si sono dichiarate due variabili intere \textbf{k1} e \textbf{k2} che contengono sistematicamente l'indice del \textbf{primo} e dell'\textbf{ultimo} nodo tra quelli appartenenti alla t-esima componente connessa memorizzata in \textit{comps}. Si osserva che \textit{k2} è inizializzato al valore \textbf{$-1$} in quanto gli indici di un qualsiasi vettore partono da $0$.

\begin{lstlisting}

    if (ncomp > 1)
        {
            int k1 = 0;
            int k2 = -1;

            for (int c = 0; c < ncomp; c++)
            {
                int dimIndexValue = compscount[c] * (compscount[c] - 1) / 2; 
                int *cutind = (int*)malloc(dimIndexValue * sizeof(int));
                double *cutval = (double*)malloc(dimIndexValue * sizeof(double));
                int nzcnt = 0;

                
                k2 += compscount[c];

                for (int i = k1; i < k2; i++)
                {
                    for (int j = i + 1; j <= k2; j++)
                    {
                        cutval[nzcnt] = 1.0;
                        cutind[nzcnt] = xPos(comps[i], comps[j], inst);
                        nzcnt++;
                    }
                }

                k1 = k2 + 1;
                
                CPXcutcallbackadd(env, cbdata, wherefrom, nzcnt, compscount[c] - 1, 'L', cutind, cutval, CPX\_USECUT\_FORCE);

                *useraction\_p = CPX\_CALLBACK\_SET; 
                free(cutind);
                free(cutval);
            }

            free(elist);
            free(comps);
            free(compscount);
            free(xstar);


            return 0;
        }

\end{lstlisting}

Nel caso in cui la soluzione presenti una sola componente connessa, come in Fig. X, invocando la funzione \textbf{CCcut\_violated\_cuts} di \textit{Concorde} è possibile individuare gli insiemi $S$ che soddisfino la disuguaglianza \eqref{eq:concorde2}: noto $S$ risulta poi banale inserire il relativo vincolo di subtour. In particolare \textit{CCcut\_violated\_cuts} è una funzione in grado di individuare sezioni di capacità inferiori ad una certa soglia. Descriviamo quindi i 7 parametri che tale funzione riceve in input:

\begin{itemize}
    \item \textbf{int ncount}, \textbf{int ecount}, \textbf{int *elist}: il loro significato è già stato descritto per la funzione \textit{CCcut\_connect\_components};
    \item \textbf{dlen}: vettore contenente la capacità di ogni lato;
    \item \textbf{cutoff}:[Questo è il termine noto della disequazione f2, non ho capito perchè devo togliere a 2 un EPSILON, così è scritto nel pdf condiviso dal prof che si chiama         RO2\_TSPutilities]
    \item \textbf{(*(doit\_fn)(double, int, int *, void *) }: è una funzione creata da noi che risulta essere una vera e propria callback: ogniqualvolta \textit{Concorde} individua un insieme $S$ cercato tale funzione viene invocata. Al suo interno, grazie ai parametri forniti\footnote{Maggiori dettagli riguardo i quattro parametri di ingresso saranno forniti a breve durante la descrizione di come l'implementazione di tale funzione è stata da noi realizzata.} è nostro compito procedere all'ampliamento del pool di tagli di \textit{Cplex}.
    \item \textbf{pass\_param}: puntatore ad una struttura dati contenente variabili e puntatori che devono essere accessibili all’interno della callback;
\end{itemize}

Nel nostro caso l'invocazione di tale metodo avviene nel seguente modo:

\begin{lstlisting}

CCcut_violated_cuts(inst->nNodes, inst->nCols, elist, xstar, 2.0 - cutThreshold, doitFuncConcorde, (void*)&in)

\end{lstlisting}

Dove occorre solamente far notare che la funzione callback da noi definita prende il nome \textbf{doitFuncConcorde} mentre l'ultimo parametro è una \textbf{struct} da noi creata contenente al suo interno tutte le informazioni occorrenti per invocare il metodo \textbf{CPXcutcallbackadd}, descritto in precedenza, all'interno della callback.

\begin{lstlisting}

typedef struct 
{
    instance *inst;
    CPXCENVptr env;
    void *cbdata;
    int wherefrom;
    int *useraction\_p;
} inputCC;

\end{lstlisting}

Per concludere questo paragrafo non rimane altro che parlare più in dettagli riguardo la realizzazione della callback \textbf{doitFuncConcorde}, per prima cosa forniamo la sua firma:

\begin{lstlisting}

int doitFuncConcorde(double cutValue, int cutcount, int *cut, void *inParam)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{cutValue}: rappresenta il valore del taglio;
    \item \textbf{cutcount}: rappresenta il numero dei nodi;
    \item \textbf{cut}: array contenente l'indice associato ai nodi;
    \item \textbf{inParam}: struttura dati appena descritta;
\end{itemize}

Dopo aver effettuato la classica operazione di recupero del puntatore alla struttura dati fornita in ingresso alla callback

\begin{lstlisting}

inputCC *in = (inputCC*)inParam;

\end{lstlisting}

possiamo procedere con l'aggiunta del taglio  attraverso \textit{CPXcutcallbackadd}: si sono così definiti due array di interi \textbf{cutind} e \textbf{cutval} contenenti rispettivamente gli indici delle variabili che costituiscono il taglio ed il relativo coefficiente. Si è inoltre dichiarata una variabile intera \textbf{nzcnt} che contiene il numero di variabili caratterizzanti il taglio:

\begin{lstlisting}

int dimIndexValue = inst->nNodes * (inst->nNodes - 1) / 2;
int *cutind = (int*)malloc(dimIndexValue * sizeof(int));
double *cutval = (double*)malloc(dimIndexValue * sizeof(double));
int nzcnt = 0;

    for (int i = 0; i < cutcount - 1; i++)
    {
        for (int j = i + 1; j <= cutcount - 1; j++)
        {
            int n1 = cut[i];
            int n2 = cut[j];
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            METTI QUA IL COMMENTO A xPos che avevi fatto... il codice va commentato !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            cutind[nzcnt] = xPos(n1, n2, inst);
            cutval[nzcnt] = 1.0;
            nzcnt++;
        }
    }
CPXcutcallbackadd(in->env, in->cbdata, in->wherefrom, nzcnt, cutcount - 1, 'L', cutind, cutval, CPX\_USECUT\_FORCE);

*in->useraction\_p = CPX\_CALLBACK\_SET;

free(cutind);
free(cutval);

return 0;

\end{lstlisting}

\section*{SEZIONE 7}

Fino a questo momento sono stati presentati algoritmi che, alla loro naturale terminazione, garantiscono di risolvere una generica istanza del problema del commesso viaggiatore in modo esatto, ovvero restituendo sempre un ottimo globale come soluzione.
L'applicazione di metodi esatti non è sempre possibile per due motivi principali: il primo è che si necessita di un programma di calcolo molto potente ed in genere costoso come può essere \textbf{Cplex}, in secondo luogo, quando si procede all'analisi di problemi \textbf{NP-hard}, indipendentemente da quali accorgimenti introduciamo, non è mai garantito di trovare la soluzione migliore in tempi relativamente brevi.
Per tali ragioni, nelle applicazioni reali, capita spesso che l'unica strada percorribile sia il ricorrere a metodi \textit{non esatti}, che, come abbiamo già potuto vedere nelle varianti del metodo \textbf{Loop} presentate, prendono il nome di algoritmi euristici: la soluzione che offrono sarà sempre ammissibile ma non viene garantità la sua ottimilità, al contrario nella maggior parte dei casi, soprattutto per istanze complesse, questa non viene quasi mai raggiunta. \'E inoltre tenere ben presente che esistono molteplici algoritmi euristici più o meno potenti, essendo inoltre tecniche non esatte, è possibile trovarne infinite varianti per ognuno di essi. In generale, come meglio vedremo nel seguito del testo, possiamo classificarli in \textbf{costruttivi}, \textbf{migliorativi}, \textbf{metaeuristici} e \textbf{matheuristics}.
Quanto esposto fino ad ora ci porta intuitivamente a pensare che la bontà di un metodo proposto può subire enormi variazioni in base a quali istanze su cui viene applicato.

\subsection*{ALGORITMI COSTRUTTIVI GREEDY}

Gli algoritmi costruttivi hanno la caratteristica di determinare una soluzione ammissibile partendo da una \textit{vuota}. Quest'ultima, durante tutto il corso dell'agoritmo, seguendo il criterio di espansione, viene continuamente aggiornata ed ampliata attraverso l'introduzione di nuove componenti fintanto che non diviene completa e quindi ammissibile.
Una sottocategoria molto importante degli algoritmi costruttivi viene definita come \textbf{greedy}: la soluzione euristica al problema è ottenuta attraverso una sequenza \textit{finita} di decisioni "localmente ottime". In altre parole, attraverso una struttura ricorsiva, ad ogni sua iterazione, la soluzione parziale viene aggiornata con l'aggiunta dell'elemento migliore disponibile in quel momento. La correttezza di queste operazione non deve però mai essere verificata runtime dell'algoritmo ma solamente a livello teorico durante la sua fase di progettazione. |'E proprio questa caratteristica che motiva il nome \textit{greedy} e soprattutto rende tali algoritmi estremamente velociti.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"ProceduraGreedy".jpg}
    \caption{Algoritmo Greedy}
\end{figure}

Nella procedura, \textbf{S} è l'insieme degli elementi di \textbf{E} che sono stati inseriti nella soluzione parziale corrente mentre \textbf{Q} è l'insieme degli elementi appartenenti ad \textbf{E} ancora da esaminare.
La procedura fa uso della sottoprocedura \textbf{Best} la quale fornisce il miglior elemento di \textbf{E} tra quelli ancora in \textbf{Q} sulla base di un prefissato criterio euristico.
Come esempio della categoria di algoritmi euristici costruttivi greedy presentiamo nel paragrafo seguente la tecnica del \textbf{nearest neighbour}.

\subsection*{ALGORITMO NEAREST NEIGHBOUR}

L'algoritmo \textbf{nearest neighbour} è stato uno dei primi algoritmi utilizzati per risolvere istanze del problema del commesso viaggiatore. La sua dimostrazione di correttezza non viene qui riportata in quanto non risulta di interesse ai fine del nostro progetto ed è inoltre ampiamente discussa in letteratura. Limitiamoci quindi ad una descrizione del concetto fondamentale alla base dell'algoritmo: dato un qualsiasi percorso (soluzione) parziale, il modo migliore per ampliarlo è banalmente attraverso l'aggiunta di un nuovo arco a costo \textbf{minore} avente come estremi uno dei due nodi liberi\footnote{Nodi attraversati del percorso parziale ma aventi un solo lato incidente.} del percorso stesso mentre il secondo sia uno ancora disponibile\footnote{Non ancora attraversato dal circuito parziale.}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"ng".jpg}
    \caption{Esempio di algoritmo Nearest Neighbour}
\end{figure}

Entriamo ora più nel dettaglio nella realizzazione di questo algoritmo descrivendone i passaggi fondamentali. Noteremo che sono state fatte delle scelte di programmazione che in un primo momento potrebbero apparire inmotivate se considerate limitatamente a qanto visto fino ad ora.
L'algoritmo preso in analisi produce una soluzione valida molto velocemente ma che risulta essere scadente per quanto riguarda il suo costo, nel nostro progetto di conseguenza il \textit{nearest neighbour} viene unicamente utilizzato per fornire una o più soluzioni di partenza per altri algoritmi euristici. Risulta pertanto di maggior importanza che al suo interno sia introdotta una certa randomicità nelle scelte che effettua in modo tale che multipli utilizzi sulla stessa instanza del TSP producano soluzioni tra loro scorrelate. Algoritmi che presentano tale caratteristica possono essere trovati in letteratura con la dicitura \textbf{GRASP}\footnote{Greedy Randomly Adaptive Search Procedure.}
\begin{itemize}
    \item Innanzi tutto, partendo da una soluzione vuota è necessaria una operazione preliminare prima di innescare la ricorsività dell'algoritmo. In altre parole dobbiamo fornire un nodo iniziale il cui lato incidente a costo minore diventa il la prima vera componente della soluzione che quindi da vuota diviene parziale.
    La scelta di quale debba essere il nodo di partenza avviene in modo casuale;
    \item Come sarà più chiaro in seguito, l'algoritmo \textit{nearest neighbour} non produce mai soluzioni soddisfacenti ed i solamente utilizzato come punto di partenza per algoritmi più complessi. Questi ultimi necessitano in genere di una struttura dati che veda il circuito prodotto come un percorso orientato. Seguendo questa linea di pensiero, supponendo che l'ultima iterazione abbia introdotto il nodo $j$ nel percorso parzile, il lato successivo che andremo a selezionare dovrà sempre essere incidente in $j$. In questo modo risulta molto più semplice tenere traccia della soluzione come un vero e proprio percorso orientato, essendo questo utilizzato solamente come input per altri metodo più complessi la nostra scelta non risulta in alcun modo limitante;
    \item Per introdurre un ulteriore livello di casualità nell'algoritmo, la scelta di quale lato entra a far parte della soluzione parziale non ricade sempre in quello a costo minore. In particolare dopo varie prove si è deciso che quest'ultima opzione avviene con una percentuale del $90\%$, mentre con il $9\%$ la scelta ricade nel secondo miglior lato e con il restate $1\%$ nel terzo miglior lato;
    \item Spesso può capitare che il lato designito per essere aggiunto al percorso causerebbe la presenza di un cappio al suo interno. Naturalmente la soluzione finale risulterebbe non valida e quindi tale situazione deve essere evitata. Banalmente, nel caso in cui il lato in questione sia la $i-esima$ scelta migliore, questo viene sostituito dalla $(i+1)-esima$ miglior scelta. Naturalmente il tutto viene ripetuto iterativamente fino a che non si trova un lato accettabile;
\end{itemize}

Di seguito è riportata la realizzazione del codice tenendo presente che è richiesta in input una struttura dati che permetta di ottenere l'ordine crescente, per ogni nodo, dei lati in esso incidenti basandosi chiaramente sul loro costo. Tale informazione è fornita dal metodo \textbf{BuildSLComplete} già descritto brevemente LINK!!!!!!!!!!!!! (loop euristico) ed in dettaglio nell'apposito paragrafo della appendice LINK!!!!!!!!!!!!!!!!!!!.

\begin{lstlisting}

public static PathGenetic NearestNeighbour(Instance instance, Random rnd, List<int>[] listArray)
{
// heuristicSolution is the path of the current heuristic solution to generate
    int[] heuristicSolution = new int[instance.NNodes];
    double distHeuristic = 0;

    int currentIndex = rnd.Next(instance.NNodes);
    int startindex = currentIndex;

    bool[] availableIndexes = new bool[instance.NNodes];

    availableIndexes[currentIndex] = true;

    for (int i = 0; i < instance.NNodes - 1; i++)
    {
        bool found = false;

        int plus = RndPlus(rnd);

        int nextIndex = listArray[currentIndex][0 + plus];

        do
        {
            if (availableIndexes[nextIndex] == false)
            {
                heuristicSolution[currentIndex] = nextIndex;
                distHeuristic += Point.Distance(instance.Coord[currentIndex], instance.Coord[nextIndex], instance.EdgeType);
                availableIndexes[nextIndex] = true;
                currentIndex = nextIndex;
                found = true;
            }
            else
            {
                plus++;
                if (plus >= instance.NNodes - 1)
                {
                    nextIndex = listArray[currentIndex][0];
                    plus = 0;
                }
                else
                    nextIndex = listArray[currentIndex][0 + plus];
            }

        } while (!found);
    }

    heuristicSolution[currentIndex] = startindex;
    distHeuristic += Point.Distance(instance.Coord[currentIndex], instance.Coord[startindex], instance.EdgeType);

    return new PathGenetic(heuristicSolution, distHeuristic);
}

\end{lstlisting}

\subsection*{ALGORITMI MIGLIORATIVI}

Gli algoritmi euristici migliorativi si basano su un'idea estremamente semplice ed intuitiva: data una soluzione ammissibile \textbf{x}, relativa ad un problema di ottimizzazione, viene esaminato se attraverso minime variazioni questa risulta migliorabile in termini di funzione obiettivo.
In gergo più tecnico si parla di ricercare soluzioni \textit{vicine} a quella attuale ma migliorative. Per poter definire il concetto di "vicinanza" è necessario discutere quello di \textbf{mossa}. Questa è una operazione di modifica (caratteristica dell'algoritmo migliorativo) che viene eseguita su \textbf{x} e che ha come conseguenza la generazione di un \textbf{insieme} di soluzioni ammissibili le quali costituiscono un intorno di \textbf{x}, indicato con \textbf{N(x)}. Si parla allora di \textbf{y} vicina ad \textbf{x} se e solo se differiscono tra loro per una sola mossa e quindi $y \in N(x)$.

Una volta definito $N(x)$ questo viene esplorato secondo due possibili strategie che sono \textbf{first improvement} e \textbf{steepest descent}. Nel primo caso l'esplorazione dell'intorno termina non appena si trova una soluzione migliore di quella corrente. Nel secondo caso, invece, l'esplorazione è completa e viene trovato il miglioramento più consistente.

Qualora esista una soluzione \textbf{y} migliore di \textbf{x}, il procedimento viene iterato esplorando N(y); viceversa  l'algoritmo si arresta. Giunti a questo punto il risultato finale può essere una soluzione \textit{localmente ottima} oppure, più raramente, globalmente ottima\footnote{Da notare che un ottimo è globale se lo è anche localmente}. Poiché da un punto di vista matematico il processo di ricerca analizza, ad ogni interazione, un intorno della soluzione corrente, gli algoritmi migliorativi vengono anche chiamati \emph{algoritmi di ricerca locale}.

Tranne alcuni casi particolari in cui la funzione obiettivo ha determinate caratteristiche di convessità, nella maggior parte dei problemi reali questa presenta un grande numero di minimi locali che spesso si discostano totalmente dell'ottimo globale. In effetti, una delle fortunate eccezioni è il metodo del simplesso per la programmazione lineare che si pone alla base degli studi in questo settore: esso fornisce sia un metodo per analizzare in un numero finito di passi tutti gli ottimi locali del problema e soprattutto se questi sono anche globali.

Tra i più famosi algoritmi migliorativi applicabili al problema del commesso viaggiatore troviamo i \textbf{K-Opt} dove \textbf{K} è in genere un numero intero superiore a $2$. Procediamo quindi ad una loro descrizione generale seguita da una implementazione particolare della tecnica del \textbf{2-Opt}.

\subsection*{ALGORITMO K-OPT}

Gli algoritmi \textbf{K-Opt}, sigla inglese per K-Ottimalità, fanno parte della categoria degli algoritmi migliorativi e sono caratterizzati da una mossa, applicata ad un circuito hamiltoniano, consistente nello \textbf{scambio} di \textbf{K} archi con altrettanti non facenti parte del percorso producendone uno \textit{vicino}, migliore e chiaramente valido.
Come specificato nel paragrafo precedente \textbf{K} può assumere qualsiasi valore superiore a $2$\footnote{Chiaramente \textbf{K} non può superare il numero di archi che costituiscono la soluzione.} ma in genere è proprio $K = 2$ l'unica variante realmente utilizzata. Risulta infatti facilmente verificabile che più il suo valore è alto, più salgono sia la complessità computazione che di scrittura\\progettazione dell'algoritmo\footnote{Vedremo in seguito che questa affermazione è valida solo per algoritmi che applicano direttamente la definizione di K-Ottimalità. Esistono infatti metodi che la ottengono indirettamente se sono caratterizzati da tempi di esecuzione molto buoni.} perdendo così i vantaggi offerti dall'utilizzo di tecniche euristiche.
Concentriamoci quindi unicamente nella variante $2-Opt$: presa una qualsiasi coppia di archi distinti $([i,j];[h,k])$\footnote{Notiamo che questi non possono mai essere presi consecutivi e cioè con un vertice in comune in quanto non ci sarebbe modo di produrre una soluzione \textit{vicina} valida.} è possibile sostituirli correttamente con una sola delle combinazioni $([i,k];[h,j])$ e $([i,h];[j,k])$. Una di queste due, infatti, trasforma la soluzione in una seconda contenente due subtour.
A discapito quindi di un concetto molto basilare, l'algoritmo $2-opt$\footnote{In generale lo stesso discorso può applicarsi anche a tutto il resto della famiglia di algoritmi.} introduce la difficoltà di verificare quale delle due possibili sostituzioni è valida. L'approccio migliore in questi casi è di introdurre un fittizio ordinamento nel circuito attraverso una struttura dati di supporto apposita. Come è possibile infatti vedere dalla figura X, se gli archi sono ordinati, e quindi lo è anche il circuito, la difficoltà appena discussa è facilmente risolvibile: 

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"2-opt".png}
    \caption{Esempio di azione nell'algoritmo 2-opt}
\end{figure}

Viene da sé che applicare l'approccio $2-Opt$ a qualsiasi coppia di archi non garantisce un miglioramento del costo della soluzione. Questo però avviene nel $100\%$ dei casi se i due archi in questione visualmente si incrociano come mostrato nella figura X, tale affermazione è facilmente verificabile matematicamente.
Nel complesso, nel caso in cui si voglia trovare l'operazione di due ottimalità migliore\footnote{Cioè trovare la soluzione vicina a costo più basso} è necessario confrontare tutte le coppie possibili ottenendo quindi una complessità computazione pari a $O(n^2)$ rispetto al numero di nodi mentre nel caso di un generico valore di $K$ si passa ovviamente a $O(n^3)$.
Nel caso del \textit{TSP}, alcuni esperimenti svolti versoo la fine degli anni '50 hanno mostrato che il passaggio da due ottimalità a tre ottimalità porta un miglioramento sensibile della qualità della soluzione trovata, che giustifica pienamente l'aumento di carico computazionale ma non il costo di scrittura\\progettazione dell'algoritmo se paragonato ad altri metodi euristici che mostreremo nel seguito del testo. Miglioramenti praticamente trascurabili si hanno invece per $K > 3$. 
Concludiamo le nozioni riguardanti i metodi migliorativi di K ottimalità nel seguente paragrafo dove vengono mostrati i dettagli implementativi dell'algoritmo $2-Opt$ da noi progettato

\subsection*{METODO TwoOpt}

Il metodo TwoOpt implementa l' euristico algoritmo $2-Opt$ applicato al problema del commesso viaggiatore la cui discussione teorica è stata presentata nel paragrafo precedente.

\begin{lstlisting}
public static void TwoOpt(Instance instance, PathStandard pathG)
\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{instance}: oggetto dove sono memorizzati i dati relativi alla istanza del problema TSP;
    \item \textbf{pathG}: rappresenta il percorso sul quale l'algoritmo viene eseguito;
\end{itemize}

La classe \textbf{PathStandard}, descritta in dettagli in questo capitolo della appendice LINK!!!!!!!!!!!!!!!!, permette di memorizzare una soluzione del problema come un percorso ordinato. Molto semplicemente al suo interno si mantiene aggiornato un vettore di interi di nome \textbf{path} dove all'indice $i-esimo$ troviamo il nodo successivo da visitare, seguendo un il percorso attuale, trovandosi nel vertice di indice $i$.
Di seguito è riportato il contenuto del metodo \textbf{TwoOpt} che nel nostro caso utilizza la tecnica \textit{first improvement}, già discussa nei paragrafi precedenti.

\begin{lstlisting}

int indexStart = 0;
int cnt = 0;
bool found = false;

do
{
   found = false;
   int a = indexStart;
   int b = pathG.path[a];
   int c = pathG.path[b];
   int d = pathG.path[c];

   for (int i = 0; i < instance.NNodes - 3; i++)
   {
      double distAC = Point.Distance(instance.Coord[a], instance.Coord[c], instance.EdgeType);
      double distBD = Point.Distance(instance.Coord[b], instance.Coord[d], instance.EdgeType);
      double distAD = Point.Distance(instance.Coord[a], instance.Coord[d], instance.EdgeType);
      double distBC = Point.Distance(instance.Coord[b], instance.Coord[c], instance.EdgeType);

      double distTotABCD = Point.Distance(instance.Coord[a], instance.Coord[b], instance.EdgeType) +
      Point.Distance(instance.Coord[c], instance.Coord[d], instance.EdgeType);

      if (distAC + distBD < distTotABCD)
      {
            Utility.SwapRoute(c, b, pathG);
            pathG.path[a] = c;
            pathG.path[b] = d;
            pathG.cost = pathG.cost - distTotABCD + distAC + distBD;
            indexStart = 0;
            cnt = 0;
            found = true;
            //"break" = "first improvement" technique
            break;
      }
      
      c = d;
      d = pathG.path[c];
    }

    if (!found)
    {
        indexStart = b;
        cnt++;
    }

} while (cnt < instance.NNodes);

\end{lstlisting}

\'E utile fare infine le seguenti annotazioni: le assegnazioni degli indici possono ad un primo sguardo sembrare errate in quanto non tutte le possibili coppie di lati vengono analizzate, in realtà questo non avviene solamente per quelli tra loro consecutivi. Infine, dato che come vedremo a breve la tecnica della due ottimalità è utilizzata in un contesto più ampio, il percorso modificato viene poi riutilizzato e quindi è necessario mantenere aggiornato anche il suo ordinamento fittizzio. Questa funzionalità è offerta dal metodo \textbf{SwapRoute} descritto nel dettaglio nella appendice LINK!!!!!!!.

\subsection*{MULTISTART}

La tecnica del \textit{multi start} è un modo molto semplice per combinare i due algoritmi euristici proposti, \textit{nearest neighbour} e \textit{2-Opt}, sfruttando appieno i loro punti di forza.
L'idea alla base è la seguente: \textit{nearest neighbour}, secondo l'implementazione presentata LINK!!!!!!!, offre la possibilità di produrre molto velocemente un numero soluzioni valide al problema TSP in esame tutto diverse tra loro; Il suo principale svantaggio è che queste presentano risultati molto scadenti per quanto riguarda la funzione obiettivo da minimizzare. A questo punto è logico pensare di introdurre la tecnica del \textit{2-Opt}, l'algoritmo infatti necessità di una soluzione iniziale su cui essere applicato e produce velocemente risultati accettabili indipendentemente dalla bontà del punto di partenza.
Nel complesso quindi, l'algoritmo \textit{multi start} ripeto la combinazione appena proposta memorizzando solamente la soluzione migliore torvata durante il processo. Il tutto naturalmente fino allo scadere del classico timelimit ricevuto in ingresso dalla applicazione.
Riportiamo quindi di seguito il codice commentato senza fornire ulteriori indicazioni in quanto la sua comprensione dovrebbe a questo punto risultare facile:

\begin{lstlisting}

//It stores the current best path found
PathStandard incumbentSol = new PathStandard();
//It stores the latest path found
PathStandard heuristicSol;
//Used by nearest neighbour, it orders the links accident in a generic node based on their cost
List<int>[] listArray = Utility.BuildSLComplete(instance);

//At least one time the combo nearest neighbour and 2-Opt is used to produce a valide solution
do
{
//Using the nearest neighbour technique
heuristicSol = Utility.NearestNeighbour(instance, rnd, listArray);

//Using the 2-Opt technique on the nearest neighbour solution produced
TwoOpt(instance, heuristicSol);

//Confronting the best solution so far with the latest
if (incumbentSol.cost > heuristicSol.cost)
{
incumbentSol = heuristicSol;

Console.WriteLine("Incumbed changed");
}
else
Console.WriteLine("Incumbed not changed");

} while (clock.ElapsedMilliseconds / 1000.0 < instance.TimeLimit); //Cicle is repeated until the time limit is over

\end{lstlisting}

\subsection*{GENERAZIONE NUMERI CASUALI - SEMERANDOM DA SPOSTARE!!!!!!!!!!!!!!! INIZIO O APPENDICE}

Per generare un numero casuale è sufficiente istanziare la classe Random ed invocare sull' istanza creata il metodo \textbf{Next} o \textbf{NextDouble}. Per esempio nel caso in cui si voglia generare un numero casuale intero tra 1 e 99 è necessario scrivere le seguenti righe di codice:

\begin{lstlisting}

Random random = new Random();
int nun = random.Next(1,100);

\end{lstlisting}

I numeri random sono generati, a partire da un valore d' inizializzazione chiamato \textbf{seme}, da un algoritmo matematico. Per sua natura l' algoritmo è deterministico: se si fornisce in input lo stesso seme genererà sempre la medesima sequenza di numeri. Per tale ragione il valore del seme viene derivato dall'orologio di sistema all' atto della  creazione dell' istanza della classe Random qualora si utilizza il costruttore di default. In questo modo, non essendo predicibile il valore del seme, la sequenza di numeri generati dall' algoritmo risulta essere sistematicamente casuale. 

L' orologio di sistema non sempre risulta un buon valore da utilizzare per settare il seme. Si supponga di avere la necessità di creare due oggetti diversi della classe Random: qualora quest’ ultimi siano creati uno di seguito all’ altro avranno entrambi il medesimo seme poichè l' orologio di sistema risulta lo stesso nel lasso di tempo che il processore impiega ad eseguire le due istruzioni.

Per constatare ciò si è realizzato il seguente programma:

\begin{lstlisting}

Random rdn1 = new Random();
Random rdn2 = new Random();

for (int i = 0; i < 10; i++)
{
    Console.WriteLine(rdn1.Next(1, 10) + "-" + rdn2.Next(1, 10));
}
Console.ReadLine();

\end{lstlisting}

Il cui output, come previsto, risulta mostrato in Fig C.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"ng".jpg}
    \caption{Output}
\end{figure}

Per ovviare a questa problematica la classe Random dispone di un secondo costruttore che riceve come parametro un intero che setta il valore del seme: sarà a questo punto compito del programmatore passare valori casuali e  differenti all' atto della creazione delle due istanze della classe Random.


\section*{METAEURISTICI}

\subsection*{TABU}

\subsection*{VNS}

\subsection*{ALGORITMI GENETICI}

Gli Algoritmi Genetici (\textit{AG}), proposti nel 1975 da J.H. Holland, sono un modello computazionale idealizzato dall'evoluzione naturale darwinista. L'aggettivo "genetico" deriva dal fatto che il modello evolutivo darwiniano trova spiegazioni nella branca della biologia detta genetica e dal fatto che tali algoritmi attuano meccaniche concettualmente simili a quelli dei processi biochimici scoperti da questa scienza. I principi fondamentali che consentono la nascita e lo sviluppo di un processo evolutivo che porta all'evoluzione di una specie sono la \textbf{selezione naturale} e la \textbf{varietà del genotipo}\footnote{Il termine \textit{genotipo} indica la costituzione genetica di un organismo o di un gruppo di individui} della popolazione.
La selezione naturale è il meccanismo grazie al quale si ha un progressivo e cumulativo aumento della frequenza degli individui aventi caratteristiche ottimali per l'ambiente in cui essi vivono poiché solo quelli che meglio si adattano ad un certo habitat riescono a sopravvivere e a riprodursi.
I meccanismi generatori della variazione del genotipo della popolazione sono sostanzialmente due:

\begin{itemize}
    \item Un processo di \textbf{riproduzione} nel quale gli individui, detti genitori, si accoppiano producendo di nuovi, detti figli, il cui patrimonio genetico risulta pertanto una combinazione di quello dei genitori;
    \item Un processo di \textbf{mutazione} che colpisce i figli i quali subiscono una modifica del patrimonio genetico ereditato dai genitori per effetto dell'ambiente che li circonda;
\end{itemize}

I cambiamenti che si verificano da una generazione all'altra risultano essere molto piccoli ma, dato che sopravvivono soprattutto quelli positivi, un loro accumulo porta nel tempo a grandi cambiamenti.
La ricerca parte da una popolazione iniziale di individui, detti cromosomi, che rappresentano ipotetiche soluzioni al problema dato. Ogni individuo della popolazione viene codificato da un vettore\footnote{Oltre alla codifica vettoriale in letteratura è possibile trovare anche quella ad albero. Tuttavia essa viene utilizzata per codificare gli individui della popolazione nell'ambito della programmazione genetica (che è?????????).} i cui elementi contengono simboli appartenenti ad un alfabeto finito, detti geni. Ad ogni soluzione è associato un valore determinato da una funzione chiamata \textbf{Fitness} il cui scopo è di determinare la bontà di un individuo nel risolvere il problema in questione.
Così come nella natura solamente gli individui che meglio si adattano all' ambiente sono in grado di sopravvivere e riprodursi, anche negli algoritmi genetici le soluzioni migliori sono quelle che hanno la maggiore probabilità di trasmettere i propri geni alle generazioni future.
Come vedremo in seguito sono fondamentalmente tre le caratteristiche determinanti per un algoritmo genetico: determinare quale funzione di fitness si andrà ad utilizzare, partendo dalla attuale generazione decidere come creare un pull di possibili candidati per quella successiva ed infine come selezionare tra questi ultimi quelli che sopravviveranno.
Essendo la definizione delle funzione di fitness direttamente dipendente da quale tipo di problema si desidera studiare, concludiamo questa introduzione elencando solamente quali operatori genetici è possibile applicare per definire le restanti due caratteristiche di un algoritmo.

\subsection*{OPERATORI GENETICI}

In questo paragrafo vengono trattati i principali operatori genetici applicabili ai cromosomi. Per ogni operatore vengono inoltre descritte le principali varianti che si possono trovare in letteratura.

\subsubsection*{OPERATORE DI CROSSOVER}

Il crossover è una metafora della riproduzione in cui il materiale genetico dei discendenti è una combinazione di quello dei genitori. Di seguito sono indicati alcuni dei metodi più comuni per creare un \textit{figlio} partendo da due \textit{genitori}, le instanze così ottenute vanno a far parte di quelle candidate alla sopravvivenza per la generazione successiva:

\begin{itemize}
    \item \textbf{Crossover ad un punto}: date due soluzioni si tagliano i loro vettori di codifica in un punto casuale o predefinito per ottenere due teste \{$H_a, H_b$\} e due code\{$T_a, T_b$\}, si possono costruire quindi altrettante soluzioni distinte combinando la testa di un genitore con la coda dell'altro $S_1 = H_a \cup T_b , S_2 = H_b \cup T_1$;
    
    \item \textbf{Crossover a due punti}: date due soluzioni si tagliano i loro vettori di codifica in due punti predefiniti o casuali al fine di ottenere una coppia di teste\{$H_a, H_b$\}, parti centrale \{$I_a, I_b$\} ed code \{$T_a, T_b$\}. Le due soluzioni sono ottenute scambiando le due parti centrali nei genitori $S_1 = H_a \cup I_b \cup T_a , S_2 = H_b \cup I_a \cup T_b$;
    
    \item \textbf{Crossover uniforme}: consiste nello scambiare casualmente elementi tra le soluzioni candidate all'evoluzione;
    
    \item \textbf{Crossover aritmetico}: consiste nell'utilizzare un'operazione aritmetica per creare la nuova soluzione, ad esempio eseguendo una \textit{XOR} o una \textit{AND} tra elementi dei genitori se interpretati come una sequenza binaria;
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"selezioneSP".jpg}
    \caption{Esempio di operatore di crossover}
\end{figure}

\subsubsection*{OPERATORI DI SELEZIONE}

A causa di complessi fenomeni di interazione non lineare, non è sempre vero che da due soluzioni promettenti ne nasca una terza \textit{migliore} né che da due soluzioni con valori di fitness basso venga generato un figlio \textit{peggiore}. Pertanto non è statisticamente conveniente utilizzare i soli elementi con valori di fitness elevata sia durante la scelta dei genitori che durante la scelta di quali elementi faranno parte della generazione successiva. Per quanto riguarda quest'ultimo caso, oltre al semplice valore di fitness, vengono prese in considerazione particolari tecniche di \textit{selezione}. Le più comuni sono:

\begin{itemize}
    \item \textbf{Selezione a roulette}: la probabilità che una soluzione venga scelta per far parte della successiva generazione è direttamente proporzionale al valore restituito dalla funzione di fitness. Immaginiamo quindi di avere a disposizione una roulette la cui ruota viene divisa in sezioni tutte assegnate ai vari candidati, la loro grandezza è quindi proporzionale all'idoneità dell'individuo. La selezione è banalamente ottenuta con molteplici rotazioni della roulette tenendo conto che un individuo non può essere selezionato più volte. Questa tecnica presenta dei problemi nel caso in cui le sezioni della ruota risultino tra loro eccessivamente sbilanciate in ampiezza, le soluzioni peggiori vengono selezionate troppo raramente e questo per quanto già esposto non è necessariamente un bene;
    
    \item \textbf{Selezione di Boltzmann}: le soluzioni vengono scelte con un grado di probabilità che, agli inizi dell'algoritmo, favorisce \textit{l'esplorazione} mentre più avanti tende a stabilizzarsi. Questa tecnica ritiene utile, in un primo momento, consentire agli individui meno idonei di riprodursi quasi quanto quelli migliori, e far procedere lentamente la selezione così da mantenere una certa diversità all'interno della popolazione. In seguito si rafforza la selezione per favorire maggiormente gli individui ad alta idoneità, presumendo che la fase iniziale, con grande diversità e poca selezione, abbia consentito alla popolazione di individuare la zona giusta nello spazio di ricerca;
    
    \item \textbf{Selezione a torneo}: da un pool di possibili soluzioni, nel caso più comune vengono scelti in modo del tutto casuale sia due individui che un numero $c \in [0, 1]$. Se quest'ultimo risulta minore di un parametro $k \in [0, 1]$ fissato, si seleziona il più idoneo tra i due candidati, altrimenti la scelta ricade sul peggiore. Naturalmente si procede fino a quando non ho tutti gli elementi per la generazione successiva.
\end{itemize}

Non esiste in assoluto un metodo migliore tra quelli proposti, molto dipende direttamente da come questi sono implementati e soprattutto sia dalla dimensione del problema che dalla quantità di vincoli imposti: ad esempio, nel caso in cui sia richiesto di trovare nel minor tempo possibile una \textbf{buona} soluzione è sconsigliato utilizzare la selezione di Boltzmann.

\subsubsection*{OPERATORI DI MUTAZIONE}

L'operatore di mutazione prevede che in funzione di una prefissata e usualmente piccola probabilità $p_{mutation}$, il valore di un bit del figlio venga cambiato: questo serve per simulare quanto avviene in natura dove, anche se raramente, è possibile che vi sia una variazione del genotipo durante l' evoluzione di un essere vivente.
La figura x.y illustra un esempio di mutazione.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"Mutazione".jpg}
    \caption{Esempio di mutazione}
\end{figure}

\subsection{ALGORITMO GENETICO TSP}

Gli \textit{AG} risolvono un determinato problema generando sempre nuove \textbf{popolazioni} di soluzioni dove in genere troviamo una fitness media piuttosto bassa, giungendo solamente dopo diverse generazioni a valori più elevati. Per poter applicare un algoritmo genetico, occorre anzitutto codificare numericamente le soluzioni e individuare una opportuna funzione di fitness. La codifica vettoriale dei cromosomi più adatta per i problemi di TSP risulta essere un vettore di interi dove ogni elemento identifica in maniera univoca una delle città da visitare mentre il suo posizionamento identifica l'ordine di visita.
La funzione di fitness realizzata riceve in ingresso una soluzione \textbf{ammissibile}\footnote{Per qualsiasi generazione non sono quindi accettabili elementi non validi per il problema in questione. La funzione XXXX LINK!!! è stata realizzata a a tale scopo.} e restituisce un valore reale pari al reciproco del suo costo PERCHE'?????? LO DICIAMO DOPO???????.
La prima generazione viene ottenuta attraverso il metodo \textbf{NearestNeightborGenetic} dell classe \textbf{Utility}. Come facilmente intuibile genera soluzioni che tendono a collegare nodi tra loro vicini, per maggiori dettagli si consulti l'apposita sezione ad esso dedicata nella appendice LINKK!!!!!!!!!!!!!!!!!.
La generazione di un \textit{figlio} a partire da due \textit{genitori} avviene attraverso il crossover ad un punto già presentato dove però solamente una delle due soluzioni ottenute entra a far parte del pool di candidati per la successiva generazione. Il crossover viene fornito dal metodo \textbf{GenerateChild}, sempre appartenente alla classe \textbf{Utility}, che viene descritto nell'apposito paragrafo LINK!!!!!!!, mentre i restanti condidati alla nuova generazione sono gli elementi stessi della generazione precedente (motivo?!?!?!).
Come operatore di selezione, si è deciso di utilizzare la \textit{selezione a roulette} dato che le soluzioni hanno lo stesso ordine di grandezza per quanto riguarda i loro costi QUI NON E' CHIARO CHE SIGNIFICA---INTENDI CHE LE FETTE CHE VENGONO FUORI NON SONO TROPPO DIVERSE??????. Infine la mutazione avviene con probabilità $p_{mutex}$ pari all'1\%.
Quanto descritto viene per la maggior parte gestito attraverso il metodo NOME!!!!!!!!!!!!! con l'ausilio della classe \textbf{pathgenetic} descritta nella apposita sezione LINK!!!!!!!!!!!!!!!!!!!!!!!!!!!!.

\subsection*{FUNZIONE GENETICALGORITHM}

Questa classe ha il compito di amministrare tutto tutte le fasi dell'algoritmo genetico. Per prima cosa si procede con una dichiariazione ed inizializzazione delle varie strutture dati necessarie. Tra queste troviamo due liste di \textit{PathGenetic} chiamate \textbf{OriginallyPopulated} e \textbf{ChildPoulation} che, durante tutto il processo, contengono rispettivamente l'insieme dei circuiti hamiltoniani che compongono la generazione $i-esima$ ed i figli da loro generati. La prima generazione viene ottenuta attraverso il metodo \textbf{NearestNeightborGenetic}, discusso in maggiore dettagli nella appendice LINK!!!!!, che, ricevendo la lista completa per ogni nodo di quali sono ad esso più vicini\footnote{Funzione già descritta qui LINK!!!!!!!!!!!!!!.}, costruisce le varie instanze tendendo a collegare i nodi più vicini tra loro\footnote{Il numero di componenti per ogni generazione viene chiesto in input all'utente e passato come parametro di ingresso alla funzione \textit{GeneticAlgorithm}.}.
Durante la generazione dei nuovi figli, poiché l'indice in cui è memorizzato un circuito all'interno di \textit{OriginallyPopulated}, dovuto in genere all'estrazione della rouellette, è casuale\footnote{Con casuale si intende che non è presente alcuna forma di correlazione fra l'indice e il costo della soluzione.} si è deciso di accoppiare circuiti memorizzati in celle adiacenti; la casualità di OriginallyPopulated consente di combinare fra loro soluzioni buone con altre meno buone e ciò statisticamente risulta particolarmente vantaggioso.
Una volta prodotti i figli è necessario procedere con la creazione della nuova generazione padre: questo viene eseguito dal metodo \textbf{NextPopulation} descritto in seguito. Per identificare il miglior circuito della generazione corrente si è realizzato il metodo \textbf{BestSolution}, qualora il valore ottenuto risulti minore dell’incumbent\footnote{Con incumbent si intende la miglio soluzione fin ora calcolata.} quest'ultimo viene aggiornato. L'algoritmo termina quanto scade il time limit fornito dall' utente.  Riportiamo di seguito il codice realizzato:

\begin{lstlisting}

PathGenetic incumbentSol = new PathGenetic();
PathGenetic currentBestPath = null;

List<PathGenetic> OriginallyPopulated = new List<PathGenetic>();
List<PathGenetic> ChildPoulation = new List<PathGenetic>();

List<int>[] listArray = Utility.BuildSLComplete(instance);

//Generate the first population
for (int i = 0; i < sizePopulation; i++)
OriginallyPopulated.Add(Utility.NearestNeightborGenetic(instance, rnd, true, listArray));
do
{
//Generate the children
for (int i = 0; i < sizePopulation; i++)
{
if (i % 2 != 0)
ChildPoulation.Add(Utility.GenerateChild(instance, rnd, OriginallyPopulated[i], OriginallyPopulated[i - 1], listArray));
}

OriginallyPopulated = Utility.NextPopulation(instance, sizePopulation, OriginallyPopulated, ChildPoulation);

//currentBestPath contains the best path of the current population
currentBestPath = Utility.BestSolution(OriginallyPopulated, incumbentSol);

if (currentBestPath.cost < incumbentSol.cost)
{
incumbentSol = (PathGenetic)currentBestPath.Clone();
Utility.PrintGeneticSolution(instance, process, incumbentSol);
}

// We empty the list that contain the child
ChildPoulation.RemoveRange(0, ChildPoulation.Count);

} while (clock.ElapsedMilliseconds / 1000.0 < instance.TimeLimit);

Console.WriteLine("Best distance found within the timelit is: " + incumbentSol.cost);

\end{lstlisting}

\subsection*{NEARESTNEIGHTBORGENETIC}

Il corrente metodo è simile alla funzione NearestNeight discussa nel paragrafo X.Y ma con due differenze significative:

\begin{itemize}
    \item La sequenza degli elementi nell array che codifica il percorso creato dal metodo indicano l'ordine con cui il circuito visita i nodi. Si ricorda invece che il metodo NearestNeight produce percorsi codificati in array in cui alla generica posizione \textbf{i} è collocato il nodo successivo al nodo \textbf{i}. Tale modifica è dettata solamente da una agevolazione nell'utilizzo successivo di queste informazioni da parte dell'algoritmo genetico nella creazione della prima generazione.
    
    \item Poiché un algoritmo genetico è tanto migliore quanto gli individui che formano la popolazione di partenza hanno caratteristiche dissimili fra di loro, si è fatto in modo che i circuiti fossero il più possibili diversi gli uni dagli altri.
\end{itemize}


L' intestazione del metodo risulta essere:

\begin{lstlisting}

public static PathGenetic NearestNeightborGenetic(Instance instance, Random rnd, bool rndStartPoint, List<int>[] listArray)

\end{lstlisting}


Dove:


\begin{itemize}
    \item \textbf{instance}: oggetto della classe \textit{Instance} contenente tutti i dati che descrivono l'istanza del problema del Commesso Viaggiatore fornita in ingresso dall' utente;
    \item \textbf{rnd}: istanza della classe \textit{Random} precedentemente inizializzato con un seme random diverso per ogni iterazione del programma;
    \item \textbf{rndStartPoint}: variabile booleana che determina se il nodo di partenza sul quale viene applicato l' algoritmo nearest neightbor risulta essere casuale (in tal caso assume il valore true) oppure sia il nodo di default 0;
    \item \textbf{listArray}: lista in cui all'indice \textbf{i} è presente un vettore di dimensione instance.Nnodes al cui interno sono, in ordine crescente rispetto alla distanza assunta dal nodo \textbf{i}, presenti gli indici associati ai nodi del grafo.
\end{itemize}

Il circuito prodotto dal metodo viene memorizzato all'interno del vettore \textbf{heuristicSolution} avente una dimensione pari al numero di nodi del grafo. Poiché si vogliono soluzioni che siano il più possibile dissimili tra loro, è consigliabile fare in modo che \textit{rndStartPoint} sia posta a \textit{true}\footnote{Da notare che tale parametro non è settata runtime ma solamente via hardcode.}. Il vettore \textbf{VisitedNodes} di tipo bool è un vettore di supporto che memorizza all'indice \textbf{i} il valore logico true se il nodo \textbf{i} è già stato visitato, false altrimenti.

\begin{lstlisting}

// heuristicSolution is the path of the current heuristic solution generate
int[] heuristicSolution = new int[instance.NNodes];

bool[] VisitedNodes = new bool[instance.NNodes];

int firstNode = 0;

//rndStartPoint define if the starting point is random or always the node 0 
if (rndStartPoint)
firstNode = rnd.Next(0, instance.NNodes);

heuristicSolution[0] = firstNode;
VisitedNodes[firstNode] = true;

\end{lstlisting}

Una volta definito il nodo di partenza i restanti nodi, che se visitati rispettando il loro ordine compongono un circuito hamiltoniano, son ottenuti attraverso un ciclo \textit{for}: alla generica iterazione \textbf{i} del ciclo, sfruttando la struttura dati listArray e la funzione \textbf{RndGenetic} si memorizza all'interno della variabile \textbf{nextNode} il nodo successivo visitato dal percorso sempre che questo sia ancora disponibile. Per verificarne la disponibilità si utilizza l'array \textit{VisitedNodes}, qualora non sia possibile utilizzare tale nodo si passa al successivo più vicino.


(la variabile contatore de ciclo for è inizializzata al valore 1, quindi il heuristicSolution[i-1] è memorizzato l' ultimo nodo visitato)  QUESTO VA COME COMMENTO NEL CODICE

\begin{lstlisting}

for (int i = 1; i < instance.NNodes; i++)
{
bool found = false;
int candPos = RndGenetic(rnd);
int nextNode = listArray[heuristicSolution[i - 1]][candPos];
do
{
//We control that the selected node has never been visited
if (VisitedNodes[nextNode] == false)
{
VisitedNodes[nextNode] = true;
heuristicSolution[i] = nextNode;
found = true;
}
else
{
candPos++;
if (candPos >= instance.NNodes - 1)
{
nextNode = listArray[heuristicSolution[i - 1]][0];
candPos = 0;
}
else
nextNode = listArray[heuristicSolution[i - 1]][candPos];
}

} while (!found);
}

\end{lstlisting}

\subsection*{GENERATECHILD}

Per generare un figlio si è realizzato il metodo \textbf{GenerateChild}, appartenente alla classe Utility, avente la seguente intestazione:

\begin{lstlisting}

public static PathGenetic GenerateChild(Instance instance, Random rnd, PathGenetic mother, PathGenetic father, List<int>[] listArray)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{instance}: oggetto della classe Instance contenente tutti i dati che descrivono l'istanza del problema del Commesso Viaggiatore fornita in ingresso dall' utente;
    \item \textbf{rnd}: istanza della classe \textit{Random} precedentemente inizializzato con un seme random diverso per ogni iterazione del programma;
    \item \textbf{father}: circuito hamiltoniamo che sarà accopiato con il parametro mather;
    \item \textbf{mother}: hamiltoniamo che sarà accopiato con il parametro father;
    \item \textbf{listArray}: lista in cui all’ indice i è presente un vettore di dimensione instance.Nnodes al cui interno sono, in ordine crescente rispetto alla distanza assunta dal nodo i, presenti gli indici associati ai nodi del grafo.
\end{itemize}

Come precedentemente accennato il seguente metodo produce un figlio utilizzando l'operatore di crossover a singolo punto.

\begin{lstlisting}

int crossover = (rnd.Next(0, instance.NNodes));

for (int i = 0; i < instance.NNodes; i++)
{
if (i > crossover)
pathChild[i] = mother.path[i];
else
pathChild[i] = father.path[i];
}

\end{lstlisting}


Una volta creato il figlio, con una probabilità p = 0.01 viene effettuata su di esso una mutazione utilizzando il metodo \textbf{Mutation} LINK?!!?!?.


\begin{lstlisting}

if (rnd.Next(0, 101) == 100)
Mutation(instance, rnd, pathChild);

\end{lstlisting}

Il figlio ottenuto quasi certamente non risulta essere un circuito ammissibile, per tale motivo si è progettato il metodo \textbf{Repair}. \'E interessante far notare che quest'ultimo non cerca di modificare i circuiti non modo da abbassarne il più possibile il costo ma al contrario è stato costruito in modo tale da risultare il più veloce possibile: soprattutto per popolazioni numerose e time limit alti tale scelta risulta essenziale. Di conseguenza i figli così prodotti sono tipicamente caratterizzati da un costo che con bassa probabilità risulta migliore rispetto a quello dei genitori e ciò comporta una saturazione dell'algoritmo dopo poche iterazioni (PERCHè?!?!?!?! METTERLO COME FOOTNOTE). Come operazione finale si è quindi deciso di applicare su di essi l'algoritmo \textbf{TwoOpt} ma solamente con una probabilità $p = 1 / (n/2)$, dove n è il numero dei nodi. La ragione per cui $p$ assume tale valore è dovuta al fatto che l'operazione di due ottimalità ha complessità computazionale O()[quando faccio il multistart controllo meglio quanto è la sua complessità] ed una sua applicazione più frequente rallenterebbe troppo l'algoritmo.

\begin{lstlisting}

if (ProbabilityTwoOpt(instance, rnd) == 1)
{
child.path = InterfaceForTwoOpt(child.path);
TSP.TwoOpt(instance, child);
child.path = Reverse(child.path);
}

\end{lstlisting}

Da notare che la funzione per ottenere la due ottimalità è utilizzata da più metodi di risoluzione (multi-start ecc..) e necessita che il percorso della soluzione hamiltoniana sia memorizzato con un apposito formato diverso da quello presentato per l'algoritmo genetico: sono quindi necessarie due semplici interfacce \textbf{InterfaceForTwoOpt, Reverse}, i cui tempi di esecuzione sono $O(n)$.

\subsection*{NEXTPOPULATION}

La funzione \textbf{NextPopulation}, appartenente alla classe \textbf{Utility}, consente di definire la nuova generazione scegliendone gli elementi tra la vecchia generazione ed i suoi figli attraverso una estrazione a roulette. La firma di tale funzione risulta essere:

\begin{lstlisting}

public static List<PathGenetic> NextPopulation(Instance instance, int sizePopulation, List<PathGenetic> FatherGeneration, List<PathGenetic> ChildGeneration)

\end{lstlisting}

Dove:

\begin{itemize}
    
    \item \textbf{instance}: oggetto della classe Instance contenente tutti i dati che descrivono l'istanza del problema del Commesso Viaggiatore fornita in ingresso dall' utente;
    \item \textbf{sizePopulation}: parametro che indica di quanti elementi deve essere la nuova generazione, per come è stato costruito il nostro programma questo parametro non varia mai ed è richiesto una sola volta all'utente;
    \item \textbf{FatherGeneration}: Lista contenente i circuiti che definiscono la generazione corrente;
    \item \textbf{ChildGeneration}: Lista contenente i circuiti figli generati da FatherGeneration utilizzando la funzione GenerateChild.
    
\end{itemize}

Per prima cosa uniamo le due liste di circuiti in quanto si è deciso che l'unico metro di giudizio durante la selezione deve essere il valore di fitness attribuito ad ogni soluzione indipendentemente dalla loro provenienza.

\begin{lstlisting}

for (int i = 0; i < ChildGeneration.Count; i++)
FatherGeneration.Add(ChildGeneration[i]);

\end{lstlisting}

Passiamo ora a descrivere come è gestita la selezione a roulette, chiaramente esistono molteplici metodi e quello da noi scelto non ha alcun vantaggio significativo rispetto agli altri. L'idea alla base dell'algoritmo è di assegnare un valore univoco ad ogni circuito estraibile e di utilizzare tali valori molteplici volte come caselle della roulette, implementata come una lista di interi. Il numero di inserimenti per ogni valore è direttamente proporzionale alla fitness del circuito a cui è associato. Tutto questo viene per la maggior parte gestito all'interno del metodo \textbf{FillRoulette} LINK!!!!!!!!!!!!!!!!!, sempre definito nella classe \textbf{Utility}, che restituisce inoltre la grandezza della roulette così creata e poi memorizzato nella variabile \textbf{upperExtremity}:

\begin{lstlisting}

List<PathGenetic> nextGeneration = new List<PathGenetic>();
List<int> roulette = new List<int>();
Random rouletteValue = new Random();
int upperExtremity = FillRoulette(roulette, FatherGeneration);

\end{lstlisting}

La creazione della nuova generazione avviene estraendo valori random non superiori ad \textit{upperExtremity}, questi forniscono gli indici della lista-roulette le cui posizioni indicano indirettamente quale circuito deve far parte della nuova generazione. Naturalmente è possibile estrarre più volte la stessa soluzione, in questo caso la cosa va ignorata ripetendo nuovamente il processo. Nel complesso si dovranno estrarre (\textit{sizePopulation}) circuiti hamiltoniani.

\begin{lstlisting}

List<int> NumbersExtracted = new List<int>();
bool find = false;
int numberExtracted;

for (int i = 0; i < instance.SizePopulation; i++)
{
do
{
find = true;
numberExtracted = rouletteValue.Next(0, upperExtremity);
//A path can't be extracted more than one time
if (NumbersExtracted.Contains(roulette[numberExtracted]) == false)
{
find = false;
NumbersExtracted.Add(roulette[numberExtracted]);
nextGeneration.Add(FatherGeneration.Find(x => x.NRoulette == roulette[numberExtracted]));
}
} while (find);
}
return nextGeneration;

\end{lstlisting}

\section*{MATHEURISTICS}

Gli algoritmi \textbf{matheuristics} nascono con l'obbiettivo di migliorare una soluzione di partenza ammissibile \textbf{x} sfruttando il \textbf{modello matematico} del problema (ogni tanto parli di MIP, ma si intende modelli misti interi e frazionari, è giusto usarlo???) che si vuole risolvere. Analogamente a quanto visto per gli algoritmi di ricerca locale e metaeuristici, i matheuristici tentano di individuare una soluzione migliore \textbf{x*} all' interno di un intorno N(x) ottenuto, in questo ambito, modificando opportunamente il modello matematico di partenza. 

L'esplorazione di N(x) non avviene per enumerazione come visto in precedenza ma tramite appositi solver come ad esempio Cplex: grazie alla loro sempre maggiore ottimizzazione, questa operazione risulta quindi essere molto veloce. 

I matheuristici possono essere applicati a qualunque soluzione ammissibile x; ciò nonostante per apprezzarne davvero la potenza è consigliabile utilizzare un punto di partenza già buono. A tale scopo si può quindi pensare di concatenarli  all'esecuzione di un algoritmo migliorativo o, meglio ancora, al termine del multistart o di un metaeuristico. Questi infatti arrivano molto frequentemente a saturare in prossimità di una soluzione molto buona \textbf{$\overline{x}$} ma non ottima.

Sfruttando questa combinazione di algoritmi è stato dimostrato che già in un breve lasso di tempo si riescono ad ottenere sostanziali miglioramenti ed in alcuni casi è possibile raggiungere anche l'ottimo globale. Si osserva che esiste una notevole differenza fra l'ottenere quest'ultimo risultato grazie ad un algoritmo esatto e seguendo il procedimento precedentemente discusso: mentre nel primo caso è sempre certificato, nel secondo questo non avviene\footnote{Il solver utilizzato garantisce solamente l'ottimalità del modello da noi fornitogli che chiaramente non può essere quello originale del problema.} e non si ha nemmeno modo di certificarlo a meno che non lo si conosca a priori.

A questo punto è chiaro come il fattore caratterizzante di un algoritmo matheuristico sia come questo definisce l'intorno della soluzione di partenza sul quale si suppone possano essere localizzati dei miglioramenti. 

Uno schema comunemente utilizzato prende il nome di \textbf{hard variable fixing} e prevede di fissare il valore di un certo numero di variabili, rendendole di fatto costanti, mentre le restanti vengono lasciate libere. Lo svantaggio principale derivante da questa tecnica è che a priori non esistono indicazioni su cosa è più opportuno fissare e cosa lo è meno. Di conseguenza esiste una sua variante detta \textbf{soft variable fixing} che lascia al solver questa responsabilità indicandogli solamente con quale proporzione deve avvenire la cosa.

Nei prossimi paragrafi sono riportanti alcuni esempi di algoritmi matheuristici che si basano sui concetti appena esposti ricordando che come per qualsiasi metodo euristico non esistono varianti più o meno efficaci in assoluto ma molto dipende dal problema che si sta analizzando e da fattori casuali non calcolabili.

\subsection*{HARD FIXING}

L'hard fixing è una tecnica euristica che, partendo da una qualsiasi soluzione ammissibile \textbf{$x_H$}, tenta di trovarne una migliore all'interno di un suo intorno. Quest'ultimo viene definito dall'algoritmo stesso attraverso il fissaggio a priori di alcune variabili del modello matematico, rendendole così di fatto costanti, utilizzando i valori che queste assumo in $x_H$. 

Come già discusso nel paragrafo precedente, una volta definito l'intorno e quindi un nuovo modello matematico, la sua risoluzione viene affidata ad un solver esterno pertanto l'unica fase saliente dell'algoritmo è la scelta stessa di quale porzione di $x_H$ mantenere valida e quale no. 

Esistono chiaramente molteplici approcci ammissibili e nessuno di questi risulta migliore in assoluto. Come spesso accade negli algoritmi euristici la scelta più semplice produce risultati molto buoni e quindi alcune varianti dell'\textit{hard fixing} semplicemente fissano un qualunque lato con probabilità $p$ o meno con probabilità $1-p$\footnote{Ovviamente $p$ è direttamente proporzionale a quanti lati sul loro totale vogliamo fissare.}.

Altri approcci invece tentano di definire un sistema di ranking come ad esempio dare più valore agli elementi con costo minore.

Indipendentemente da quale tecnica si decida di utilizzare maggiore è il numero dei lati fissati, minore è il carico di lavoro per risolvere il rilassamento continuo derivante ma allo stesso tempo diviene minore anche l'ampiezza dell'intorno che si va a sondare.

Nel complesso quindi è buona norma tentare sì molteplici fissaggi ma anche variarne il numero cercando di trovare la miglior combinazione per il problema in questione.

Nel nostro caso si è deciso di optare per la prima variante andando progressivamente a diminuire il valore di $p$. Il motivo di tale scelta è che il nostro algoritmo non ha un target specifico di istanze aventi una struttura ben definita dove diventa quindi evidente un sistema di ranking efficiente.

Preferiamo quindi ampliare il range di possibili intorni da visitae dando però sempre la possibilità all'algoritmo di trovare la soluzione ottima. Di conseguenza più è alto il tempo limite che gli andiamo a concedere maggiori sono le probabilità di avvicinarsi al risultato desiderato.

\subsection*{WARM-START}

Tra le svariate funzionalità offerta da Cplex possiamo trovarne una in particolare che è sempre consigliato utilizzare quando possibile e nello specifico risulta essere una naturale aggiunta alla tecnica dell'\textbf{hard-fixing}. Stiamo parlando della possibilità di fornire a Cplex una soluzione al problema che dovrà andare a risolvere in modo tale che, una volta controllata la sua validità durante la fase di prepocessing, possa essere utilizzata come incumbent. Questa soluzione prende il nome di \textbf{warm-start} o \textbf{MIP-start} e chiaramente quando si procede al fissaggio di alcune variabili in accordo ad $x_H$, questa rimane ovviamente valida per il problema e quindi è una naturale candidata per questo ruolo.

Cplex trae diversi potenziali vantaggi grazie ad un \textbf{warm-start}: prima di tutto sfruttando il criterio di bounding, avere a disposizione un buon incumbent fin dai primi momenti della tecnica del \textit{branch\&cut} può velocizzare la costruzione dell'albero decisionale dichiarandone alcuni nodi come sondati; In secondo luogo permette di applicare particolare tecniche euristiche che necessitano di questa condizione di partenza, parliamo ad esempio degli algoritmi \textbf{RINS} e \textbf{polishing} che saranno discussi successivamente anche in questa tesi.

In linguaggio \textbf{C\#} l'operazione di warm-start avviene attraverso il metodo non statico \textbf{AddMIPStart} della classe \textit{Cplex} la cui firma è:

\begin{lstlisting}

public virtual int AddMIPStart(INumVar[] vars,double[] values)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{vars}: Vettore contenente nella posizione $i$ la $i-esima$ variabile del modello;
    \item \textbf{values}: Vettore contenente nella posizione $i$ il valore della $i-esima$ variabile del modello;
\end{itemize}

Si osserva inoltre che nel caso in cui si attuino consecutive esecuzione dell'\textit{hard-fixing} non è più necessario aggiornare manualmente il valore di \textit{warm-start}\footnote{Se non alla prima run.}: variare solamente i fissaggi delle variabili, senza modificare ulteriormente il modello matematico, non viene considerata da Cplex una operazione \textit{drastica} al punto di abbandonare i risultati ottenuti fino a quel momento.

In altre parole, nel caso in cui non sia trovata una soluzione migliore rispetto al \textit{warm-start} attuale la validità di quest'ultimo viene automaticamente ricontrollata durante la successiva fase di preprocessing\footnote{La sua validità è sempre garantita in quanto siamo nel caso in cui sì applichiamo un fissaggio diverso ma rispetto la stessa soluzione di partenza dato che non ne sono state trovate di migliori.} effettuata dal solver. Altrimenti nel caso in cui l'ultimo rilassamento continuo abbia individuato un nuovo valore per l'incumbent, e quindi un nuovo \textit{warm-start}, Cplex provvede autonomamente al suo aggiornamento.

\subsection*{PREPROCESSINGTSP}

Una volta defenito l'intorno \textbf{$N(x_I)$} e quindi aver fissato il \textit{lower bound} di alcune variabili a $1$ è possibile procedere immediatamente alla risoluzione del problema modificato attraverso il solver, nel nostro caso Cplex. Come ben noto, nel caso più generico, il pool di tagli è inizialmente vuoto e solo quelli necessari, non determinabili a priori, sono individuati attraverso le callback installate.

Nel caso dell'\textbf{hard-fixing} questa affermazione non è del tutto esatta in quanto \textbf{alcuni} dei tagli \textbf{necessari}\footnote{Per necessari si intende che sicuramente } possono essere trovati molto velocemente attraverso una analisi del fissaggio effettuato. Una loro aggiunta preventiva risulta quindi molto vantaggiosa in quanto si evitano certamente delle iterazioni al solver risparmiando nel complesso diverso tempo.
In \hyperref[fig:Preprocessiong1]{FiguraX} troviamo una generica situazione dove gli archi in \textit{blu} sono stati \textit{fissati} mentre quelli in \textit{azzurro} no. Proprio questi ultimi però verrebbero immediatamente selezionati dal solver in quanto la soluzione con i due subtour indicati risulta banalmente la meno costosa. Il compito del preprocessingTSP (\textbf{ppTSP}) da noi progettato è quindi proprio questo, trovare tutti quei lati che, se anche selezionati singolarmente, generano un subtour\footnote{Dato che non ha senso fissare $n-1$ lati su un totale di $n$, se la singola selezione di un lato genera un subtour, qualsiasi siano le restanti selezioni, la soluzione così prodotta avrà sempre almeno un secondo subtour e quindi risulta invalida.} e di conseguenza forzarli a valore $0$.

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/"PreProcessing".jpg}}
    \label{fig:Preprocessiong1}
    \caption{Preprocessing}
\end{figure}

A livello algoritmo l'operazione di \textit{ppTSP} è molto semplice da realizzare. Sfruttiamo la stessa tecnica utilizzata nel corso del progetto per individuare le componenti connesse di una \textbf{soluzione} proposta. Queste nel nostro caso non risulteranno mai essere un ciclo completo per costruzione e quindi si possono sempre individuare le coppie di nodi posti alle loro estremetà: i lati che collegano i due elementi appartenenti alla stessa coppia sono esattamente quelli da forzare a valore nullo\footnote{Questo discorso è sempre valido a meno che la componente connessa non ciclica trovata sia composta da un solo lato, in quel caso non è richiesta nessuna operazione.}.

Una definizione equivalente di quanto stiamo cercando sono tutti quei nodi posti alla estremi di un solo lato che è stato fissato. Proponiamo ora il codice commentato che sfrutta quest'ultima affermazione e permette di attuare la completa fase di \textit{ppTSP}:

\begin{lstlisting}

public static void PreProcessingTSP(Instance instance, INumVar[] x)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{instance}: riferimento all' oggetto contenente tutte le informazioni relative all' istanza del Problema del Commesso Viaggiatore corrente;
    \item \textbf{x}: vettore contente le variabili del modello matematico;
\end{itemize}

\begin{lstlisting}

//Questo vettore tiene traccia all'indice i-esimo di quante volte il nodo i è estremo di un lato fissato, opzioni valide sono 0, 1, 2
int[] cntNode = new int[instance.NNodes];

//Questo vettore tiene traccia di quale componente connessa fa parte ogni nodo
int[] compConn = new int[instance.NNodes];

//Questo vettore di liste di interi è la struttura dati di supporto dove infine ogni lista contenente due elementi sarà relativa ad una singola
//componente connessa e immagazzinerà al suo interno gli indici dei nodi posti alle sue estremità. Chiaramente tale informazione è facilmente
//ricavabile dai due precedenti vettori cntNode e compConn ma con un costo complessivo più alto.
List<int>[] externalNodes = new List<int>[instance.NNodes];

//Classica inizializzazione delle componenti connesse, ad ogni nodo è assegnato ne è assegnata una propria
Utility.InitCC(compConn);

//Inizializzazione di externalNodes
for (int i = 0; i < instance.NNodes; i++)
    externalNodes[i] = new List<int>();

for (int i = 0; i < instance.NNodes; i++)
{
    for (int j = i + 1; j < instance.NNodes; j++)
    {
        //Trovo indice corretto del lato con estremi i nodi di indice i e j
        int position = Utility.xPos(i, j, instance.NNodes);

        //Nel caso sia stato fissato dall'hard-fixing lo si analizza
        if (x[position].LB == 1)
        {
            //Aggiornamento del contatore relativo ai nodi i e j
            cntNode[i] += 1;
            cntNode[j] += 1;

            //Aggiorno componenti connesse seguendo la tecnica di Kruskal
            for (int k = 0; k < instance.NNodes; k++)
            {
                if ((k != j) && (compConn[k] == compConn[j]))
                    compConn[k] = compConn[i];
            }

            compConn[j] = compConn[i];
        }
    }
}

//Popoliamo correttamente externalNodes in modo tale che solamente i due nodi estremi della stessa componente connessa
//siano inserite all'interno della stessa lista
for(int i = 0; i< instance.NNodes; i++)
{
    if (cntNode[i] == 1)
        externalNodes[compConn[i]].Add(i);
}

//Controlliamo quali elementi del vettore di liste appena popolato risultano avere esattamente due elementi ed eseguiamo
//l'operazione fondamentale del preprocessing discussa
for (int i = 0; i < instance.NNodes; i++)
{
    if (externalNodes[i].Count == 2)
    {
        //Calcolo l'indice del lato di cui voglio forzare l'upper bound a 0
        int pos = xPos(externalNodes[i][0], externalNodes[i][1], instance.NNodes);

        //Se il lato analizzato era in precedenza stato fissato ad uno dall'algoritmo di hard fixing, quindi il suo lower bound
        //è pari ad 1, non lo andiamo a toccare in quanto significa che la componente connesse non ha altri elementi
        if (x[pos].LB == 0)
            x[pos].UB = 0;
    }
}

\end{lstlisting}

\subsection*{IMPLEMENTAZIONE HARD FIXING}

\begin{lstlisting}

static void HardFixing(Cplex cplex, Instance instance, Process process, Random rnd, Stopwatch clock)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{cplex}: riferimento all'oggetto contenente il modello da risolvere;
    \item \textbf{instance}: riferimento all'oggetto contenente tutte le informazioni relative all'istanza del Problema del Commesso Viaggiatore corrente;
    \item \textbf{process}: riferimento all'oggetto necessario per la stampa dei dati attraverso \textit{GNUPlot};
    \item \textbf{rdn}: istanza della classe Random utilizzata per la generazione dei numeri casuali;
    \item \textbf{clock}: riferimento all'oggetto utilizzato come cronometro, deve già essere stato avviato;;
\end{itemize}

Di seguito troviamo il codice del metodo \textbf{commentato}. Facciamo però presente che l'\textit{hard fixing} può ricevere in ingresso una qualsiasi soluzione di partenza, preferibilmente già buona, sulla quale vogliamo definire un intorno di ricerca. Nella versione base dell'algoritmo riportato viene utilizzato il modo più veloce per ottenere tale risultato e quindi attraverso la funzione \textbf{NearestNeightbor} LINK!!!!!!!!!!!!!!! con conseguente algoritmo di due ottimalità.

Nei test a fine capitolo vedremo invece una variante che sfrutta soluzioni già precedentemente ottenute da altri algoritmi euristici attraverso loro tempi di esecuzione infinitamente più alti.

\begin{lstlisting}
//Oggetto utilizzato per la scrittura su file dei vari incumbent trovati in modo tale che GNUPlot possa stamparne il ciclo a video
StreamWriter file;

//Vettore che vuole essere sempre aggiornato al miglior ciclo trovato
double[] currentIncumbentSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

//Variabile sempre aggiornata al costo del miglior ciclo trovato
double currentIncumbentCost = Double.MaxValue;

//All'indice i-esimo troviamo in ordine crescente quali sono i nodi più vicini all'i-esimo nodo
List<int>[] listArray = Utility.BuildSLComplete(instance);

//Variabile booleana che comunicherà alla lazy callback utilizzata di non stampare a video tutte gli aggiornamenti dell'incumbent che trova
bool BlockPrint = false;

//Indica dopo quante consecutive esplorazioni di diversi intorni sia necessario ampliare l'ampiezza dei successivi
const int VALUECONSITENOTIMPROV = 3;

//Variabile costantemente aggiornata a quante esplorazioni consecutive non hanno portato ad una soluzione migliore, inizialmente si parte da VALUECONSITENOTIMPROV
int consecutiveiterationNotImprov = VALUECONSITENOTIMPROV;

//La percentuale inizile p che ha ogni lato di essere fissato
double percentageFixing = 0.8;

//Semplice inizializzazione del vettore che andrà a contenere la selezione o meno di ogni lato nella soluzione migliore finale
instance.BestSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

//Creo il modello matematico di partenza
INumVar[] x = Utility.BuildModel(cplex, instance, -1);

//Utilizzo del NearestNeightbor per iniziare a costruire la soluzione di partenza
PathStandard heuristicSol = Utility.NearestNeighbour(instance, rnd, listArray);

//Applicazione del 2-Opt per completare la soluzione di partenza
TwoOpt(instance, heuristicSol);

//La soluzione di partenza è settata come attuale incumbent
for (int i = 0; i < instance.NNodes; i++)
{
    int position = Utility.xPos(i, heuristicSol.path[i], instance.NNodes);
    currentIncumbentSol[position] = 1;
}
//Il costo della soluzione di partenza è settato come il miglior costo attuale
currentIncumbentCost = heuristicSol.cost;

//Installazione lazy callback per la risoluzione del modello
TSPLazyConsCallback tspLazy = new TSPLazyConsCallback(cplex, x, instance, process, BlockPrint);
cplex.Use(tspLazy);

//Forniamo a Cplex il warm-start
cplex.AddMIPStart(x, currentIncumbentSol);

//Setto i thread utilizzati da Cplex pari al numero di core virtuali della macchina utilizzata, il codice della Lazy è thread-safe
cplex.SetParam(Cplex.Param.Threads, cplex.GetNumCores());

//La polita da noi scelta prevede che al primo miglioramento ottenuto durante l'esplorazione dell'intorno attuale questa venga fermata in modo da ripetere il procedimento
//in modo da ripetere il procedimentocon il nuovo valore di incumbent. Per ottenere questo risultato comunichiamo a Cplex che alla seconda soluzione intera trovata fermi
//la propria risoluzione. Notiamo che la prima soluzione intera è il warm-start
cplex.SetParam(Cplex.LongParam.IntSolLim, 2);

do
{
    //Modifichiamo il modello introducento il fissaggio di alcune variabili creando in questo modo un intorno della soluzione migliore attuale
    Utility.ModifyModel(instance, x, rnd, percentageFixing, currentIncumbentSol);

    //Risolviamo il modello attuale
    cplex.Solve();

    //Se otteniamo un miglioramento
    if (currentIncumbentCost > cplex.GetObjValue(Cplex.IncumbentId))
    {
        //Preparo il file
        file = new StreamWriter(instance.InputFile + ".dat", false);

        //Aggiorno le variabili con l'attuale percorso e costo incumbent
        currentIncumbentCost = cplex.GetObjValue(Cplex.IncumbentId);
        currentIncumbentSol = cplex.GetValues(x, Cplex.IncumbentId);

        //Stampa del nuovo percorso incumbent su file
        for (int i = 0; i < instance.NNodes; i++)
        {
            for (int j = i + 1; j < instance.NNodes; j++)
            {
                int position = Utility.xPos(i, j, instance.NNodes);

                if (currentIncumbentSol[position] >= 0.5)
                {
                    file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                    file.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");
                }
            }
        }
        //Chiusura del file di tipo StreamWriter, il flush dal buffer viene eseguito
        file.Close();

        //Stampa attraverso GNUPLot del nuovo incumbet path
        Utility.PrintGNUPlot(process, instance.InputFile, 1, currentIncumbentCost, -1);

        //Resettiamo il numero di successivi non miglioramenti
        consecutiveiterationNotImprov = VALUECONSITENOTIMPROV;
    }
    else
    {
        //Il numero di consecutivi non miglioramenti è decrementato
        consecutiveiterationNotImprov--;
    }

    //Se ho raggiunto il limite di consecutivi non miglioramenti
    if (consecutiveiterationNotImprov == 0)
    {
        //Se la percentuale di fissaggio di un nodo è ancora superiore al 20% la diminuisco
        if (percentageFixing > 0.2)
        {
            //Diminuzione della percentuale di fissammento di un nodo di un 10%
            percentageFixing -= 0.1;
            //Resetto il numero di consecutivi non miglioramenti in seguito alla variazione dell'ampiezza dell'intorno da analizzare
            consecutiveiterationNotImprov = VALUECONSITENOTIMPROV;
        }
    }

    //Elimino l'ultimo fissaggio delle variabili in preparazione al prossimo 
    for (int i = 0; i < x.Length; i++)
    {
        x[i].LB = 0;
        x[i].UB = 1;
    }

} while (clock.ElapsedMilliseconds / 1000.0 < instance.TimeLimit);
//Ripeto il tutto fino a che non scade il timelimit, l'ultima iterazione può sforarlo fino a che non è completa

//Aggiorno la variabili instance con la soluzione migliore finale ed il relativo costo
instance.XBest = currentIncumbentCost;
instance.BestSol = currentIncumbentSol;

//Stampo righe vuota nell'output standard di Cplex
cplex.Output().WriteLine();
cplex.Output().WriteLine();
//Stampo il costo della miglior soluzione trovata nell'output standard di Cplex
cplex.Output().WriteLine("x = " + instance.XBest + "\n");
\end{lstlisting}

\subsection*{LOCAL BRANCH}

Terminata l'analisi di una possibile variante della tecnica \textit{hard-fixing} proseguiamo con la tipologia gemella del \textbf{soft-fixing}: si ricordi che la principale differenza tra i due approcci è che il secondo lascia al solver, nel nostro caso Cplex, anche l'operazione di fissaggio indicandogli solamente la forma che questo deve assuemere.

Nello specifico prendiamo in considerazione una particolare tipologia di algoritmi facente parte del ramo \textit{soft-fixing} e cioè il \textbf{Local Branch}: proposto nell'anno 2002 dai docenti universitari \textbf{Matteo Fischetti} \footnote{Docente presso l' Università di Padova, Dipartimento di Ingegneria dell’ Informazione.} e \textbf{Andrea Lodi} \footnote{Docente presso l' Università di Bologna, Dipartimento di Ingegneria dell'Energia Elettrica e dell'Informazione.}, questa variante mira ad ottenere l'esplorazione di un intorno $N(x,r)$ di una soluzione $x$ con un costo computazionale estremamente inferiore a $O(n^r)$ che invece abbiamo visto essere necessario per un classico algoritmo di \textit{r-ottimalità}.

Il \textit{Local Branch} non utilizza la classica tecnica di eplorazione per enumerazione di $N(x,r)$ ma introduce una specifica disequanzione al modello matematico del problema \textit{TSP}:


\begin{equation}\label{eq:LocalBranchVincoloAsimmetrico}
\displaystyle\sum_{e \text{ } : \text{ } x_e = 1} x_e^{*} \ge n - r
\end{equation}

Attraverso questo vincolo è il solver stesso a generare un intorno $N(x,r)$ sul quale cercare la soluzione migliore al suo interno. In altre parole, nel nostro esempio, sfruttiamo la velocità offerta da Cplex nel risolvere un modello matematico e costruiamo quest'ultimo così che ammetta tutte le soluzioni a loro volta valide per un algoritmo di \textit{r-ottimalità}.

Prendendo più in esame \eqref{eq:LocalBranchVincoloAsimmetrico}, è possibile notare come la sua elevata potenza sia in pieno contrasto alla sua estrema semplicità. Tra tutte le variabili disponibili, sono considerate solamente quelle facenti parte della soluzione $x$ attuale\footnote{Il cui numero totale pari al numero di nodi indicato con $n$.} e si impone che almeno $n-r$ dovranno far parte della nuova soluzione prodotta dal solver. Sono quindi ammessi fino a $r$ scambi tra variabili in soluzione e non, producendo di fatto \textit{gratuitamente} un'operazione di $r-ottimalità$.

La forma espressa dalla \eqref{eq:LocalBranchVincoloAsimmetrico} prende il nome di formulazione \textbf{asimentrica} in quanto non appaiono direttamente le variabili non selezionate da $x$. \'E presente anche una sua variante \textbf{simmetrica} che risulta essere sia più esplicita che maggiormente \textit{complessa}:

\begin{equation}\label{eq:LocalBranchVincoloSimmetrico}
\displaystyle\underbrace{\sum_{j\text{ } : \text{ } x_j = 0} x_j^{*}}_{\text{\# variabili cha passano da 0 a 1}} + \underbrace{\sum_{j\text{ }:\text{ } x_j = 1}(1 - x_j^{*})}_{\text{\# variabili cha passano da 1 a 0}} \le r
\end{equation}

Come si può vedere da una breve analisi le due forme \eqref{eq:LocalBranchVincoloAsimmetrico} e \eqref{eq:LocalBranchVincoloSimmetrico} sono del tutto equivalenti, nello specifico \eqref{eq:LocalBranchVincoloSimmetrico} definisce la massima distanza di \textbf{Hamming}\footnote{La distanza di \textit{Hamming} fra due vettori di pari dimensione, corrisponde al numero di posizioni aventi simboli corrispondenti diversi.} che può sussistere fra \textbf{$x^*$} e \textbf{$x$}\footnote, rispettivamente la nuova e la attuale soluzione.

Esponiamo due concetti riguardanti le due formulazioni proposto. Come prima cosa \eqref{eq:LocalBranchVincoloSimmetrico}, al contrario di \eqref{eq:LocalBranchVincoloAsimmetrico}, nel caso in cui voglia simulare una operazione $k-Opt$ deve porre $r = 2*k$ in quando devo indicare sia i lati che aggiungo rispetto a $x$ ma anche quelli che tolgo da quest'ultima.

In secondo luogo la decisione di quale delle due formulazioni adottare dipende dal tipo di problema: notiamo infatti che in \eqref{eq:LocalBranchVincoloSimmetrico} appaiono tutte le variabili del problema mentre in \eqref{eq:LocalBranchVincoloAsimmetrico} solamente quelle facenti parte della soluzione attuale. Nel caso in cui queste due quantità risultino paragonabili allora le due formulazioni sono entrambe valide. In caso contrario, come ad esempio i modelli di TSP analizzati in questa tesi dove la differenza è di un ordine di grandezza, \eqref{eq:LocalBranchVincoloSimmetrico} risulta molto più densa di \eqref{eq:LocalBranchVincoloAsimmetrico} e quindi più difficilmente gestibile dal solver.

Concludiamo questa introduzione teorica con una considerazione sui valori assegnabili ad $r$ nella \eqref{eq:LocalBranchVincoloAsimmetrico}. Sappiamo che una operazione di \textit{k ottimalità} comprende anche tutte le possibili $m-Opt$ dove $k>m$ pertanto più alto viene posto il valore di $r$ più diventa ampio l'intorno $N(x,r)$ dove andiamo a cercare la nuova soluzione e quindi le possibilità di ottenere un risultato migliore.
Naturale conseguenza è anche una maggiore complessità computazionale sia nel caso di una banale esplorazione per enumerazione di $N(x,r)$ sia attraverso l'uso del \textit{Local Branching}. Non è mai pertanto consigliabile oltreppassare certi limiti, direttamente dipendenti dal tipo di macchina sulla quale vengono fatti eseguire gli algoritmi, in quanto si viene a parte la fondamentale caratteristica degli euristici: la loro velocità.

\subsection*{IMPLEMENTAZIONE LOCAL BRANCHING}

Presentiamo ora il codice \textbf{commentato} che realizza la tecnica \textit{Local Branching} in versione \textbf{asimmetrica} per le motivazioni esposte nel precedente paragrafo.

Come per il metodo \textbf{hard fixing} qui viene riportato un versione basilare del codice che crea una soluzione di partenza attraverso la applicazione consecutiva del NN LINK!!!!!! e $2-Opt$ LINK!!!!. Nella parte finale della tesi dove sono presentati vari test, saranno invece utilizzate soluzioni migliore ottenute in precedenza dall'applicazione di altri metodi euristici.

Infine riprendendo quanto detto alla fine dell'ultimo paragrafo specifichiamo che i valori di $r$ utilizzati\footnote{Dove $r$ determina quale operazione di $r-Opt$ si ottiene.} sono solamente ${3, 5, 7, 10}$, raggiungibili in progressione una volta che i precedenti falliscono\footnote{Cioè se non si rova una soluzione migliore di quella già disponibile all'interno del suo intorno $N(x,r)$.}.

\begin{lstlisting}

static void LocalBranching(Cplex cplex, Instance instance, Process process, Random rnd, Stopwatch clock)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{cplex}: riferimento all'oggetto contenente il modello da risolvere;
    \item \textbf{instance}: riferimento all'oggetto contenente tutte le informazioni relative all'istanza del Problema del Commesso Viaggiatore corrente;
    \item \textbf{process}: riferimento all'oggetto necessario per la stampa dei dati attraverso \textit{GNUPlot};
    \item \textbf{rdn}: istanza della classe Random utilizzata per la generazione dei numeri casuali;
    \item \textbf{clock}: riferimento all'oggetto utilizzato come cronometro, deve già essere stato avviato;
\end{itemize}

\begin{lstlisting}

//Vettore contenente i possibili valori del raggio r che definisce l'intorno nel quale il metodo cerca
//una soluzione migliore della attuale
int[] possibleRadius = {3, 5, 7, 10};

//Variabile che memorizza l'indice dove trovare l'attuale raggio in possibleRadius, inizializzata a 0
int currentRange = 0;

//Variabile booleana utilizzare per comunicare alla Lazy Callback di Cplex se deve stampare la soluzione
//intera trovata nel caso migliore quella incumbent
bool BlockPrint = false;

//Inizializzazione del vettore contenente la soluzione incumbent
double[] incumbentSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

//Inizializzazione variabile contenente il costo della soluzione incumbent
double incumbentCost = double.MaxValue;

//Inizializzazione del vettore presente in istance sul quale viene memorizzata la soluzione finale migliore
instance.BestSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

//Creo il modello iniziale e assegnao ad x il riferimento alle sua variabili
INumVar[] x = Utility.BuildModel(cplex, instance, -1);

//All'indice i-esimo troviamo in ordine crescente quali sono i nodi più vicini all'i-esimo nodo
List<int>[] listArray = Utility.BuildSLComplete(instance);

//Prima parte della creazione della soluzione di partenza, si utilizza la tecnica del nearest neigh
PathStandard heuristicSol = Utility.NearestNeighbour(instance, rnd, listArray);

///Seconda parte della creazione della soluzione di partenza, si applica un semplice 2-Opt
TwoOpt(instance, heuristicSol);

//Aggiornamento del vettore incumbentSol secondo la soluzione iniziale appena prodotta
for (int i = 0; i < instance.NNodes; i++)
{
    int position = Utility.xPos(i, heuristicSol.path[i], instance.NNodes);

    incumbentSol[position] = 1;
}

//Installazione Lazy Callback
cplex.Use(new TSPLazyConsCallback(cplex, x, instance, process, BlockPrint));

//Settaggio per il multi-thread di Cplex, si utilizzano tanti thread quanti i core virtuali della macchina
cplex.SetParam(Cplex.Param.Threads, cplex.GetNumCores());

//Aggiunta di un warm-start per Cplex
cplex.AddMIPStart(x, incumbentSol);

//Inizio creazione del vincolo asincrono caratterizzante il Local Branching

//Creao il contenitore per l'espressione del vincolo di Local Branching
ILinearNumExpr expr = cplex.LinearNumExpr();

//Popolo il contenitore secondo le variabili utilizzate dalla soluzione di partenza appena creata
for (int i = 0; i < instance.NNodes; i++)
    expr.AddTerm(x[Utility.xPos(i, heuristicSol.path[i], instance.NNodes)], 1);

//Dovendo ad ogni applicazione del Local Branching sostituire il vincolo caratterizzante, si memorizza
//quello attuale in una variabile apposita in modo tale da facilitare la sua rimozione futura
IAddable localBranchConstraint  = cplex.Ge(expr, instance.NNodes - possibleRadius[currentRange]);

//Aggiungo il vincolo creato non come un qualsiasi taglio ma come una vero e proprio vincolo
//del modello matematico, la risoluzione da parte di Cplex è nettamente migliorata
cplex.Add(localBranchConstraint);


//Inizio ciclo do-while che ripete la tecnica del Local Branching fino al termine del tempo limite
//indicato dall'utente o quando il raggio r=10 non produce più miglioramenti
do
{
    //Cplex risolve l'attuale modello
    cplex.Solve();

    //Se trovo un miglioramento rispetto alla soluzione incumbent
    if (incumbentCost > cplex.GetObjValue())
    {
        //Sostituisco l'incumbent attuale con i valori appena trovati da Cplex
        incumbentCost = cplex.ObjValue;
        incumbentSol = cplex.GetValues(x);

        //Rimozione del vincolo caratterizzante attualmente utilizzato nel modello
        cplex.Remove(localBranchConstraint);

        //Preparo il nuovo vincolo caratterizzante sfruttando l'esplorazione della nuova soluzione
        //per la sua stampa a video attraverso GNUPlot

        expr = cplex.LinearNumExpr();

        StreamWriter file = new StreamWriter(instance.InputFile + ".dat", false);

        //Scandisco ogni variabile per vedere se fa parte della nuova soluzione
        for (int i = 0; i < instance.NNodes; i++)
        {
            for (int j = i + 1; j < instance.NNodes; j++)
            {
                int position = Utility.xPos(i, j, instance.NNodes);

                //Testo se l'attuale variabile è stata selezionata nella nuova soluzione
                if (incumbentSol[position] >= 0.5)
                {
                    //Stampo su file il percorso della nuova soluzione per GNUPlot
                    file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                    file.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");

                    //In contemporanea aggiungo il termine all'espressione per il nuovo vincolo caratterizzante
                    expr.AddTerm(x[position], 1);
                }
            }
        }

        //Lancio la stampa attraverso GNUPlot e chiudo il flusso del file utilizzato
        file.Close();
        Utility.PrintGNUPlot(process, instance.InputFile, 1, incumbentCost, -1);

        //Completo la creazione del nuovo vincolo caratterizzante
        localBranchConstraint = cplex.Ge(expr, instance.NNodes - possibleRadius[currentRange]);

        //Aggiungo il nuovo vincolo caratterizzante al modello matematico
        cplex.Add(localBranchConstraint);
    }
    else
    {
        //Nel caso in cui non si sia trovata una soluzione migliore testo se posso aumentare il range r
        if (possibleRadius[currentRange] != 10)
        {
            //Aumento l'indice di possibleRadius sui cui trovare il nuovo raggio da utilizzare
            currentRange++;

            //Rimuovo il precedente vincolo
            cplex.Remove(localBranchConstraint);

            //Aggiorno il range r del vincolo caratterizzante mantenendo chiaramente le variabili
            //coinvolte dato che la soluzione incumbent rimane la medesima della precedente iterazione
            localBranchConstraint = cplex.Ge(expr, instance.NNodes - possibleRadius[currentRange]);

            //Aggiungo il vincolo caratterizzante aggiornato al modello matematico
            cplex.Add(localBranchConstraint);
        }
        else
        {
            //Nel caso non sia possibile aumentare ulteriormente il raggio r termino il ciclo do-while
            break;
        }
    }
} while (clock.ElapsedMilliseconds / 1000.0 < instance.TimeLimit);

//Memorizzo nelle apposite variabili di instance la soluzione finale trovata ed il relativo costo
instance.BestSol = incumbentSol;
instance.BestLb = incumbentCost;

\subsection*{RINS}

\subsection*{POLISHING}

\section*{APPENDICE}

\subsection*{METODO MODIFYMODEL (APPENDICE)}

Il metodo ModifyModel fissa in soluzione, con una certa percentuale p, lati che appartengono ad una soluzione ammissibile. La sua firma risulta essere:

\begin{lstlisting} 
public static void ModifyModel(Instance instance, INumVar[] x, Random rnd, double percentageFixing, double[] solution)
\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{instance}: riferimento all' oggetto contenente tutte le informazioni relative all' istanza del Problema del Commesso Viaggiatore corrente;
    \item \textbf{x}: vettore contenente le variabili del modello;
    \item \textbf{rnd}: istanza della classe Random utilizzata per la generazione dei numeri casuali;
    \item \textbf{percentageFixing}: Probabilità con cui un lato viene fissato in soluzione;
    \item \textbf{solution}: Vettore che codifica la soluzione ammissibile su cui si fissano in soluzione i lati.
\end{itemize}


L' idea dell' algoritmo consiste nel scandire tutti i lati appartenenti alla soluzione ammissibile fornitagli in ingresso, invocare per ognuno lato il metodo \textbf{RandomSelect} e se ritorna 1 viene fissato il lato altrimenti no. Per fissarlo si pone semplicemente il LB della variabile ad esso associata a 1.  Il ciclo do - while serve per ripete il fissaggio qualora si fissino tutti i lati o non si vincoli solo un lato poichè non avrebbe senso a questo punto far partire cplex. Al termine del metodo viene effettuato il preprocessing discusso del paragrafo precedente.

\begin{lstlisting}

//Stored the number of variable fixed
int nVariabileFix = 0;

do
{
nVariabileFix = 0;

//Scan all edge that belong to the current heuristic solution
for (int i = 0; i < x.Length; i++)
{
if ((solution[i] == 1))
{
//Whit a percentageFixing probability fix a edge belong to the current solution
if (RandomSelect(rnd, percentageFixing) == 1)
{
x[i].LB = 1;
nVariabileFix++;
}
}
}

} while (nVariabileFix >= instance.NNodes - 1);

Utility.PreProcessingTSP(instance, x);

\end{lstlisting}

\subsection*{FILL ROULETTE}

Il metodo FillRoulette ha il compito di popolare la roulette in modo tale che la selezione sia proporzionale alla fitness. Associa ad ogni circuito un numero intero, chiamato \textbf{NRoulette}, progressivo e inserisce all'interno della roulette tale valore un numero di volte proporzionale al valore della fitness del circuito, infine ritorna la dimensione della roulette. La sua firma risulta essere:

\begin{lstlisting}

static int FillRoulette(List<int> roulette, List<PathGenetic> CurrentGeneration)

\end{lstlisting}

\begin{itemize}
    \item \textbf{roulette}: Lista di interi che rappresenta la roulette e che viene popolata dal metodo;
    \item \textbf{CurrentGeneration}: Lista contenente i circuiti candidati a far parte della nuova generazione;
\end{itemize}

Utilizzando il metodo \textbf{Estimate} LINK!!!!!!!!!!!!! si ottiene una costante intera che viene memorizzata all'interno della variabile \textbf{proportionalityConstant}: moltiplicare questo valore per la fitness di un circuito ci dice quante volte il corrispondente \textit{NRoulette} associato vada inserito nella ruolette. Poiché all'interno della stessa generazione i valori della fitness non variano per ordini di grandezza, tale costante viene per convenzione calcolata utilizzando il circuito memorizzato all'indice $0$ in \textit{CurrentGeneration}.
\begin{lstlisting}

int sizeRoulette = 0;
            
int proportionalityConstant = Estimate(CurrentGeneration[0].Fitness);

for (int i = 0; i < CurrentGeneration.Count; i++)
{
   int prob = (int)(CurrentGeneration[i].Fitness * proportionalityConstant);
   CurrentGeneration[i].NRoulette = i;
   sizeRoulette += prob;
   
   for (int j = 0; j < prob; j++)
     roulette.Add(i);
}
return sizeRoulette;

\end{lstlisting}

\subsection*{ESTIMATE}

Il metodo Estimate genera una costante di proporzionalità in modo tale che, eseguendo il prodotto fra tale costante ed il valore ricevuto come parametro di ingresso, si ottenga una quantità sempre maggiore di 100 PERCHE'??????? A COSA SERVE?????. La sua firma risulta essere:

\begin{lstlisting}

static int Estimate(double sample)
{
    int k = 1;
    while (sample*k < 100)
    {
        k = k * 10;
    }
    return k;
}

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{sample}: Valore della fitness presa come campione.
\end{itemize}

\subsection*{REPAIR}

Il metodo Repair è stato progettato per trasformare un percorso che non risulta essere un circuito hamiltoniano in un circuito hamiltoniano. Sappiamo che visitare più volte lo stesso nodo rende tale proprietà non vera così come la presenza di almeno un nodo isolato. L'algoritmo si sviluppa in due fasi: in un primo momento si eliminano dal vettore che codifica il percordo tutti i nodi duplicati, successivamente si fa in modo che quelli isolati vengano connessi al nodo ad essi più vicini. Un esempio di funzionamento dell'algoritmo è riportato nei tre grafici sottostanti.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"circuitoF".jpg}
    \caption{Circuito non hamiltoniano figlio}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"circuitoH".jpeg}
    \caption{Circuito hamiltoniano incompleto}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{Immagini/"circuitoC".jpg}
    \caption{Circuito hamiltoniano figlio}
\end{figure}

Discutiamo ora il codice prodotto. Costruiamo due liste di interi chiamate \textbf{isolatedNodes} e \textbf{nearlestIsolatedNodes} dove rispettivamente contengono all'i-esimo elemento l'indice dell'i-esimo nodo isolato e l' indice del nodo ad esso più vicino\footnote{Ci sono in realtà delle eccezzioni a quest'ultima affermazione che vedremo in seguito}.
Per popolare tali liste utilizziamo i metodi \textbf{FindIsolatedNodes} LINK!!!!!! e \textbf{FindNearestNode} LINK!!!!!!!!!!.
Dichiariamo le due liste \textbf{pathIncomplete} e \textbf{pathComplete}, nella prima andiamo ad inserire il percorso originale privo degli elementi che lo rendono non hamiltoniano mentre nella seconda costruiamo il percorso completo di tutti i nodi ed hamiltoniano. Per ottenere quest'ultimo risultato procediamo ciclicamente con la copia di ogni elemento appartente a \textit{pathIncomplete} in \textbf{pathComplete} facendo però in modo che, se per un qualsisi $i, j, m$ vale $pathIncomplete[i]=nearlestIsolatedNodes[j]$, allora nel caso andiamo a porre $pathComplete[m]=pathIncomplete[i]$ dovrà anche valere $pathComplete[m+1]=isolatedNodes[j]$ e $pathComplete[m+2]=pathIncomplete[i+1]$ simili a quanto avviene nella Figura 3!!!!!!!!!!!!!!!!!!!!!!!.

\begin{lstlisting}

int positionInsertNode = 0;

for (int i = 0; i < pathIncomplete.Count; i++)
{
    if (nearlestIsolatedNodes.Contains(pathIncomplete[i]))
    {
        pathComplete[positionInsertNode] = pathIncomplete[i];
        pathComplete[positionInsertNode + 1] = isolatedNodes[nearlestIsolatedNodes.IndexOf(pathIncomplete[i])];
        positionInsertNode++;
    }
    else
        pathComplete[positionInsertNode] = pathIncomplete[i];

    positionInsertNode++;
}
return new PathGenetic(pathComplete, instance);
\end{lstlisting}

\subsection*{FINDISOLATEDNODES}

Tale funzione viene utilizzata per identificare tutti i nodi isolati presenti in un generico percorso.
La sua firma risulta essere:

\begin{lstlisting}
static void FindIsolatedNodes(Instance instance, int[] path, List<int> isolatedNodes)
\end{lstlisting}

\begin{itemize}
    \item \textbf{instance}: oggetto della classe Instance contenente tutti i dati che descrivono l'istanza del problema del Commesso Viaggiatore fornita in ingresso dall' utente;
    \item \textbf{isolatedNodes}: Lista contenente gli indici di tutti i nodi isolati;
\end{itemize}

Data la semplicità del metodo non si ritiene utile far nessuna considerazione, riportiamo direttamente il codice realizzato.

\begin{lstlisting}

bool nodeIsVisited = false;

for (int i = 0; i < instance.NNodes; i++)
{
    for (int j = 0; j < instance.NNodes; j++)
    {
         if (pathChild[j] == i)
         {
            nodeIsVisited = true;
            //If the node is visited can exit to for
            break;
         }
    }

    //If the node has nevere been visited is a isolated noode
    if (nodeIsVisited == false)
       isolatedNodes.Add(i);

    //Configure nodeIsVisited to its default value
    nodeIsVisited = false;
}

\end{lstlisting}

\subsection*{FINDNEARESTNODE}

Dato un certo circuito ed una lista di nodi isolati in esso contenuti, il metodo FindNearestNode fornisce per ognuno di essi il nodo più vicino \textit{valido} ossia che rispetti le seguenti condizioni:

\begin{itemize}
    \item  Non deve essere un nodo isolato;
    \item  Non deve essere il nodo più vicino di un nodo isolato precedentemente analizzato. In altre parole se $n_3$ è un nodo non isolato e risulta il nodo più vicino dei nodi isolati $n_1$ e $n_2$ non è possibile avere: $nearestNeighIsolNode[indice_{n_1}] = n_3 \wedge nearestNeighIsolNode[indice{n_2}] = n_3$. Per convenzione, supponendo $indice_{n_1} < indice_{n_2}$ vale $nearestNeighIsolNode[indice_{n_1}] = n_3$ mentre a $nearestNeighIsolNode[indice_{n_2}]$ viene assegnato il successivo nodo valido più vicino disponibile.
\end{itemize}

Il codice commentato della funzione viene riportato di seguito.

COMMENTA CODICE!!!!!!!!!!!!!!!!!!!!!!! RIPORTA TUTTO IL METODO!!!!!!!!!!!!!!!!! PUBLIC ...

\begin{lstlisting}

int nextNode = 0;
int nearestNode = 0;
bool find = true;

for (int i = 0; i < isolatedNodes.Count; i++)
{
    find = false;
    nextNode = 0;
    do
    {
       nearestNode = listArray[isolatedNodes[i]][nextNode];

       if (((isolatedNodes.Contains(nearestNode)) == false) && (nearestNeighIsolNode.Contains(nearestNode) == false))
       {
          nearestNeighIsolNode.Add(nearestNode);
          find = false;
       }
       else
       {
           nextNode++;
           find = true;
       }
    } while (find);
}

\end{lstlisting}

\subsection*{BESTSOLUTION}

Il metodo BestSolution riceve come input una serie di percorsi hamiltoniani memorizzati attraverso la classe \textbf{PathGenetic} LINK!!!!!!!!!!!!!!!!!!!! ed in output fornisce quello a costo minore, la sua intestazione risulta essere:

\begin{lstlisting}

public static PathGenetic BestSolution(List<PathGenetic> population)

\end{lstlisting}

Dove:

\begin{itemize}
    \item \textbf{population}: Insieme di cammini hamiltoniani;
\end{itemize}

Di seguito il codice:

\begin{lstlisting}

PathGenetic currentBestPath = population[0];

for (int i = 1; i < population.Count; i++)
{
   if (population[i].cost < currentBestPath.cost)
      currentBestPath = population[i];
}

return currentBestPath;

\end{lstlisting}

\section*{TEST E RISULTATI}

In questa sezione sono presentati i test eseguiti sugli algoritmi discussi nel testo. La presentazione è suddivisa in tre sottozezioni:
\begin{itemize}
    \item Instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti;
    \item Instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti;
    \item Instanze con numero di nodi compreso tra \textbf{$300$} e \textbf{$999$} $+$ algoritmi euristici;
\end{itemize}
Essendo il codice progettatto in Visual Studio utilizzando il linguaggio C\#, non è stato possibile utilizzare il cluster di calcolo offerto dal dipartimento di studio DEI dell'università di Padova. Pertanto la macchina su cui i test sono stati eseguiti è un normale PC di utilizzo quotidiano: da pretest eseguiti durante la fase di sviluppo, si era già notato come istanze di tagli superiore ai $300$ nodi richiedessero tempi troppo alti per essere risolte da algoritmi esatti; Tenendo presente inoltre che sarebbero state richiesti multipli tentativi di risoluzione per ogni coppia istanza/algoritmo, si è deciso di optare per la suddivisione appena descritta.

I dettagli hardware della macchina utilizzata sono riportati di seguito ma è necessario far notare che è stato imposto un limite massimo all'utilizzo della CPU pari al $75\%$: si è voluto sfruttare l'arco minimo di tempo per i test in modo tale che l'ambiente rimanesse il più omogeneo possibile, pertanto un uso superiore delle prestazioni del PC per 2/4 giorni di seguito\footnote{Attualemente ci troviamo in stagione estiva con alte temperature.} avrebbe potuto arrecarvi danni.

\begin{figure}[htbp]
    \centering
    \scalebox{1}{\includegraphics{Immagini/"Spec1".jpg}}
    \caption{CPU}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{1}{\includegraphics{Immagini/"Spec2".jpg}}
    \caption{Caches}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{1}{\includegraphics{Immagini/"Spec3".jpg}}
    \caption{Scheda madre}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{1}{\includegraphics{Immagini/"Spec4".jpg}}
    \caption{RAM}
\end{figure}


Aggiungiamo solamente infine che il sistema operativo è Windows 10 Pro versione 1703 installato su una memoria a stato solido con velocità di lettura/scrittura fino a 535 MB sec/445 MB sec.

Concludiamo questa introduzione spendendo alcune righe descrivendo alcuni aspetti comuni a tutti i test.

Nelle tre successessive sottosezioni troviamo inizialmente una descrizione delle sigle utilizzate per identificare gli algoritmi utilizzati e l'indicazione del numero di run eseguite. Successivamente sono esposti i tempi medi di esecuzione, espressi in secondi, sotto forma tabellare utilizzando come tempo limite $30$ minuti. Infine troviamo una serie di immagini che mostrano visivamente un confronto dei vari algoritmi per ogni istanza.

Per nessun test sono riportati i circuiti hamiltoniani trovati in quanto le istanze utilizzate sono tutte note in litteratura e già risolte all'ottimo. L'obiettivo che si vuole raggiungere è, per quanto riguarda gli algoritmi esatti un confronto dei loro tempi di esecuzione, mentre invece per quelli euristici un confronto del costo delle soluzioni da loro trovate e il valore ottimo noto entro un tempo limite fissato.

In ogni algoritmo sono state quindi rimosse tutte le stampe sia visuali attraverso GNUPlot che su file del circuito trovato ed anche la stampa su file del modello matematico finale comprendente i tagli generati. Le prove per gli algoritmi esatti sono state automatizzate in modo tale che per la stessa istanza venissero eseguiti in serie tutte le run necessarie ogni algoritmo\footnote{Ogni run è stata caratterizzata da un seme diverso sia per quanto riguarda Cplex sia per quanto riguarda gli oggetti utilizzati per generare valori random.}.

Nel caso in cui una o più run presentavano rallentamentamenti apparentemente non motivabili o improvvisi queste sono state ripetute per verificare che il problema non riguardasse fattori esterni determinati dalla macchina utilizzata. Tutti i valori riportati sono quindi verificati sotto questo punto di vista e dipendenti solamente dalla applicazione sviluppata.

\subsection*{Instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}

Gli algoritmi esatti a disposizione sono i seguenti: Loop completamente esatto più le sue due varianti a prima fase euristica (linguaggio C\#), utilizzo LazyConstraint Callback (linguaggio C\#), utilizzo LazyConstraint e UserCut Callback (linguaggio C).

Il numero di run per ogni algoritmo è stato di 5: i valori riportati sono quindi una media aritmetica.

Passiamo quindi alla descrizione delle sigle utilizzate:
\begin{itemize}
    \item \textbf{LOOP}: metodo Loop completamente esatto;
    \item \textbf{L EG\textit{X}}: metodo Loop con prima fase euristica dove EpGap è settato al $X\%$;
    \item \textbf{L LA\textit{X}}: metodo Loop con prima fase euristica dove sono abilitati i soli \textit{X} lati a costo minore incidenti in un qualsiasi nodo;
    \item \textbf{L EG\textit{X} LA\textit{Y}}: combinazione dei due punti precedenti;
    \item \textbf{LAZY}: utilizzo lazyconstraint callback in linguaggio\textit{ C\#};
    \item \textbf{USER}: utilizzo lazyconstraint callback e usercut callback in linguaggio \textit{C};
\end{itemize}

Notiamo che modificare un modello matematico attraverso l'eliminazione di alcune variabili può causare l'invalidazione di tutte le soluzioni originali: questi casi sono di seguito riconoscibili da un tempo di esecuzione medio pari a $0,00$ secondi.

\newpage

\begin{table}
\begin{adjustbox}{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \cline{2-10} 
        \multicolumn{1}{c|}{} & \multirow{3}{*}{\textbf{LOOP}} & \multirow{3}{*}{\textbf{L EG5}} & \multirow{3}{*}{\textbf{L EG10}} & \multirow{3}{*}{\textbf{L LA5}} & \multirow{3}{*}{\textbf{L LA10}} & \multirow{3}{*}{\textbf{L EG5 LA5}} & \multirow{3}{*}{\textbf{L EG10 LA10}} & \multirow{3}{*}{\textbf{LAZY}} & \multirow{3}{*}{\textbf{USER}}\tabularnewline
        \multicolumn{1}{c|}{} &  &  &  &  &  &  &  &  & \tabularnewline
        \multicolumn{1}{c|}{} &  &  &  &  &  &  &  &  & \tabularnewline
        \hline 
        \textbf{\hyperref[fig:berlin52]{berlin52}} & 0,111 & 0,083 & 0,073 & 0,092 & 0,053 & 0,096 & 0,051 & 0,028 & 0,024\tabularnewline
        \hline 
        \textbf{\hyperref[fig:st70]{st70}} & 0,628 & 0,577 & 0,579 & 0,000 & 0,193 & 0,000 & 0,187 & 0,298 & 0,363\tabularnewline
        \hline 
        \textbf{\hyperref[fig:eil76]{eil76}} & 0,297 & 0,254 & 0,235 & 0,204 & 0,075 & 0,204 & 0,075 & 0,107 & 0,084\tabularnewline
        \hline 
        \textbf{\hyperref[fig:pr76]{pr76}} & 3,586 & 3,572 & 3,305 & 0,000 & 2,958 & 0,000 & 2,589 & 6,344 & 3,178\tabularnewline
        \hline 
        \textbf{\hyperref[fig:rat99]{rat99}} & 1,040 & 1,010 & 1,041 & 0,845 & 0,458 & 0,670 & 0,450 & 0,396 & 0,468\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroA100]{kroA100}} & 2,009 & 1,959 & 1,891 & 1,544 & 0,770 & 1,504 & 0,777 & 0,915 & 1,508\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroB100]{kroB100}} & 3,745 & 4,016 & 3,031 & 1,767 & 1,820 & 2,026 & 1,699 & 0,785 & 1,026\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroC100]{kroC100}} & 2,306 & 1,850 & 1,908 & 2,197 & 0,823 & 1,878 & 0,821 & 0,648 & 0,996\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroD100]{kroD100}} & 2,397 & 1,758 & 1,990 & 2,547 & 0,896 & 1,903 & 0,934 & 0,514 & 0,769\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroE100]{kroE100}} & 2,017 & 2,243 & 2,290 & 2,168 & 1,137 & 1,793 & 0,936 & 1,084 & 0,900\tabularnewline
        \hline 
        \textbf{\hyperref[fig:eil101]{eil101}} & 0,952 & 0,851 & 0,802 & 0,426 & 0,370 & 0,433 & 0,414 & 0,363 & 0,342\tabularnewline
        \hline 
        \textbf{\hyperref[fig:lin105]{lin105}} & 1,402 & 0,897 & 0,959 & 0,664 & 1,000 & 0,625 & 0,588 & 0,545 & 1,071\tabularnewline
        \hline 
        \textbf{\hyperref[fig:bier127]{bier127}} & 1,862 & 2,228 & 3,077 & 1,251 & 0,981 & 1,222 & 0,905 & 1,093 & 1,636\tabularnewline
        \hline 
        \textbf{\hyperref[fig:ch130]{ch130}} & 2,013 & 2,213 & 2,198 & 1,625 & 0,980 & 1,911 & 1,052 & 1,373 & 1,589\tabularnewline
        \hline 
        \textbf{\hyperref[fig:pr144]{pr144}} & 10,247 & 6,362 & 4,023 & 0,000 & 7,427 & 0,000 & 5,703 & 3,300 & 2,020\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroA150]{kroA150}} & 9,446 & 8,455 & 7,329 & 3,875 & 4,524 & 3,536 & 4,096 & 2,943 & 3,058\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroB150]{kroB150}} & 15,815 & 10,842 & 12,213 & 9,041 & 7,643 & 5,165 & 8,266 & 8,473 & 5,067\tabularnewline
        \hline 
        \textbf{\hyperref[fig:ch150]{ch150}} & 4,563 & 5,158 & 6,103 & 2,348 & 2,612 & 3,034 & 3,987 & 2,413 & 2,481\tabularnewline
        \hline 
        \textbf{\hyperref[fig:pr152]{pr152}} & 4,806 & 3,961 & 3,610 & 0,000 & 0,000 & 0,000 & 0,000 & 2,638 & 3,130\tabularnewline
        \hline 
        \textbf{\hyperref[fig:u159]{u159}} & 3,310 & 2,816 & 2,766 & 1,538 & 2,146 & 1,339 & 2,364 & 1,876 & 2,759\tabularnewline
        \hline 
        \textbf{\hyperref[fig:rat195]{rat195}} & 25,914 & 19,111 & 19,606 & 13,473 & 15,830 & 11,534 & 14,198 & 13,354 & 4,130\tabularnewline
        \hline 
\end{tabular}
\end{adjustbox}
\caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"berlin52".png}}
    \label{fig:berlin52}
    \caption{berlin52}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"st70".png}}
    \label{fig:st70}
    \caption{st70}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"eil76".png}}
    \label{fig:eil76}
    \caption{eil76}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"pr76".png}}
    \label{fig:pr76}
    \caption{pr76}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"rat99".png}}
\label{fig:rat99}
\caption{rat99}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroA100".png}}
\label{fig:kroA100}
\caption{kroA100}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroB100".png}}
\label{fig:kroB100}
\caption{kroB100}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroC100".png}}
\label{fig:kroC100}
\caption{kroC100}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroD100".png}}
\label{fig:kroD100}
\caption{kroD100}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroE100".png}}
\label{fig:kroE100}
\caption{kroE100}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"eil101".png}}
\label{fig:eil101}
\caption{eil101}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"lin105".png}}
\label{fig:lin105}
\caption{lin105}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"bier127".png}}
\label{fig:bier127}
\caption{bier127}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"ch130".png}}
\label{fig:ch130}
\caption{ch130}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"pr144".png}}
\label{fig:pr144}
\caption{pr144}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroA150".png}}
\label{fig:kroA150}
\caption{kroA150}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroB150".png}}
\label{fig:kroB150}
\caption{kroB150}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"ch150".png}}
\label{fig:ch150}
\caption{ch150}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"pr152".png}}
\label{fig:pr152}
\caption{pr152}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"u159".png}}
\label{fig:u159}
\caption{u159}
\end{figure}

\begin{figure}[htbp]
\centering
\scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"rat195".png}}
\label{fig:rat195}
\caption{rat195}
\end{figure}

\FloatBarrier

\subsection*{Instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}

Questo set di risultati ha le stesse identiche premesse indicate per il precedente se non che il numero di run eseguito per ogni coppia istanza/algoritmo è pari a $2$ e non $5$. Il motivo di tale scelta è puramente per una questione temporale.

Come più volte ripetuto è stato posto un tempo limite pari a $30$ minuti il quale è stato raggiunto dall'istanza \textbf{pr99} se risolta attraverso l'utilizzo della sola \textit{LazyConstraint Callback}: il valore medio comunicato da Cplex per ottenere il risultato ottimo era in questo di circa lo $0,36\%$.

\vspace*{\fill}
{
\centering
\centerline{
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
        \cline{2-10} 
        \multicolumn{1}{c|}{} & \multirow{3}{*}{\textbf{LOOP}} & \multirow{3}{*}{\textbf{L EG5}} & \multirow{3}{*}{\textbf{L EG10}} & \multirow{3}{*}{\textbf{L LA5}} & \multirow{3}{*}{\textbf{L LA10}} & \multirow{3}{*}{\textbf{L EG5 LA5}} & \multirow{3}{*}{\textbf{L EG10 LA10}} & \multirow{3}{*}{\textbf{LAZY}} & \multirow{3}{*}{\textbf{USER}}\tabularnewline
        \multicolumn{1}{c|}{} &  &  &  &  &  &  &  &  & \tabularnewline
        \multicolumn{1}{c|}{} &  &  &  &  &  &  &  &  & \tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroA200]{kroA200}} & 26,12 & 35,36 & 35,02 & 23,71 & 25,25 & 20,73 & 23,20 & 61,62 & 65,22\tabularnewline
        \hline 
        \textbf{\hyperref[fig:kroB200]{kroB200}} & 10,92 & 13,53 & 13,93 & 4,86 & 6,44 & 5,67 & 5,11 & 6,05 & 5,21\tabularnewline
        \hline 
        \textbf{\hyperref[fig:tsp225]{tsp225}} & 28,10 & 26,72 & 28,15 & 11,61 & 15,46 & 14,85 & 15,20 & 23,49 & 6,70\tabularnewline
        \hline 
        \textbf{\hyperref[fig:pr226]{pr226}} & 326,40 & 32,52 & 16,64 & 0,00 & 0,00 & 0,00 & 0,00 & 7,97 & 4,90\tabularnewline
        \hline 
        \textbf{\hyperref[fig:gil262]{gil262}} & 26,86 & 40,91 & 27,55 & 8,95 & 14,02 & 18,27 & 20,29 & 79,30 & 37,50\tabularnewline
        \hline 
        \textbf{\hyperref[fig:a280]{a280}} & 19,00 & 29,20 & 16,74 & 5,03 & 6,48 & 4,75 & 10,06 & 6,46 & 5,56\tabularnewline
        \hline 
        \textbf{\hyperref[fig:pr299]{pr299}} & 102,89 & 142,75 & 128,17 & 67,00 & 85,60 & 97,19 & 101,65 & 1800,00 & 27,52\tabularnewline
        \hline 
\end{tabular}
}
\captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroA200".png}}
    \label{fig:kroA200}
    \caption{kroA200}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"kroB200".png}}
    \label{fig:kroB200}
    \caption{kroB200}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"tsp225".png}}
    \label{fig:tsp225}
    \caption{tsp225}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"pr226".png}}
    \label{fig:pr226}
    \caption{pr226}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"gil262".png}}
    \label{fig:gil262}
    \caption{gil262}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"a280".png}}
    \label{fig:a280}
    \caption{a280}
\end{figure}

\begin{figure}[htbp]
    \centering
    \scalebox{.75}{\includegraphics{Immagini/GRAFI_ESATTI/"pr299".png}}
    \label{fig:pr299}
    \caption{pr299}
\end{figure}

\FloatBarrier

\subsection*{Instanze con numero di nodi compreso tra \textbf{$300$} e \textbf{$999$} $+$ algoritmi euristici}

\subsubsection*{MULTI START}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{lin318 MULTI START (costo ottimo 42029)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            44098 & 0,6 & 45374 & 0,6 & 45153 & 0,6 & 45442 & 0,6\tabularnewline
            \hline 
            43987 & 3,6 & 43904 & 1,7 & 44188 & 1,1 & 44054 & 1,5\tabularnewline
            \hline 
            43962 & 6,6 & 43663 & 4,1 & 43976 & 2,3 & 43695 & 1,9\tabularnewline
            \hline 
            43783 & 10,9 & 43620 & 14,9 & 43960 & 6,5 & 43139 & 40,6\tabularnewline
            \hline 
            43641 & 11,9 & 43549 & 20,7 & 43688 & 15,7 & 43094 & 684,7\tabularnewline
            \hline 
            43575 & 112,5 & 43231 & 319,1 & 43358 & 41,6 & 43094 & 1800,0\tabularnewline
            \hline 
            43286 & 145,3 & 43231 & 1800,0 & 43315 & 639,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            42935 & 872,0 & \multicolumn{1}{c}{} &  & 43230 & 833,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            42935 & 1800,0 & \multicolumn{1}{c}{} &  & 43020 & 1196,2 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 43020 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
\begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline 
    \multicolumn{8}{|c|}{pr439 MULTI START (costo ottimo 107217)}\tabularnewline
    \hline 
    \hline 
    \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
    \hline 
    Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s)\tabularnewline
    \hline 
    116111 & 1,2 & 112354 & 1,4 & 116794 & 0,9 & 116014 & 1,5\tabularnewline
    \hline 
    114306 & 2,4 & 112228 & 8,2 & 114316 & 1,7 & 111574 & 3,2\tabularnewline
    \hline 
    112609 & 6,7 & 111791 & 13,9 & 112781 & 7,9 & 109631 & 6,2\tabularnewline
    \hline 
    112481 & 11,7 & 110439 & 21,9 & 111045 & 18,0 & 109539 & 198,4\tabularnewline
    \hline 
    110785 & 19,8 & 110324 & 32,9 & 110899 & 34,3 & 109395 & 901,7\tabularnewline
    \hline 
    110182 & 146,5 & 109949 & 104,7 & 110584 & 78,9 & 109240 & 1158,3\tabularnewline
    \hline 
    110122 & 168,2 & 109641 & 294,3 & 110424 & 172,5 & 109240 & 1800,0\tabularnewline
    \hline 
    109928 & 366,4 & 109519 & 544,3 & 109705 & 213,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
    \cline{1-6} 
    109823 & 416,9 & 109270 & 1119,0 & 109659 & 526,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
    \cline{1-6} 
    109352 & 1066,4 & 109220 & 1431,2 & 109508 & 706,3 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
    \cline{1-6} 
    109335 & 1253,0 & 109220 & 1800,0 & 109508 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
    \cline{1-6} 
    109335 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
    \cline{1-2} 
\end{tabular}
}
\captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{d493 MULTI START (costo ottimo 35002)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s)\tabularnewline
            \hline 
            36948 & 1,8 & 36912 & 2,4 & 36904 & 1,9 & 36459 & 1,6\tabularnewline
            \hline 
            36857 & 4,8 & 36895 & 4,9 & 36889 & 5,9 & 36409 & 37,6\tabularnewline
            \hline 
            36673 & 13,9 & 36821 & 12,1 & 36672 & 10,0 & 36256 & 91,0\tabularnewline
            \hline 
            36304 & 30,6 & 36771 & 20,6 & 36607 & 11,0 & 36175 & 1008,1\tabularnewline
            \hline 
            36257 & 191,1 & 36767 & 22,0 & 36393 & 15,8 & 36069 & 1059,5\tabularnewline
            \hline 
            36179 & 431,2 & 36633 & 31,5 & 36207 & 17,7 & 36069 & 1800,0\tabularnewline
            \hline 
            36157 & 1019,7 & 36588 & 32,3 & 36021 & 27,7 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            36157 & 1800,0 & 36534 & 68,8 & 36021 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            \multicolumn{1}{c}{} &  & 36441 & 90,3 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 36284 & 111,9 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 36253 & 278,9 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 36026 & 556,5 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 36026 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{cc|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{rat575 MULTI START (costo ottimo 6773)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{Costo} & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s)\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{7198} & 2,665 & 7284 & 2,226 & 7280 & 2,828 & 7230 & 2,307\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{7077} & 33,559 & 7208 & 6,366 & 7193 & 7,738 & 7203 & 4,532\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{7077} & 1800 & 7192 & 8,302 & 7166 & 9,767 & 7201 & 13,739\tabularnewline
            \hline 
            &  & 7186 & 10,762 & 7161 & 26,771 & 7149 & 15,732\tabularnewline
            \cline{3-8} 
            &  & 7164 & 12,977 & 7141 & 46,01 & 7141 & 47,113\tabularnewline
            \cline{3-8} 
            &  & 7153 & 18,606 & 7100 & 74,421 & 7118 & 356,143\tabularnewline
            \cline{3-8} 
            &  & 7152 & 26,139 & 7081 & 293,085 & 7060 & 613,947\tabularnewline
            \cline{3-8} 
            &  & 7122 & 83,84 & 7079 & 860,752 & 7055 & 870,445\tabularnewline
            \cline{3-8} 
            &  & 7084 & 295,355 & 7079 & 1800 & 7055 & 1800\tabularnewline
            \cline{3-8} 
            &  & 7084 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{d657 MULTI START (costo ottimo 48912)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s) & Costo & Tempo(s)\tabularnewline
            \hline 
            53830 & 3,2 & 52927 & 3,7 & 53398 & 3,2 & 52952 & 3,9\tabularnewline
            \hline 
            52167 & 6,4 & 52766 & 6,1 & 53368 & 6,3 & 52463 & 13,1\tabularnewline
            \hline 
            51703 & 12,8 & 52504 & 13,5 & 51720 & 10,5 & 51797 & 21,5\tabularnewline
            \hline 
            51680 & 27,4 & 52179 & 20,4 & 51550 & 58,2 & 51246 & 54,7\tabularnewline
            \hline 
            51561 & 47,3 & 51656 & 56,0 & 51512 & 317,0 & 50974 & 1030,6\tabularnewline
            \hline 
            51509 & 236,7 & 51430 & 85,7 & 51419 & 635,9 & 50974 & 1800,0\tabularnewline
            \hline 
            51406 & 329,1 & 51362 & 752,1 & 51230 & 895,8 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            51187 & 679,9 & 51109 & 941,9 & 51230 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            51032 & 861,0 & 51109 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-4} 
            51032 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{u724 MULTI START (costo ottimo 41910)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            45295 & 6,1 & 45000 & 6,9 & 45065 & 6,4 & 44836 & 6,5\tabularnewline
            \hline 
            44761 & 10,6 & 44795 & 11,9 & 44891 & 17,9 & 44189 & 17,4\tabularnewline
            \hline 
            44535 & 19,3 & 44530 & 28,7 & 44528 & 22,9 & 44182 & 84,6\tabularnewline
            \hline 
            44079 & 48,2 & 44163 & 41,4 & 44460 & 149,9 & 44161 & 259,9\tabularnewline
            \hline 
            43864 & 1290,6 & 44151 & 72,2 & 44451 & 244,1 & 44054 & 386,8\tabularnewline
            \hline 
            43864 & 1800,0 & 44136 & 372,2 & 44439 & 337,9 & 43749 & 990,8\tabularnewline
            \hline 
            \multicolumn{1}{c}{} &  & 43979 & 603,3 & 43977 & 371,0 & 43711 & 1135,6\tabularnewline
            \cline{3-8} 
            \multicolumn{1}{c}{} &  & 43856 & 760,0 & 43971 & 1245,1 & 43711 & 1800,0\tabularnewline
            \cline{3-8} 
            \multicolumn{1}{c}{} &  & 43852 & 1420,2 & 43953 & 1303,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 43852 & 1800,0 & 43915 & 1380,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 43915 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{cccc|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{rat783 MULTI START (costo ottimo 8806)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)} & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{9485} & \multicolumn{1}{c|}{6,2} & \multicolumn{1}{c|}{9460} & 7,6 & 9356 & 4,9 & 9401 & 5,0\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{9315} & \multicolumn{1}{c|}{11,2} & \multicolumn{1}{c|}{9317} & 19,9 & 9314 & 8,6 & 9399 & 31,7\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{9284} & \multicolumn{1}{c|}{434,1} & \multicolumn{1}{c|}{9265} & 395,6 & 9310 & 128,0 & 9376 & 88,8\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{9284} & \multicolumn{1}{c|}{1800,0} & \multicolumn{1}{c|}{9265} & 1800,0 & 9284 & 323,8 & 9369 & 127,7\tabularnewline
            \hline 
            &  &  &  & 9264 & 1071,2 & 9368 & 136,2\tabularnewline
            \cline{5-8} 
            &  &  &  & 9264 & 1800,0 & 9358 & 175,5\tabularnewline
            \cline{5-8} 
            &  &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9320 & 262,4\tabularnewline
            \cline{7-8} 
            &  &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9312 & 377,0\tabularnewline
            \cline{7-8} 
            &  &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9304 & 559,9\tabularnewline
            \cline{7-8} 
            &  &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9264 & 785,0\tabularnewline
            \cline{7-8} 
            &  &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9242 & 1207,1\tabularnewline
            \cline{7-8} 
            &  &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9242 & 1800,0\tabularnewline
            \cline{7-8} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{cc|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{dsj1000 MULTI START (costo ottimo 18659688 )}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{Costo} & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{20068535} & 19,4 & 20270696 & 13,6 & 20334609 & 14,3 & 19965496 & 21,9\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{19852900} & 239,8 & 20138131 & 26,8 & 19978177 & 34,8 & 19960654 & 66,8\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{19828957} & 279,7 & 19865783 & 79,5 & 19975814 & 213,2 & 19914229 & 165,1\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{19828957} & 1800,0 & 19852720 & 1579,5 & 19946138 & 469,5 & 19818264 & 306,9\tabularnewline
            \hline 
            &  & 19741229 & 1720,5 & 19930787 & 607,3 & 19750658 & 838,6\tabularnewline
            \cline{3-8} 
            &  & 19741229 & 1800,0 & 19841513 & 718,0 & 19750658 & 1800,0\tabularnewline
            \cline{3-8} 
            & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 19802820 & 1729,8 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 19802820 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\subsubsection*{TABU SEARCH}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|cc|c|c|cccc|}
            \hline 
            \multicolumn{8}{|c|}{lin318 TABU SEARCH (costo ottimo 42029)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline
            \multicolumn{1}{|c|}{42935} & 0 & 43231 & 0 & \multicolumn{1}{c|}{43020} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{43094} & 0\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{42935} & 1800 & 43221 & 1240,856 & \multicolumn{1}{c|}{43020} & \multicolumn{1}{c|}{1800} & \multicolumn{1}{c|}{43094} & 1800\tabularnewline
            \hline 
            \multicolumn{1}{c}{} &  & 43194 & 1241,153 &  &  &  & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 43175 & 1241,67 &  &  &  & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 43156 & 1241,962 &  &  &  & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 43156 & 1800 &  &  &  & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-4} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|cccc}
            \hline 
            \multicolumn{8}{|c|}{pr439 TABU SEARCH (costo ottimo 107217)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            109335 & 0,0 & 109220 & 0,0 & \multicolumn{1}{c|}{109508} & \multicolumn{1}{c|}{0,0} & \multicolumn{1}{c|}{109240} & \multicolumn{1}{c|}{0,0}\tabularnewline
            \hline 
            109300 & 2,2 & 109158 & 1,2 & \multicolumn{1}{c|}{109499} & \multicolumn{1}{c|}{2,7} & \multicolumn{1}{c|}{109086} & \multicolumn{1}{c|}{4,1}\tabularnewline
            \hline 
            109245 & 3,7 & 108910 & 2,5 & \multicolumn{1}{c|}{109302} & \multicolumn{1}{c|}{4,2} & \multicolumn{1}{c|}{108967} & \multicolumn{1}{c|}{7,3}\tabularnewline
            \hline 
            109242 & 4,0 & 108906 & 252,5 & \multicolumn{1}{c|}{109070} & \multicolumn{1}{c|}{5,0} & \multicolumn{1}{c|}{108955} & \multicolumn{1}{c|}{7,8}\tabularnewline
            \hline 
            109188 & 4,4 & 108904 & 253,1 & \multicolumn{1}{c|}{109070} & \multicolumn{1}{c|}{1800,0} & \multicolumn{1}{c|}{108887} & \multicolumn{1}{c|}{8,3}\tabularnewline
            \hline 
            109185 & 293,8 & 108896 & 254,4 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{108862} & \multicolumn{1}{c|}{1016,3}\tabularnewline
            \cline{1-4} \cline{7-8} 
            109175 & 294,7 & 108890 & 255,0 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{108862} & \multicolumn{1}{c|}{1800,0}\tabularnewline
            \cline{1-4} \cline{7-8} 
            109173 & 295,6 & 108791 & 256,2 &  &  &  & \tabularnewline
            \cline{1-4} 
            109135 & 297,3 & 108766 & 256,8 &  &  &  & \tabularnewline
            \cline{1-4} 
            109110 & 298,1 & 108745 & 257,4 &  &  &  & \tabularnewline
            \cline{1-4} 
            109097 & 299,0 & 108742 & 257,9 &  &  &  & \tabularnewline
            \cline{1-4} 
            109051 & 300,6 & 108720 & 312,3 &  &  &  & \tabularnewline
            \cline{1-4} 
            109018 & 301,4 & 108715 & 312,8 &  &  &  & \tabularnewline
            \cline{1-4} 
            109001 & 302,9 & 108713 & 313,5 &  &  &  & \tabularnewline
            \cline{1-4} 
            108981 & 303,7 & 108654 & 353,6 &  &  &  & \tabularnewline
            \cline{1-4} 
            108977 & 304,4 & 108582 & 354,2 &  &  &  & \tabularnewline
            \cline{1-4} 
            108974 & 305,2 & 108571 & 354,8 &  &  &  & \tabularnewline
            \cline{1-4} 
            108927 & 306,5 & 108569 & 355,4 &  &  &  & \tabularnewline
            \cline{1-4} 
            108888 & 307,2 & 108530 & 356,6 &  &  &  & \tabularnewline
            \cline{1-4} 
            108884 & 307,9 & 108505 & 357,1 &  &  &  & \tabularnewline
            \cline{1-4} 
            108882 & 308,6 & 108480 & 357,7 &  &  &  & \tabularnewline
            \cline{1-4} 
            108837 & 310,5 & 108459 & 358,2 &  &  &  & \tabularnewline
            \cline{1-4} 
            108816 & 311,0 & 108449 & 452,2 &  &  &  & \tabularnewline
            \cline{1-4} 
            108814 & 311,6 & 108438 & 452,8 &  &  &  & \tabularnewline
            \cline{1-4} 
            108762 & 656,2 & 108432 & 453,5 &  &  &  & \tabularnewline
            \cline{1-4} 
            108737 & 656,8 & 108413 & 454,7 &  &  &  & \tabularnewline
            \cline{1-4} 
            108716 & 657,3 & 108392 & 455,2 &  &  &  & \tabularnewline
            \cline{1-4} 
            108696 & 657,9 & 108382 & 455,8 &  &  &  & \tabularnewline
            \cline{1-4} 
            108691 & 658,5 & 108379 & 456,4 &  &  &  & \tabularnewline
            \cline{1-4} 
            108691 & 1800,0 & 108379 & 1800,0 &  &  &  & \tabularnewline
            \cline{1-4} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|cccc}
            \hline 
            \multicolumn{8}{|c|}{d493 TABU SEARCH (costo ottimo 35002)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            36157 & 0,0 & 36026 & 0,0 & \multicolumn{1}{c|}{36021} & \multicolumn{1}{c|}{0,0} & \multicolumn{1}{c|}{36069} & \multicolumn{1}{c|}{0,0}\tabularnewline
            \hline 
            36129 & 0,6 & 35954 & 0,8 & \multicolumn{1}{c|}{36019} & \multicolumn{1}{c|}{2,0} & \multicolumn{1}{c|}{36049} & \multicolumn{1}{c|}{1,0}\tabularnewline
            \hline 
            36128 & 1,5 & 35953 & 1,2 & \multicolumn{1}{c|}{36003} & \multicolumn{1}{c|}{2,7} & \multicolumn{1}{c|}{36033} & \multicolumn{1}{c|}{1,7}\tabularnewline
            \hline 
            36120 & 2,7 & 35911 & 3,0 & \multicolumn{1}{c|}{35988} & \multicolumn{1}{c|}{6,5} & \multicolumn{1}{c|}{36021} & \multicolumn{1}{c|}{208,5}\tabularnewline
            \hline 
            36113 & 12,6 & 35904 & 5,5 & \multicolumn{1}{c|}{35987} & \multicolumn{1}{c|}{1409,0} & \multicolumn{1}{c|}{36019} & \multicolumn{1}{c|}{209,2}\tabularnewline
            \hline 
            36091 & 14,7 & 35900 & 8,1 & \multicolumn{1}{c|}{35985} & \multicolumn{1}{c|}{1409,8} & \multicolumn{1}{c|}{36018} & \multicolumn{1}{c|}{401,4}\tabularnewline
            \hline 
            36071 & 17,8 & 35897 & 200,7 & \multicolumn{1}{c|}{35985} & \multicolumn{1}{c|}{1800,0} & \multicolumn{1}{c|}{36016} & \multicolumn{1}{c|}{402,1}\tabularnewline
            \hline 
            36063 & 18,7 & 35894 & 201,4 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{36006} & \multicolumn{1}{c|}{477,1}\tabularnewline
            \cline{1-4} \cline{7-8} 
            36026 & 23,8 & 35891 & 202,3 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{36004} & \multicolumn{1}{c|}{598,8}\tabularnewline
            \cline{1-4} \cline{7-8} 
            36024 & 24,7 & 35890 & 203,1 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{36002} & \multicolumn{1}{c|}{599,6}\tabularnewline
            \cline{1-4} \cline{7-8} 
            36022 & 25,6 & 35885 & 204,5 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{36001} & \multicolumn{1}{c|}{600,3}\tabularnewline
            \cline{1-4} \cline{7-8} 
            36021 & 320,8 & 35882 & 205,2 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35998} & \multicolumn{1}{c|}{666,1}\tabularnewline
            \cline{1-4} \cline{7-8} 
            36009 & 322,6 & 35881 & 256,0 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35996} & \multicolumn{1}{c|}{666,8}\tabularnewline
            \cline{1-4} \cline{7-8} 
            36002 & 324,5 & 35876 & 257,6 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35994} & \multicolumn{1}{c|}{667,6}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35999 & 325,3 & 35873 & 258,4 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35993} & \multicolumn{1}{c|}{862,3}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35998 & 326,2 & 35868 & 259,9 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35986} & \multicolumn{1}{c|}{863,1}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35992 & 327,8 & 35865 & 260,6 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35967} & \multicolumn{1}{c|}{863,8}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35991 & 328,6 & 35862 & 261,4 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35962} & \multicolumn{1}{c|}{864,7}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35983 & 330,1 & 35859 & 262,1 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35959} & \multicolumn{1}{c|}{865,4}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35976 & 330,8 & 35845 & 262,8 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35956} & \multicolumn{1}{c|}{866,2}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35969 & 331,5 & 35842 & 325,6 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35954} & \multicolumn{1}{c|}{867,0}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35966 & 332,2 & 35837 & 327,0 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35953} & \multicolumn{1}{c|}{867,7}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35964 & 1082,4 & 35830 & 327,7 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{35953} & \multicolumn{1}{c|}{1800,0}\tabularnewline
            \cline{1-4} \cline{7-8} 
            35955 & 1468,0 & 35827 & 328,5 &  &  &  & \tabularnewline
            \cline{1-4} 
            35955 & 1800,0 & 35826 & 908,5 &  &  &  & \tabularnewline
            \cline{1-4} 
            \multicolumn{1}{c}{} &  & 35823 & 1016,8 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35820 & 1017,6 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35817 & 1018,4 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35812 & 1021,4 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35810 & 1080,7 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35807 & 1081,3 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35805 & 1082,0 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35803 & 1082,7 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35801 & 1209,3 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35798 & 1210,0 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35795 & 1210,7 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35778 & 1392,0 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35775 & 1392,8 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35772 & 1393,6 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35771 & 1394,4 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35769 & 1395,8 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35766 & 1396,6 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35765 & 1397,3 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35755 & 1588,0 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35746 & 1588,8 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35743 & 1589,5 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35742 & 1590,2 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} &  & 35742 & 1800,0 &  &  &  & \tabularnewline
            \cline{3-4} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  &  & \tabularnewline
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|cccccc}
            \hline 
            \multicolumn{8}{|c|}{rat575 TABU SEARCH (costo ottimo 6773)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            7077 & 0,0 & \multicolumn{1}{c|}{7084} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{7079} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{7055} & \multicolumn{1}{c|}{0}\tabularnewline
            \hline 
            7075 & 0,8 & \multicolumn{1}{c|}{7084} & \multicolumn{1}{c|}{1800} & \multicolumn{1}{c|}{7078} & \multicolumn{1}{c|}{455,9} & \multicolumn{1}{c|}{7049} & \multicolumn{1}{c|}{0,8}\tabularnewline
            \hline 
            7062 & 2,1 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7077} & \multicolumn{1}{c|}{546,6} & \multicolumn{1}{c|}{7034} & \multicolumn{1}{c|}{1,2}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7055 & 3,2 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7075} & \multicolumn{1}{c|}{547,7} & \multicolumn{1}{c|}{7033} & \multicolumn{1}{c|}{4,6}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7046 & 5,2 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7074} & \multicolumn{1}{c|}{548,9} & \multicolumn{1}{c|}{7032} & \multicolumn{1}{c|}{5,2}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7045 & 729,4 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7073} & \multicolumn{1}{c|}{647,4} & \multicolumn{1}{c|}{7021} & \multicolumn{1}{c|}{7,0}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7043 & 730,5 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7072} & \multicolumn{1}{c|}{648,4} & \multicolumn{1}{c|}{7019} & \multicolumn{1}{c|}{9,0}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7042 & 731,6 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7071} & \multicolumn{1}{c|}{1369,5} & \multicolumn{1}{c|}{7018} & \multicolumn{1}{c|}{561,0}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7040 & 733,6 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7070} & \multicolumn{1}{c|}{1370,5} & \multicolumn{1}{c|}{7014} & \multicolumn{1}{c|}{562,3}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7038 & 734,5 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7069} & \multicolumn{1}{c|}{1372,5} & \multicolumn{1}{c|}{7013} & \multicolumn{1}{c|}{563,5}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7036 & 735,5 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7067} & \multicolumn{1}{c|}{1373,4} & \multicolumn{1}{c|}{7012} & \multicolumn{1}{c|}{565,8}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7034 & 736,5 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7066} & \multicolumn{1}{c|}{1374,4} & \multicolumn{1}{c|}{7010} & \multicolumn{1}{c|}{566,9}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7033 & 737,4 &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7066} & \multicolumn{1}{c|}{1800} & \multicolumn{1}{c|}{7009} & \multicolumn{1}{c|}{568,0}\tabularnewline
            \cline{1-2} \cline{5-8} 
            7032 & 917,4 &  &  &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7008} & \multicolumn{1}{c|}{569,1}\tabularnewline
            \cline{1-2} \cline{7-8} 
            7031 & 918,5 &  &  &  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{7008} & \multicolumn{1}{c|}{1800}\tabularnewline
            \cline{1-2} \cline{7-8} 
            7030 & 920,4 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7028 & 921,3 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7027 & 922,3 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7026 & 923,4 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7025 & 1006,1 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7023 & 1007,2 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7022 & 1008,3 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7021 & 1187,9 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7020 & 1188,9 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7019 & 1189,9 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7018 & 1364,6 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7017 & 1365,5 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7016 & 1366,5 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7013 & 1537,6 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7012 & 1538,9 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7011 & 1541,5 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7010 & 1542,7 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7006 & 1545,0 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7004 & 1546,0 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7003 & 1547,1 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7002 & 1548,2 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            7001 & 1550,3 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            6999 & 1551,2 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            6997 & 1552,2 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            6996 & 1553,1 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            6995 & 1554,0 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            6992 & 1555,0 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
            6992 & 1800,0 &  &  &  &  &  & \tabularnewline
            \cline{1-2} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|cc|c|c|cc}
            \hline 
            \multicolumn{8}{|c|}{d657 TABU SEARCH (costo ottimo 48912)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            51032 & 0,0 & \multicolumn{1}{c|}{51109} & 0,0 & 51230 & 0,0 & \multicolumn{1}{c|}{50974} & \multicolumn{1}{c|}{0}\tabularnewline
            \hline 
            51020 & 2,3 & \multicolumn{1}{c|}{51097} & 2,3 & 51221 & 2,2 & \multicolumn{1}{c|}{50974} & \multicolumn{1}{c|}{1800}\tabularnewline
            \hline 
            50953 & 12,5 & \multicolumn{1}{c|}{51095} & 7,2 & 51210 & 5,6 &  & \tabularnewline
            \cline{1-6} 
            50945 & 16,7 & \multicolumn{1}{c|}{51092} & 8,8 & 51159 & 7,1 &  & \tabularnewline
            \cline{1-6} 
            50927 & 34,0 & \multicolumn{1}{c|}{51065} & 10,5 & 51150 & 9,4 &  & \tabularnewline
            \cline{1-6} 
            50915 & 39,8 & \multicolumn{1}{c|}{51046} & 11,4 & 51142 & 19,1 &  & \tabularnewline
            \cline{1-6} 
            50904 & 41,3 & \multicolumn{1}{c|}{50999} & 15,9 & 51135 & 112,9 &  & \tabularnewline
            \cline{1-6} 
            50889 & 102,8 & \multicolumn{1}{c|}{50995} & 17,8 & 51124 & 114,5 &  & \tabularnewline
            \cline{1-6} 
            50882 & 107,0 & \multicolumn{1}{c|}{50990} & 22,9 & 51116 & 116,1 &  & \tabularnewline
            \cline{1-6} 
            50879 & 109,0 & \multicolumn{1}{c|}{50990} & 1800,0 & 51111 & 117,6 &  & \tabularnewline
            \cline{1-6} 
            50876 & 112,9 &  &  & 51105 & 120,7 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50872 & 114,7 &  &  & 51099 & 122,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50870 & 116,7 &  &  & 51095 & 123,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50869 & 118,6 &  &  & 51054 & 126,2 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50868 & 120,5 &  &  & 51048 & 127,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50864 & 124,2 &  &  & 51045 & 128,9 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50860 & 125,9 &  &  & 51044 & 576,2 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50859 & 127,7 &  &  & 51037 & 676,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50794 & 130,9 &  &  & 51035 & 678,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50786 & 132,5 &  &  & 51030 & 679,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50778 & 134,0 &  &  & 51029 & 681,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50772 & 135,7 &  &  & 51028 & 682,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50769 & 137,4 &  &  & 51024 & 685,4 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50761 & 141,6 &  &  & 51020 & 686,8 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50750 & 142,8 &  &  & 51017 & 688,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50741 & 144,1 &  &  & 51015 & 689,4 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50734 & 145,3 &  &  & 51014 & 690,8 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50728 & 251,8 &  &  & 51007 & 693,4 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50726 & 253,1 &  &  & 51001 & 694,5 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50725 & 254,3 &  &  & 50995 & 695,8 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50716 & 356,6 &  &  & 50990 & 697,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50702 & 358,2 &  &  & 50986 & 698,3 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50701 & 359,8 &  &  & 50986 & 1800,0 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            50700 & 361,3 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50696 & 364,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50690 & 365,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50686 & 366,9 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50674 & 369,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50666 & 370,8 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50663 & 371,9 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50659 & 814,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50657 & 815,6 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50651 & 818,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50648 & 819,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50645 & 1152,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50641 & 1153,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50639 & 1154,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50634 & 1155,7 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50626 & 1157,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50619 & 1272,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50616 & 1273,3 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            50616 & 1800,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{u724 TABU SEARCH (costo ottimo 41910)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            43864 & 0 & 43915 & 0 & 43852 & 0 & 43711 & 0\tabularnewline
            \hline 
            43845 & 1,1 & 43910 & 10,2 & 43833 & 1,2 & 43692 & 1,3\tabularnewline
            \hline 
            43842 & 4,2 & 43868 & 12,4 & 43824 & 37,6 & 43680 & 7,8\tabularnewline
            \hline 
            43779 & 13,9 & 43867 & 274,9 & 43819 & 1458,8 & 43677 & 163,1\tabularnewline
            \hline 
            43745 & 15,1 & 43861 & 277,0 & 43818 & 1461,0 & 43670 & 296,0\tabularnewline
            \hline 
            43732 & 22,5 & 43860 & 279,1 & 43811 & 1465,2 & 43661 & 297,8\tabularnewline
            \hline 
            43723 & 138,5 & 43836 & 283,1 & 43803 & 1467,5 & 43659 & 299,6\tabularnewline
            \hline 
            43715 & 140,2 & 43819 & 285,0 & 43796 & 1469,6 & 43657 & 303,0\tabularnewline
            \hline 
            43711 & 141,9 & 43815 & 286,9 & 43794 & 1471,8 & 43653 & 304,6\tabularnewline
            \hline 
            43708 & 145,3 & 43813 & 288,8 & 43793 & 1473,8 & 43650 & 306,2\tabularnewline
            \hline 
            43707 & 277,7 & 43812 & 290,6 & 43789 & 1475,9 & 43649 & 307,7\tabularnewline
            \hline 
            43703 & 279,3 & 43804 & 294,2 & 43783 & 1479,9 & 43648 & 309,2\tabularnewline
            \hline 
            43700 & 281,0 & 43797 & 295,9 & 43778 & 1481,8 & 43647 & 584,7\tabularnewline
            \hline 
            43698 & 282,7 & 43795 & 297,6 & 43774 & 1483,7 & 43643 & 586,2\tabularnewline
            \hline 
            43696 & 284,3 & 43793 & 299,2 & 43768 & 1485,6 & 43639 & 587,8\tabularnewline
            \hline 
            43694 & 287,5 & 43786 & 305,5 & 43765 & 1487,4 & 43635 & 589,3\tabularnewline
            \hline 
            43691 & 289,1 & 43786 & 1800 & 43763 & 1489,2 & 43632 & 591,0\tabularnewline
            \hline 
            43682 & 413,5 & \multicolumn{1}{c}{} &  & 43761 & 1491,2 & 43632 & 1800\tabularnewline
            \cline{1-2} \cline{5-8} 
            43668 & 415,0 & \multicolumn{1}{c}{} &  & 43760 & 1494,8 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            43664 & 416,7 & \multicolumn{1}{c}{} &  & 43759 & 1496,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            43661 & 418,4 & \multicolumn{1}{c}{} &  & 43752 & 1499,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            43661 & 1800 & \multicolumn{1}{c}{} &  & 43748 & 1501,1 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 43745 & 1502,7 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 43740 & 1504,1 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 43740 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{rat783 TABU SEARCH (costo ottimo 8806)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            9284 & 0 & 9264 & 0 & 9265 & 0 & 9242 & 0\tabularnewline
            \hline 
            9283 & 59,138 & 9263 & 1,598 & 9257 & 1,352 & 9234 & 10,865\tabularnewline
            \hline 
            9280 & 66,021 & 9244 & 36,956 & 9256 & 4,652 & 9227 & 12,11\tabularnewline
            \hline 
            9278 & 73,23 & 9243 & 46,365 & 9255 & 312,909 & 9226 & 319,17\tabularnewline
            \hline 
            9277 & 80,592 & 9237 & 75,046 & 9254 & 315,584 & 9225 & 324,048\tabularnewline
            \hline 
            9276 & 187,071 & 9236 & 77,554 & 9249 & 318,202 & 9223 & 326,39\tabularnewline
            \hline 
            9274 & 188,977 & 9234 & 180,455 & 9248 & 323,082 & 9222 & 328,707\tabularnewline
            \hline 
            9273 & 190,821 & 9233 & 182,178 & 9246 & 325,655 & 9220 & 333,319\tabularnewline
            \hline 
            9267 & 336,05 & 9232 & 817,879 & 9245 & 328,17 & 9218 & 335,499\tabularnewline
            \hline 
            9266 & 337,778 & 9230 & 961,186 & 9244 & 330,618 & 9217 & 337,708\tabularnewline
            \hline 
            9265 & 339,488 & 9226 & 963,541 & 9242 & 335,162 & 9216 & 339,933\tabularnewline
            \hline 
            9264 & 341,182 & 9223 & 965,863 & 9241 & 337,401 & 9215 & 342,214\tabularnewline
            \hline 
            9263 & 342,961 & 9221 & 968,187 & 9240 & 339,715 & 9214 & 346,54\tabularnewline
            \hline 
            9262 & 807,17 & 9220 & 972,935 & 9239 & 341,989 & 9213 & 348,609\tabularnewline
            \hline 
            9261 & 809,36 & 9219 & 975,038 & 9238 & 348,087 & 9212 & 350,655\tabularnewline
            \hline 
            9260 & 811,598 & 9218 & 977,245 & 9237 & 350,126 & 9211 & 352,693\tabularnewline
            \hline 
            9259 & 813,923 & 9208 & 981,403 & 9236 & 352,109 & 9210 & 354,751\tabularnewline
            \hline 
            9258 & 818,163 & 9207 & 983,363 & 9235 & 355,929 & 9209 & 360,401\tabularnewline
            \hline 
            9257 & 820,26 & 9206 & 985,374 & 9234 & 357,908 & 9208 & 362,363\tabularnewline
            \hline 
            9256 & 822,233 & 9205 & 987,334 & 9233 & 359,712 & 9208 & 1800\tabularnewline
            \hline 
            9245 & 826,103 & 9204 & 991,107 & 9232 & 361,496 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9244 & 827,873 & 9203 & 993,077 & 9231 & 363,321 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9243 & 829,747 & 9202 & 994,903 & 9230 & 365,161 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9242 & 831,591 & 9201 & 996,771 & 9229 & 530,5 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9241 & 833,401 & 9199 & 1122,157 & 9228 & 532,25 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9240 & 835,158 & 9196 & 1124,374 & 9227 & 677,756 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9239 & 836,958 & 9195 & 1126,53 & 9226 & 679,984 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            9239 & 1800 & 9194 & 1128,633 & 9225 & 682,174 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            \multicolumn{1}{c}{} &  & 9192 & 1132,679 & 9223 & 686,373 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9191 & 1134,628 & 9221 & 688,342 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9190 & 1136,655 & 9220 & 690,422 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9189 & 1142,332 & 9219 & 692,373 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9188 & 1144,31 & 9218 & 694,368 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9187 & 1146,111 & 9217 & 698,042 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9186 & 1147,922 & 9216 & 699,793 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} &  & 9186 & 1800 & 9215 & 701,541 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{3-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9214 & 703,321 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 9214 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{
        \begin{tabular}{|c|c|cc|c|c|cc}
            \hline 
            \multicolumn{8}{|c|}{dsj1000 TABU SEARCH (costo ottimo 18659688)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)}\tabularnewline
            \hline 
            19828957 & 0,0 & \multicolumn{1}{c|}{19802820} & 0,0 & 19741229 & 0,0 & \multicolumn{1}{c|}{19750658} & \multicolumn{1}{c|}{0,0}\tabularnewline
            \hline 
            19815585 & 10,0 & \multicolumn{1}{c|}{19799454} & 3,8 & 19737657 & 3,7 & \multicolumn{1}{c|}{19747109} & \multicolumn{1}{c|}{5,2}\tabularnewline
            \hline 
            19815108 & 28,3 & \multicolumn{1}{c|}{19792630} & 11,3 & 19734229 & 44,4 & \multicolumn{1}{c|}{19744713} & \multicolumn{1}{c|}{14,8}\tabularnewline
            \hline 
            19814543 & 37,8 & \multicolumn{1}{c|}{19784187} & 29,1 & 19721723 & 47,1 & \multicolumn{1}{c|}{19741026} & \multicolumn{1}{c|}{31,7}\tabularnewline
            \hline 
            19806185 & 45,7 & \multicolumn{1}{c|}{19781812} & 33,8 & 19721431 & 117,4 & \multicolumn{1}{c|}{19731537} & \multicolumn{1}{c|}{65,7}\tabularnewline
            \hline 
            19802768 & 57,2 & \multicolumn{1}{c|}{19779585} & 52,1 & 19717868 & 121,6 & \multicolumn{1}{c|}{19726726} & \multicolumn{1}{c|}{69,1}\tabularnewline
            \hline 
            19793270 & 60,2 & \multicolumn{1}{c|}{19779059} & 517,1 & 19716480 & 543,5 & \multicolumn{1}{c|}{19723170} & \multicolumn{1}{c|}{72,5}\tabularnewline
            \hline 
            19763782 & 204,9 & \multicolumn{1}{c|}{19777739} & 521,6 & 19714929 & 547,6 & \multicolumn{1}{c|}{19703317} & \multicolumn{1}{c|}{82,7}\tabularnewline
            \hline 
            19735109 & 209,9 & \multicolumn{1}{c|}{19775888} & 530,1 & 19714904 & 551,7 & \multicolumn{1}{c|}{19703270} & \multicolumn{1}{c|}{86,1}\tabularnewline
            \hline 
            19731456 & 215,0 & \multicolumn{1}{c|}{19774017} & 534,2 & 19713214 & 559,4 & \multicolumn{1}{c|}{19700268} & \multicolumn{1}{c|}{100,9}\tabularnewline
            \hline 
            19731152 & 224,7 & \multicolumn{1}{c|}{19772302} & 538,3 & 19711789 & 563,2 & \multicolumn{1}{c|}{19700268} & \multicolumn{1}{c|}{1800,0}\tabularnewline
            \hline 
            19730940 & 229,5 & \multicolumn{1}{c|}{19771185} & 542,4 & 19711668 & 566,9 &  & \tabularnewline
            \cline{1-6} 
            19730819 & 234,2 & \multicolumn{1}{c|}{19769005} & 546,5 & 19711574 & 570,4 &  & \tabularnewline
            \cline{1-6} 
            19730725 & 238,9 & \multicolumn{1}{c|}{19768426} & 550,5 & 19710059 & 577,4 &  & \tabularnewline
            \cline{1-6} 
            19730702 & 243,7 & \multicolumn{1}{c|}{19766651} & 554,6 & 19709646 & 580,8 &  & \tabularnewline
            \cline{1-6} 
            19730312 & 252,8 & \multicolumn{1}{c|}{19766604} & 558,6 & 19709256 & 584,2 &  & \tabularnewline
            \cline{1-6} 
            19729922 & 257,1 & \multicolumn{1}{c|}{19764803} & 566,3 & 19708959 & 587,7 &  & \tabularnewline
            \cline{1-6} 
            19729558 & 265,7 & \multicolumn{1}{c|}{19763166} & 570,1 & 19708912 & 591,2 &  & \tabularnewline
            \cline{1-6} 
            19729161 & 269,7 & \multicolumn{1}{c|}{19762155} & 574,0 & 19708322 & 597,8 &  & \tabularnewline
            \cline{1-6} 
            19728767 & 273,9 & \multicolumn{1}{c|}{19761116} & 577,6 & 19707759 & 601,0 &  & \tabularnewline
            \cline{1-6} 
            19728650 & 277,9 & \multicolumn{1}{c|}{19760999} & 581,2 & 19707258 & 604,2 &  & \tabularnewline
            \cline{1-6} 
            19728023 & 285,7 & \multicolumn{1}{c|}{19760914} & 584,8 & 19706871 & 607,4 &  & \tabularnewline
            \cline{1-6} 
            19727374 & 289,5 & \multicolumn{1}{c|}{19759230} & 591,8 & 19650420 & 924,4 &  & \tabularnewline
            \cline{1-6} 
            19726873 & 293,2 & \multicolumn{1}{c|}{19758836} & 595,2 & 19649525 & 1107,9 &  & \tabularnewline
            \cline{1-6} 
            19726194 & 300,5 & \multicolumn{1}{c|}{19758499} & 598,6 & 19648888 & 1112,5 &  & \tabularnewline
            \cline{1-6} 
            19725501 & 303,8 & \multicolumn{1}{c|}{19758269} & 601,9 & 19647427 & 1121,0 &  & \tabularnewline
            \cline{1-6} 
            19725050 & 307,2 & \multicolumn{1}{c|}{19758172} & 605,3 & 19645696 & 1125,2 &  & \tabularnewline
            \cline{1-6} 
            19724943 & 310,6 & \multicolumn{1}{c|}{19757525} & 611,7 & 19644087 & 1129,4 &  & \tabularnewline
            \cline{1-6} 
            19724021 & 314,0 & \multicolumn{1}{c|}{19756962} & 614,6 & 19642735 & 1133,5 &  & \tabularnewline
            \cline{1-6} 
            19723280 & 320,3 & \multicolumn{1}{c|}{19756504} & 617,5 & 19642341 & 1137,6 &  & \tabularnewline
            \cline{1-6} 
            19722482 & 323,4 & \multicolumn{1}{c|}{19756107} & 620,5 & 19641226 & 1145,5 &  & \tabularnewline
            \cline{1-6} 
            19721767 & 326,4 & \multicolumn{1}{c|}{19755810} & 623,5 & 19640768 & 1149,4 &  & \tabularnewline
            \cline{1-6} 
            19720766 & 329,6 & \multicolumn{1}{c|}{19755465} & 1165,3 & 19640647 & 1153,3 &  & \tabularnewline
            \cline{1-6} 
            19720177 & 332,8 & \multicolumn{1}{c|}{19754597} & 1168,3 & 19640553 & 1157,3 &  & \tabularnewline
            \cline{1-6} 
            19717160 & 464,4 & \multicolumn{1}{c|}{19754261} & 1171,4 & 19638988 & 1164,6 &  & \tabularnewline
            \cline{1-6} 
            19716116 & 469,6 & \multicolumn{1}{c|}{19754261} & 1800,0 & 19638598 & 1168,0 &  & \tabularnewline
            \cline{1-6} 
            19711421 & 474,7 &  &  & 19638301 & 1171,4 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19711406 & 480,0 &  &  & 19638103 & 1174,9 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19710425 & 516,8 &  &  & 19637628 & 1181,5 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19709515 & 521,8 &  &  & 19637065 & 1184,5 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19708784 & 526,9 &  &  & 19636652 & 1187,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19708328 & 536,9 &  &  & 19636409 & 1190,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19707525 & 541,7 &  &  & 19636292 & 1193,6 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19706950 & 551,1 &  &  & 19636035 & 1712,2 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19705597 & 555,8 &  &  & 19635837 & 1715,8 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19704368 & 560,3 &  &  & 19635743 & 1719,4 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19703208 & 565,0 &  &  & 19634106 & 1726,5 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19702524 & 573,5 &  &  & 19633693 & 1730,0 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19701524 & 577,6 &  &  & 19633306 & 1733,5 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19701501 & 581,7 &  &  & 19633063 & 1736,8 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19700099 & 589,5 &  &  & 19632624 & 1743,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19698904 & 593,3 &  &  & 19632023 & 1746,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19698140 & 597,1 &  &  & 19631565 & 1749,1 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19697790 & 601,0 &  &  & 19631268 & 1752,2 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19697669 & 604,7 &  &  & 19631243 & 1755,2 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19696418 & 612,0 &  &  & 19631243 & 1800,0 &  & \tabularnewline
            \cline{1-2} \cline{5-6} 
            19695967 & 615,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19695577 & 619,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19695460 & 622,4 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19692004 & 628,9 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19691367 & 631,9 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19690909 & 634,9 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19690515 & 637,9 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19689161 & 739,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19675235 & 744,3 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19674849 & 855,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19674407 & 859,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19672795 & 866,7 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19671244 & 870,6 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19669888 & 874,4 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19669767 & 878,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19669430 & 885,3 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19669033 & 888,7 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19668639 & 892,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19668289 & 895,6 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19668266 & 899,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19667379 & 905,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19666648 & 908,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19666258 & 911,6 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19665893 & 1151,8 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19665256 & 1155,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19664814 & 1158,7 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19664420 & 1162,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19664070 & 1165,6 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19662153 & 1172,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19661460 & 1175,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19661002 & 1178,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19660612 & 1181,1 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19660400 & 1184,2 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
            19660400 & 1800,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \tabularnewline
            \cline{1-2} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\FloatBarrier

\subsubsection*{GENETICO}

\newcolumntype{C}{>{\centering\arraybackslash}p{11em}}

\FloatBarrier

\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{lin318 GENETICO GEN\#20 (costo ottimo 42029)}\tabularnewline
            \hline 
            \hline 
            Costo & Tempo(s)\tabularnewline
            \hline 
            67669 & 0,1\tabularnewline
            \hline 
            46016 & 0,9\tabularnewline
            \hline 
            45290 & 2,1\tabularnewline
            \hline 
            44701 & 8,7\tabularnewline
            \hline 
            44481 & 18,2\tabularnewline
            \hline 
            44027 & 27,5\tabularnewline
            \hline 
            43660 & 38,3\tabularnewline
            \hline 
            43570 & 65,2\tabularnewline
            \hline 
            43488 & 65,7\tabularnewline
            \hline 
            43457 & 455,4\tabularnewline
            \hline 
            43347 & 457,1\tabularnewline
            \hline 
            43157 & 458,2\tabularnewline
            \hline 
            43120 & 470,4\tabularnewline
            \hline 
            43053 & 476,9\tabularnewline
            \hline 
            43044 & 534,1\tabularnewline
            \hline 
            42960 & 1674,0\tabularnewline
            \hline 
            42960 & 1800\tabularnewline
            \hline 
        \end{tabular}
    \end{adjustbox}
\caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{pr439 GENETICO GEN\#20 (costo ottimo 107217)}\tabularnewline
            \hline 
            \hline 
            178844 & 0,2\tabularnewline
            \hline 
            172081 & 0,2\tabularnewline
            \hline 
            111632 & 5,5\tabularnewline
            \hline 
            111364 & 150,2\tabularnewline
            \hline 
            111301 & 203,1\tabularnewline
            \hline 
            111265 & 207,7\tabularnewline
            \hline 
            111134 & 235,9\tabularnewline
            \hline 
            110839 & 259,0\tabularnewline
            \hline 
            110667 & 309,8\tabularnewline
            \hline 
            110623 & 875,3\tabularnewline
            \hline 
            110508 & 1319,7\tabularnewline
            \hline 
            110508 & 1800\tabularnewline
        \end{tabular}
    \end{adjustbox}
    \caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{d493 GENETICO GEN\#20 (costo ottimo 35002)}\tabularnewline
            \hline 
            \hline 
            Costo & Tempo(s)\tabularnewline
            \hline 
            50521 & 0,3\tabularnewline
            \hline 
            37341 & 5,2\tabularnewline
            \hline 
            37107 & 8,0\tabularnewline
            \hline 
            36996 & 17,9\tabularnewline
            \hline 
            36936 & 32,9\tabularnewline
            \hline 
            36855 & 54,3\tabularnewline
            \hline 
            36810 & 115,7\tabularnewline
            \hline 
            36780 & 116,8\tabularnewline
            \hline 
            36771 & 117,6\tabularnewline
            \hline 
            36751 & 130,3\tabularnewline
            \hline 
            36683 & 527,4\tabularnewline
            \hline 
            36525 & 1176,5\tabularnewline
            \hline 
            36525 & 1800\tabularnewline
            \hline 
        \end{tabular}
    \end{adjustbox}
    \caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{rat575 GENETICO GEN\#20 (costo ottimo 6773)}\tabularnewline
            \hline 
            \hline 
            Costo & Tempo(s)\tabularnewline
            \hline 
            10225 & 0,3\tabularnewline
            \hline 
            9927 & 0,3\tabularnewline
            \hline 
            9858 & 0,3\tabularnewline
            \hline 
            9613 & 0,3\tabularnewline
            \hline 
            7411 & 8,1\tabularnewline
            \hline 
            7332 & 14,6\tabularnewline
            \hline 
            7317 & 112,0\tabularnewline
            \hline 
            7268 & 122,3\tabularnewline
            \hline 
            7263 & 277,5\tabularnewline
            \hline 
            7256 & 278,9\tabularnewline
            \hline 
            7238 & 283,3\tabularnewline
            \hline 
            7228 & 283,9\tabularnewline
            \hline 
            7206 & 338,7\tabularnewline
            \hline 
            7124 & 1175,1\tabularnewline
            \hline 
            7124 & 1800\tabularnewline
            \hline 
        \end{tabular}
    \end{adjustbox}
    \caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{d657 GENETICO GEN\#20 (costo ottimo 48912)}\tabularnewline
            \hline 
            \hline 
            Costo & Tempo(s)\tabularnewline
            \hline 
            67669 & 0,1\tabularnewline
            \hline 
            46016 & 0,9\tabularnewline
            \hline 
            45290 & 2,1\tabularnewline
            \hline 
            44701 & 8,7\tabularnewline
            \hline 
            44481 & 18,2\tabularnewline
            \hline 
            44027 & 27,5\tabularnewline
            \hline 
            43660 & 38,3\tabularnewline
            \hline 
            43570 & 65,2\tabularnewline
            \hline 
            43488 & 65,7\tabularnewline
            \hline 
            43457 & 455,4\tabularnewline
            \hline 
            43347 & 457,1\tabularnewline
            \hline 
            43157 & 458,2\tabularnewline
            \hline 
            43120 & 470,4\tabularnewline
            \hline 
            43053 & 476,9\tabularnewline
            \hline 
            43044 & 534,1\tabularnewline
            \hline 
            42960 & 1674,0\tabularnewline
            \hline 
            42960 & 1800\tabularnewline
            \hline 
        \end{tabular}
    \end{adjustbox}
    \caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{u724 GENETICO GEN\#20 (costo ottimo 41910)}\tabularnewline
            \hline 
            \hline 
            Costo & Tempo(s)\tabularnewline
            \hline 
            64140 & 0,5\tabularnewline
            \hline 
            45937 & 18,8\tabularnewline
            \hline 
            44988 & 58,6\tabularnewline
            \hline 
            44351 & 116,3\tabularnewline
            \hline 
            44279 & 1114,6\tabularnewline
            \hline 
            44279 & 1800,0\tabularnewline
            \hline 
        \end{tabular}
    \end{adjustbox}
    \caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}



\begin{table}
    \begin{adjustbox}{center}
        \begin{tabular}{|C|C|}
            \hline 
            \multicolumn{2}{|c|}{rat783 GENETICO GEN\#20 (costo ottimo 8806)}\tabularnewline
            \hline 
            \hline 
            13519 & 0,4\tabularnewline
            \hline 
            13180 & 0,5\tabularnewline
            \hline 
            9672 & 12,9\tabularnewline
            \hline 
            9562 & 30,1\tabularnewline
            \hline 
            9552 & 57,6\tabularnewline
            \hline 
            9536 & 76,5\tabularnewline
            \hline 
            9516 & 79,8\tabularnewline
            \hline 
            9485 & 89,2\tabularnewline
            \hline 
            9482 & 101,4\tabularnewline
            \hline 
            9426 & 125,2\tabularnewline
            \hline 
            9403 & 656,9\tabularnewline
            \hline 
            9386 & 800,9\tabularnewline
            \hline 
            9380 & 806,2\tabularnewline
            \hline 
            9380 & 1800\tabularnewline
            \hline 
        \end{tabular}
    \end{adjustbox}
    \caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\begin{table}
\begin{adjustbox}{center}
    \begin{tabular}{|C|C|}
        \hline 
        \multicolumn{2}{|c|}{dsj1000 GENETICO GEN\#20 (costo ottimo 18659688)}\tabularnewline
        \hline 
        \hline 
        28530708 & 0,7\tabularnewline
        \hline 
        28339022 & 0,9\tabularnewline
        \hline 
        27940942 & 1,5\tabularnewline
        \hline 
        27704229 & 1,7\tabularnewline
        \hline 
        20180860 & 55,9\tabularnewline
        \hline 
        19914677 & 113,8\tabularnewline
        \hline 
        19899518 & 215,1\tabularnewline
        \hline 
        19886374 & 950,6\tabularnewline
        \hline 
        19885127 & 1241,2\tabularnewline
        \hline 
        19885127 & 1800,0\tabularnewline
        \hline 
    \end{tabular}
\end{adjustbox}
\caption{Tabella risultati instanze con numero di nodi inferiore a \textbf{$200$} $+$ algoritmi esatti}
\end{table}

\FloatBarrier

\subsubsection*{VNS}

\FloatBarrier

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{lin318 VNS (costo ottimo 42029)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            44328 & 0,0 & 45631 & 0,0 & 45189 & 0,0 & 44805 & 0,0\tabularnewline
            \hline 
            44293 & 0,1 & 44369 & 0,2 & 44674 & 0,2 & 44459 & 1,7\tabularnewline
            \hline 
            44242 & 0,1 & 44163 & 0,3 & 44375 & 0,5 & 44411 & 1,9\tabularnewline
            \hline 
            44128 & 3,0 & 43344 & 0,7 & 44365 & 3,1 & 44251 & 2,1\tabularnewline
            \hline 
            43691 & 3,3 & 43320 & 286,4 & 43945 & 7,2 & 44128 & 2,7\tabularnewline
            \hline 
            43675 & 3,4 & 43310 & 637,1 & 43901 & 7,3 & 44034 & 2,9\tabularnewline
            \hline 
            43639 & 4,8 & 43233 & 637,2 & 43807 & 7,7 & 43968 & 3,0\tabularnewline
            \hline 
            43591 & 6,1 & 43146 & 914,6 & 43685 & 27,2 & 43655 & 3,1\tabularnewline
            \hline 
            43583 & 25,0 & 43142 & 914,6 & 43574 & 27,3 & 43579 & 3,2\tabularnewline
            \hline 
            43369 & 25,0 & 43142 & 1800 & 43447 & 81,3 & 43578 & 38,1\tabularnewline
            \hline 
            43282 & 95,7 & \multicolumn{1}{c}{} &  & 43392 & 81,7 & 43524 & 61,8\tabularnewline
            \cline{1-2} \cline{5-8} 
            43280 & 937,2 & \multicolumn{1}{c}{} &  & 43374 & 124,6 & 43316 & 289,0\tabularnewline
            \cline{1-2} \cline{5-8} 
            43163 & 955,1 & \multicolumn{1}{c}{} &  & 43230 & 137,8 & 43211 & 790,5\tabularnewline
            \cline{1-2} \cline{5-8} 
            43052 & 1483,7 & \multicolumn{1}{c}{} &  & 43168 & 771,2 & 42984 & 1560,1\tabularnewline
            \cline{1-2} \cline{5-8} 
            43052 & 1800 & \multicolumn{1}{c}{} &  & 43129 & 1385,1 & 42984 & 1800\tabularnewline
            \cline{1-2} \cline{5-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 43129 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{pr439 VNS (costo ottimo 107217)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            115162 & 0,0 & 115118 & 0,0 & 118329 & 0,0 & 116833 & 0,0\tabularnewline
            \hline 
            114445 & 0,1 & 113644 & 0,6 & 117757 & 0,3 & 116375 & 1,9\tabularnewline
            \hline 
            113959 & 0,9 & 113100 & 6,5 & 117749 & 0,5 & 114772 & 2,9\tabularnewline
            \hline 
            113010 & 1,3 & 112843 & 7,2 & 117469 & 2,8 & 114236 & 6,1\tabularnewline
            \hline 
            112977 & 3,1 & 112083 & 37,8 & 116925 & 4,2 & 114226 & 8,2\tabularnewline
            \hline 
            112431 & 8,9 & 111462 & 66,1 & 113697 & 5,2 & 112902 & 11,1\tabularnewline
            \hline 
            112400 & 9,4 & 111095 & 67,5 & 113573 & 5,3 & 112328 & 18,4\tabularnewline
            \hline 
            111864 & 19,0 & 111013 & 67,9 & 113007 & 15,0 & 111610 & 18,8\tabularnewline
            \hline 
            111378 & 19,2 & 110754 & 203,2 & 112911 & 15,5 & 111182 & 79,3\tabularnewline
            \hline 
            111219 & 19,3 & 110613 & 379,3 & 112512 & 17,0 & 110818 & 139,9\tabularnewline
            \hline 
            111153 & 26,1 & 110219 & 490,3 & 110844 & 18,4 & 110367 & 293,0\tabularnewline
            \hline 
            110824 & 26,5 & 109775 & 568,4 & 110598 & 46,9 & 110297 & 391,1\tabularnewline
            \hline 
            110700 & 26,7 & 109764 & 1219,9 & 110580 & 84,4 & 110229 & 976,1\tabularnewline
            \hline 
            109214 & 28,0 & 109167 & 1220,5 & 110249 & 192,0 & 110138 & 976,3\tabularnewline
            \hline 
            108691 & 1343,0 & 109167 & 1800 & 110132 & 368,4 & 109942 & 1468,1\tabularnewline
            \hline 
            108691 & 1800 & \multicolumn{1}{c}{} &  & 109930 & 994,4 & 109942 & 1800\tabularnewline
            \cline{1-2} \cline{5-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 109563 & 1086,7 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 109287 & 1173,8 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 109287 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|cc|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{d493 VNS (costo ottimo 35002)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            37367 & 0,0 & \multicolumn{1}{c|}{37017} & 0,0 & 37712 & 0,0 & 37356 & 0,0\tabularnewline
            \hline 
            37302 & 4,0 & \multicolumn{1}{c|}{36771} & 14,6 & 37561 & 0,8 & 37256 & 0,3\tabularnewline
            \hline 
            37210 & 8,3 & \multicolumn{1}{c|}{36736} & 66,1 & 37519 & 1,5 & 37062 & 1,0\tabularnewline
            \hline 
            37114 & 8,8 & \multicolumn{1}{c|}{36593} & 82,2 & 37328 & 2,3 & 37022 & 105,9\tabularnewline
            \hline 
            37065 & 10,1 & \multicolumn{1}{c|}{36495} & 522,8 & 37285 & 2,6 & 36960 & 106,5\tabularnewline
            \hline 
            36888 & 12,1 & \multicolumn{1}{c|}{36344} & 1170,5 & 37263 & 5,4 & 36902 & 107,2\tabularnewline
            \hline 
            36833 & 20,5 & \multicolumn{1}{c|}{36344} & 1800 & 37177 & 5,9 & 36784 & 107,5\tabularnewline
            \hline 
            36546 & 27,8 &  &  & 36894 & 10,7 & 36579 & 108,0\tabularnewline
            \cline{1-2} \cline{5-8} 
            36532 & 28,2 &  &  & 36813 & 14,2 & 36530 & 108,8\tabularnewline
            \cline{1-2} \cline{5-8} 
            36452 & 31,1 &  &  & 36738 & 94,7 & 36519 & 113,5\tabularnewline
            \cline{1-2} \cline{5-8} 
            36421 & 537,5 &  &  & 36550 & 97,0 & 36388 & 136,3\tabularnewline
            \cline{1-2} \cline{5-8} 
            36276 & 537,9 &  &  & 36517 & 124,4 & 36296 & 136,8\tabularnewline
            \cline{1-2} \cline{5-8} 
            36276 & 1800 &  &  & 36484 & 125,1 & 36296 & 1800\tabularnewline
            \cline{1-2} \cline{5-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 36431 & 144,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 36398 & 144,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 36260 & 273,5 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 36260 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{rat575 VNS (costo ottimo 6773)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            7239 & 0,0 & 7342 & 0,0 & 7318 & 0,0 & 7369 & 0,0\tabularnewline
            \hline 
            7233 & 34,4 & 7312 & 0,8 & 7294 & 0,4 & 7366 & 0,4\tabularnewline
            \hline 
            7232 & 57,6 & 7287 & 15,7 & 7283 & 5,8 & 7316 & 2,0\tabularnewline
            \hline 
            7229 & 58,2 & 7276 & 16,5 & 7277 & 6,1 & 7270 & 3,0\tabularnewline
            \hline 
            7226 & 71,9 & 7250 & 18,6 & 7274 & 8,4 & 7269 & 4,0\tabularnewline
            \hline 
            7203 & 130,5 & 7248 & 19,1 & 7265 & 20,9 & 7240 & 6,5\tabularnewline
            \hline 
            7192 & 132,2 & 7188 & 127,2 & 7231 & 26,4 & 7229 & 114,3\tabularnewline
            \hline 
            7171 & 300,1 & 7186 & 313,7 & 7200 & 80,6 & 7207 & 115,6\tabularnewline
            \hline 
            7171 & 1800,0 & 7173 & 381,3 & 7189 & 511,7 & 7181 & 520,9\tabularnewline
            \hline 
            \multicolumn{1}{c}{} &  & 7173 & 1800,0 & 7180 & 833,6 & 7157 & 992,6\tabularnewline
            \cline{3-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 7176 & 869,9 & 7157 & 1800,0\tabularnewline
            \cline{5-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 7174 & 871,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 7161 & 872,1 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 7129 & 873,5 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 7129 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|c|c|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{d657 VNS (costo ottimo 48912)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            52642 & 0,0 & 52724 & 0,0 & 52852 & 0,0 & 53319 & 0,0\tabularnewline
            \hline 
            52583 & 3,1 & 52629 & 1,6 & 52484 & 1,1 & 53304 & 0,8\tabularnewline
            \hline 
            52443 & 17,5 & 52283 & 29,2 & 52157 & 3,1 & 53274 & 1,7\tabularnewline
            \hline 
            52271 & 19,7 & 52199 & 88,0 & 52053 & 100,1 & 53141 & 2,4\tabularnewline
            \hline 
            52145 & 42,1 & 52166 & 89,0 & 52035 & 100,6 & 52650 & 3,0\tabularnewline
            \hline 
            52072 & 46,4 & 52154 & 120,9 & 51824 & 145,5 & 52037 & 3,4\tabularnewline
            \hline 
            52058 & 51,0 & 51923 & 126,3 & 51789 & 147,6 & 51922 & 136,8\tabularnewline
            \hline 
            51944 & 63,9 & 51874 & 152,2 & 51785 & 148,4 & 51667 & 147,5\tabularnewline
            \hline 
            51767 & 70,8 & 51409 & 153,1 & 51733 & 420,5 & 51352 & 149,8\tabularnewline
            \hline 
            51669 & 214,3 & 51109 & 177,2 & 51703 & 421,5 & 51352 & 1800,0\tabularnewline
            \hline 
            51648 & 319,5 & 50997 & 179,8 & 51620 & 422,3 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            51580 & 325,7 & 50872 & 180,4 & 51602 & 425,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            51462 & 326,8 & 50768 & 181,6 & 51550 & 429,8 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            51051 & 388,2 & 50768 & 1800,0 & 51405 & 431,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-6} 
            51051 & 1800,0 & \multicolumn{1}{c}{} &  & 51235 & 433,1 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 51224 & 885,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 51194 & 889,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 50809 & 1194,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 50809 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|c|c|cc|c|c|}
            \hline 
            \multicolumn{8}{|c|}{u724 VNS (costo ottimo 41910)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            45228 & 0,001 & 44729 & 0,001 & \multicolumn{1}{c|}{44683} & 0,001 & 45146 & 0,001\tabularnewline
            \hline 
            45054 & 41,522 & 44669 & 3,564 & \multicolumn{1}{c|}{44505} & 54,886 & 45022 & 0,69\tabularnewline
            \hline 
            44987 & 47,077 & 44636 & 28,622 & \multicolumn{1}{c|}{44441} & 56,136 & 45001 & 25,236\tabularnewline
            \hline 
            44957 & 183,277 & 44496 & 112,255 & \multicolumn{1}{c|}{44390} & 834,913 & 44965 & 26,903\tabularnewline
            \hline 
            44788 & 211,512 & 44459 & 1083,77 & \multicolumn{1}{c|}{44316} & 1118,98 & 44929 & 27,838\tabularnewline
            \hline 
            44786 & 415,122 & 44331 & 1284,459 & \multicolumn{1}{c|}{44316} & 1800,0 & 44846 & 79,558\tabularnewline
            \hline 
            44500 & 438,924 & 44196 & 1708,761 &  &  & 44763 & 117,202\tabularnewline
            \cline{1-4} \cline{7-8} 
            44381 & 479,237 & 44196 & 1800,0 &  &  & 44681 & 124,146\tabularnewline
            \cline{1-4} \cline{7-8} 
            44246 & 483,172 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 44567 & 345,671\tabularnewline
            \cline{1-2} \cline{7-8} 
            44201 & 744,046 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 44556 & 458,118\tabularnewline
            \cline{1-2} \cline{7-8} 
            44201 & 1800,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 44416 & 459,21\tabularnewline
            \cline{1-2} \cline{7-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 44270 & 1151,915\tabularnewline
            \cline{7-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 44202 & 1152,22\tabularnewline
            \cline{7-8} 
            \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  &  & 44202 & 1800,0\tabularnewline
            \cline{7-8} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{cccc|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{rat783 VNS (costo ottimo 8806)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{Costo} & \multicolumn{1}{c|}{Tempo (s)} & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{9399} & \multicolumn{1}{c|}{0,0} & \multicolumn{1}{c|}{9432} & 0,0 & 9606 & 0,0 & 9459 & 0,0\tabularnewline
            \hline 
            \multicolumn{1}{|c|}{9399} & \multicolumn{1}{c|}{1800} & \multicolumn{1}{c|}{9418} & 24,7 & 9596 & 0,7 & 9453 & 53,0\tabularnewline
            \hline 
            & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{9393} & 26,2 & 9578 & 2,5 & 9452 & 639,3\tabularnewline
            \cline{3-8} 
            & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{9371} & 117,1 & 9563 & 43,9 & 9448 & 911,3\tabularnewline
            \cline{3-8} 
            & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{9366} & 118,0 & 9562 & 44,7 & 9439 & 912,4\tabularnewline
            \cline{3-8} 
            & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{9356} & 120,2 & 9528 & 47,6 & 9426 & 1000,8\tabularnewline
            \cline{3-8} 
            & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{9356} & 1800 & 9523 & 63,5 & 9402 & 1660,8\tabularnewline
            \cline{3-8} 
            &  &  &  & 9513 & 78,4 & 9394 & 1677,7\tabularnewline
            \cline{5-8} 
            &  &  &  & 9504 & 84,9 & 9384 & 1683,0\tabularnewline
            \cline{5-8} 
            &  &  &  & 9495 & 95,3 & 9384 & 1800\tabularnewline
            \cline{5-8} 
            &  &  &  & 9488 & 139,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9477 & 140,1 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9466 & 163,8 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9445 & 164,0 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9443 & 168,9 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9421 & 169,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9420 & 390,7 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9419 & 391,7 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9415 & 392,4 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9406 & 976,6 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
            &  &  &  & 9406 & 1800 & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{5-6} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\vspace*{\fill}
{
    \centering
    \centerline{\begin{tabular}{|c|c|cc|c|c|c|c|}
            \hline 
            \multicolumn{8}{|c|}{dsj1000 VNS (costo ottimo 18659688)}\tabularnewline
            \hline 
            \hline 
            \multicolumn{2}{|c|}{Thread1} & \multicolumn{2}{c|}{Thread2} & \multicolumn{2}{c|}{Thread3} & \multicolumn{2}{c|}{Thread4}\tabularnewline
            \hline 
            Costo & Tempo (s) & \multicolumn{1}{c|}{Costo} & Tempo (s) & Costo & Tempo (s) & Costo & Tempo (s)\tabularnewline
            \hline 
            20388124 & 0,0 & \multicolumn{1}{c|}{19933316} & 0,0 & 20179476 & 0,0 & 20192173 & 0,0\tabularnewline
            \hline 
            20350385 & 0,9 & \multicolumn{1}{c|}{19901388} & 3,9 & 20041915 & 8,3 & 20190252 & 17,1\tabularnewline
            \hline 
            20315711 & 29,2 & \multicolumn{1}{c|}{19819155} & 23,8 & 20037603 & 822,0 & 20161855 & 136,0\tabularnewline
            \hline 
            20273258 & 82,7 & \multicolumn{1}{c|}{19818600} & 849,1 & 20010375 & 889,4 & 20068673 & 149,9\tabularnewline
            \hline 
            20207005 & 90,0 & \multicolumn{1}{c|}{19811979} & 850,2 & 19968630 & 890,5 & 20063392 & 158,9\tabularnewline
            \hline 
            20202303 & 92,6 & \multicolumn{1}{c|}{19811979} & 1800,0 & 19930678 & 1750,2 & 20054192 & 159,4\tabularnewline
            \hline 
            20196943 & 95,1 &  &  & 19918893 & 1755,2 & 19926458 & 160,8\tabularnewline
            \cline{1-2} \cline{5-8} 
            20059067 & 113,1 &  &  & 19918893 & 1800,0 & 19856223 & 638,3\tabularnewline
            \cline{1-2} \cline{5-8} 
            20054941 & 119,3 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 19834387 & 1649,3\tabularnewline
            \cline{1-2} \cline{7-8} 
            20023983 & 150,4 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &  & 19834387 & 1800,0\tabularnewline
            \cline{1-2} \cline{7-8} 
            19976516 & 314,6 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} 
            19892262 & 324,5 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} 
            19861128 & 1082,7 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} 
            19861128 & 1800,0 &  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\tabularnewline
            \cline{1-2} 
        \end{tabular}
    }
    \captionof{table}{Tabella risultati instanze con numero di nodi compreso tra \textbf{$200$} e \textbf{$299$} $+$ algoritmi esatti}
}
\vspace*{\fill}

\end{document}
