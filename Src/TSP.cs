using ILOG.Concert;
using ILOG.CPLEX;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Management;

namespace TSPCsharp
{
    class TSP
    {
        //--------------------------------------------------------COMMON Objects--------------------------------------------------------
        //Process used to start GNUPlot
        static Process process;
        //StreamWriter used by GNUPlot to print the solution
        static StreamWriter file;
        //Instance of the solution
        static Instance instance;
        //Stopwatch
        static Stopwatch cl;
        //Cplex object
        static Cplex cplex;
        //INumVar is a special interface used to stare any kinf of variable compatible with cplex
        //Building the model, z is necessary to access the variabiles via their stored names
        static INumVar[] z;

        //------------------------------------------------------Loop COMMON OBjects-----------------------------------------------------
        //listArray contains the nearest availeble edges for each edge 
        static List<int>[] listArray;
        //compConn stores the related component of each node
        static int[] compConn;
        //Buffers used 
        static List<ILinearNumExpr> ccExpr;
        static List<int> bufferCoeffCC;
        //If 0 the solution used heuristics methods, otherwhise it is 1
        static int typeSol = 1;


        public class TSPLazyConsCallback : Cplex.LazyConstraintCallback
        {
            public override void Main()
            {
                //Buffers used 
                List<ILinearNumExpr> ccExprLC = new List<ILinearNumExpr>();
                List<int> bufferCoeffCCLC = new List<int>(); ;

                int[] compConnLC = new int[instance.NNodes];

                InitCC(compConnLC);

                //To call GetValues for each value in z is a lot more expensive for unknown reasons
                double[] actualZ = GetValues(z);

                string nodeId = GetNodeId().ToString();

                //Init the StreamWriter for the current solution
                StreamWriter fileLC = new StreamWriter(instance.InputFile + "_" + nodeId + ".dat", false);

                for (int i = 0; i < instance.NNodes; i++)
                {
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {
                        //Retriving the correct index position for the current link inside z
                        int position = zPos(i, j, instance.NNodes);

                        //Only links in the optimal solution (coefficient = 1) are printed in the GNUPlot file
                        if (actualZ[position] >= 0.5)
                        {
                            //Updating the model with the current subtours elimination
                            BuildCC(i, j, ccExprLC, bufferCoeffCCLC, compConnLC);


                            fileLC.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                            fileLC.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");
                        }
                    }
                }

                //GNUPlot input file needs to be closed
                fileLC.Close();

                //Accessing GNUPlot to read the file
                if (Program.VERBOSE >= -100)
                    PrintGNUPlot(instance.InputFile + "_" + nodeId, typeSol);

                IRange[] cuts = new IRange[ccExprLC.Count];

                if (cuts.Length > 1)
                {
                    for (int i = 0; i < cuts.Length; i++)
                    {
                        cuts[i] = cplex.Le(ccExprLC[i], bufferCoeffCCLC[i] - 1);

                        //----------------------2----------------------
                        // Riepilogo:
                        //     The cut is treated exactly as cuts generated by CPLEX.
                        //
                        // Commenti:
                        //     In other words, the cut is filtered through the CPLEX process; it may not even
                        //     be added to the relaxation; for example, if other cuts are deemed more effective,
                        //     or if the cut is too dense, or for other similar reasons.
                        //----------------------0----------------------
                        // Riepilogo:
                        //     The cut is added to the relaxation and remains there.
                        //----------------------1----------------------
                        // Riepilogo:
                        //     The cut is added to the relaxation, but can be purged later if CPLEX determines
                        //     that the cut is ineffective.

                        Add(cuts[i], 1);
                    }                    
                }
            }

            internal void BuildCC(int i, int j, List<ILinearNumExpr> ccExprLC, List<int> bufferCoeffCCLC, int[] compConnLC)
            {
                if (compConnLC[i] != compConnLC[j])//Same related component, the latter is not closed yet
                {
                    for (int k = 0; k < compConnLC.Length; k++)// k>i poichè i > j
                    {
                        if ((k != j) && (compConnLC[k] == compConnLC[j]))
                        {
                            //Same as Kruskal
                            compConnLC[k] = compConnLC[i];
                        }
                    }

                    //Finally also the vallue relative to the Point j are updated
                    compConnLC[j] = compConnLC[i];
                }
                else//Here the current releted component is complete and the relative subtout elimination constraint can be added to the model
                {
                    ILinearNumExpr expr = cplex.LinearNumExpr();

                    int cnt = 0;

                    for (int h = 0; h < compConnLC.Length; h++)
                    {
                        if (compConnLC[h] == compConnLC[i])
                        {
                            for (int k = h + 1; k < compConnLC.Length; k++)
                            {
                                if (compConnLC[k] == compConnLC[i])
                                {
                                    expr.AddTerm(z[zPos(h, k, compConnLC.Length)], 1);
                                }
                            }

                            cnt++;
                        }
                    }

                    ccExprLC.Add(expr);
                    bufferCoeffCCLC.Add(cnt);
                }

            }
        }


        public class itemList
        {
            public itemList(double d, int i)
            {
                dist = d;
                index = i;
            }

            public double dist { get; set; }
            public int index { get; set; }
        }


        static public bool TSPOpt(Instance inst, Stopwatch clock)
        {

            cl = clock;

            //Cplex is the official class offered by IBM inside the API to use cplex
            //algorithms with C#
            cplex = new Cplex();
            cplex.SetParam(Cplex.Param.MIP.Strategy.Search, Cplex.MIPSearch.Dynamic);

            instance = inst;

            //Real starting time is stored inside instance
            instance.TStart = clock.ElapsedMilliseconds / 1000.0;

            clock.Stop();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write("\nPress enter to continue, attention: the display will be cleared");
            Console.ReadLine();
            Console.Clear();
            Console.ForegroundColor = ConsoleColor.White;

            Console.Write("Insert 1 to use the classic loop method or 2 to use the optimal branch & cut: ");

            switch (Console.ReadLine())
            {
                case "1":
                    {
                        Console.Write("\nInsert 1 to not use any heuristic method, 2 to use the % precion method, 3 to use only a # of the nearest edges, 4 to use both previous options: ");
                        switch (Console.ReadLine())
                        {
                            case "1":
                                {
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    Loop(-1, -1);
                                    break;
                                }

                            case "2":
                                {
                                    Console.Write("\nWrite the % precision: ");
                                    double percentage = Convert.ToDouble(Console.ReadLine());
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    Loop(percentage, -1);
                                    break;
                                }

                            case "3":
                                {
                                    Console.Write("\nWrite the # of nearest edges: ");
                                    int numb = Convert.ToInt32(Console.ReadLine());
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    Loop(-1, numb);
                                    break;
                                }

                            case "4":
                                {
                                    Console.Write("\nWrite the % precision: ");
                                    double percentage = Convert.ToDouble(Console.ReadLine());
                                    Console.Write("Write the # of nearest edges: ");
                                    int numb = Convert.ToInt32(Console.ReadLine());
                                    clock.Start();
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    Loop(percentage, numb);
                                    break;
                                }

                            default:
                                throw new System.Exception("Bad argument");
                        }
                        break;
                    }

                case "2":
                    {
                        Console.Write("\nInsert 1 to not use any heuristic method, 2 to use the % precion method, 3 to use only a # of the nearest edges, 4 to use both previous options: ");
                        switch (Console.ReadLine())
                        {
                            case "1":
                                {
                                    //Restarting the clock
                                    clock.Start();
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    CallBackMethod(-1, -1);
                                    break;
                                }

                            case "2":
                                {
                                    Console.Write("\nWrite the % precision: ");
                                    double percentage = Convert.ToDouble(Console.ReadLine());
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    CallBackMethod(percentage, -1);
                                    break;
                                }

                            case "3":
                                {
                                    Console.Write("\nWrite the # of nearest edges: ");
                                    int numb = Convert.ToInt32(Console.ReadLine());
                                    clock.Start();
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    CallBackMethod(-1, numb);
                                    break;
                                }

                            case "4":
                                {
                                    Console.Write("\nWrite the % precision: ");
                                    double percentage = Convert.ToDouble(Console.ReadLine());
                                    Console.Write("Write the # of nearest edges: ");
                                    int numb = Convert.ToInt32(Console.ReadLine());
                                    clock.Start();
                                    //Real starting time is stored inside instance
                                    instance.TStart = clock.ElapsedMilliseconds / 1000.0;
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    CallBackMethod(percentage, numb);
                                    break;
                                }

                            default:
                                throw new System.Exception("Bad argument");
                        }

                        
                        break;
                    }

                default:
                    throw new System.Exception("Bad argument");
            }
            return true;
        }


        static void Loop(double perc, int numb)
        {

            bool epGap = false;

            bool allEdges = true;

            if (perc <= 1 && perc >= 0)
            {
                cplex.SetParam(Cplex.DoubleParam.EpGap, perc);

                epGap = true;

                typeSol = 0;
            }

            if (numb != -1)
            {
                allEdges = false;

                typeSol = 0;
            }

            z = BuildModel(numb);

            //Allocating the correct space to store the optimal solution
            //Only links from node i to j with i < j are considered
            instance.BestSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

            compConn = new int[instance.NNodes];

            process = InitProcess();

            ccExpr = new List<ILinearNumExpr>();
            bufferCoeffCC = new List<int>();

            do
            {
                if (ccExpr.Count == 1)
                {
                    epGap = false;

                    allEdges = true;

                    cplex.SetParam(Cplex.DoubleParam.EpGap, 1e-06);

                    ResetVariables(z);

                    typeSol = 1;
                }

                //Cplex solves the current model
                cplex.Solve();

                //Initializing the arrays used to eliminate the subtour
                InitCC(compConn);

                ccExpr = new List<ILinearNumExpr>();
                bufferCoeffCC = new List<int>();

                //Init the StreamWriter for the current solution
                file = new StreamWriter(instance.InputFile + ".dat", false);

                //Storing the optimal value of the objective function
                instance.ZBest = cplex.ObjValue;

                //Blank line
                cplex.Output().WriteLine();

                //Printing the optimal solution and the GNUPlot input file
                for (int i = 0; i < instance.NNodes; i++)
                {
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {

                        //Retriving the correct index position for the current link inside z
                        int position = zPos(i, j, instance.NNodes);

                        //Reading the optimal solution for the actual link (i,j)
                        instance.BestSol[position] = cplex.GetValue(z[position]);

                        //Only links in the optimal solution (coefficient = 1) are printed in the GNUPlot file
                        if (instance.BestSol[position] >= 0.5)
                        {
                            /*
                             *Current GNUPlot format is:
                             *-- previus link --
                             *<Blank line>
                             *Xi Yi <index(i)>
                             *Xj Yj <index(j)>
                             *<Blank line> 
                             *-- next link --
                            */
                            file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                            file.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");

                            //Updating the model with the current subtours elimination
                            UpdateCC(i, j);
                        }
                    }
                }

                if (ccExpr.Count > 1)
                {
                    for (int i = 0; i < ccExpr.Count; i++)
                        cplex.AddLe(ccExpr[i], bufferCoeffCC[i] - 1);
                }

                //GNUPlot input file needs to be closed
                file.Close();

                //Accessing GNUPlot to read the file
                if (Program.VERBOSE >= -100)
                    PrintGNUPlot(instance.InputFile, typeSol);

                //Blank line
                cplex.Output().WriteLine();

                //Writing the value
                cplex.Output().WriteLine("zOPT = " + instance.ZBest + "\n");

                //Exporting the updated model
                if (Program.VERBOSE >= -100)
                    cplex.ExportModel(instance.InputFile + ".lp");

            } while (ccExpr.Count > 1 || epGap || !allEdges); //if there is more then one related components the solution is not optimal 


            //Closing Cplex link
            cplex.End();

            //Accessing GNUPlot to read the file
            if (Program.VERBOSE >= -100)
                PrintGNUPlot(instance.InputFile, typeSol);
        }

        static void CallBackMethod(double perc, int numb)
        {
            bool epGap = false;

            bool allEdges = true;

            if (perc <= 1 && perc >= 0)
            {
                cplex.SetParam(Cplex.DoubleParam.EpGap, perc);

                epGap = true;

                typeSol = 0;
            }

            if (numb != -1)
            {
                allEdges = false;

                typeSol = 0;
            }

            z = BuildModel(numb);

            instance.BestSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

            process = InitProcess();

            // Turn off presolve to prevent it from completely solving the model
            // before entering the actual LP optimizer
            cplex.SetParam(Cplex.Param.Preprocessing.Presolve, false);

            // Turn on traditional search for use with control callbacks
            cplex.SetParam(Cplex.Param.MIP.Strategy.Search, Cplex.MIPSearch.Auto);

            cplex.SetParam(Cplex.Param.Threads, Environment.ProcessorCount);

            cplex.Use(new TSPLazyConsCallback());

            cplex.Solve();

            if (epGap || !allEdges)
            {
                epGap = false;

                allEdges = true;

                cplex.SetParam(Cplex.DoubleParam.EpGap, 1e-06);

                ResetVariables(z);

                typeSol = 1;

                cplex.Solve();
            }

            //Init the StreamWriter for the current solution
            file = new StreamWriter(instance.InputFile + ".dat", false);

            //Storing the optimal value of the objective function
            instance.ZBest = cplex.ObjValue;

            //Blank line
            cplex.Output().WriteLine();

            //Printing the optimal solution and the GNUPlot input file
            for (int i = 0; i < instance.NNodes; i++)
            {
                for (int j = i + 1; j < instance.NNodes; j++)
                {

                    //Retriving the correct index position for the current link inside z
                    int position = zPos(i, j, instance.NNodes);

                    //Reading the optimal solution for the actual link (i,j)
                    instance.BestSol[position] = cplex.GetValue(z[position]);

                    //Only links in the optimal solution (coefficient = 1) are printed in the GNUPlot file
                    if (instance.BestSol[position] >= 0.5)
                    {
                        /*
                         *Current GNUPlot format is:
                         *-- previus link --
                         *<Blank line>
                         *Xi Yi <index(i)>
                         *Xj Yj <index(j)>
                         *<Blank line> 
                         *-- next link --
                        */
                        file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                        file.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");
                    }
                }
            }

            //GNUPlot input file needs to be closed
            file.Close();

            //Accessing GNUPlot to read the file
            if (Program.VERBOSE >= -100)
                PrintGNUPlot(instance.InputFile, typeSol);

            //Blank line
            cplex.Output().WriteLine();

            //Writing the value
            cplex.Output().WriteLine("zOPT = " + instance.ZBest + "\n");

            //Exporting the updated model
            if (Program.VERBOSE >= -100)
                cplex.ExportModel(instance.InputFile + ".lp");
        }


        static void ResetVariables(INumVar[] z)
        {
            for (int i = 0; i < z.Length; i++)
                z[i].UB = 1;
        }


        static List<int>[] BuildSL()
        {
            List<itemList>[] SL = new List<itemList>[instance.NNodes];
            List<int>[] L = new List<int>[instance.NNodes];

            for (int i = 0; i < SL.Length; i++)
            {
                SL[i] = new List<itemList>();

                for (int j = i + 1; j < SL.Length; j++)
                {
                    if (i != j)
                        SL[i].Add(new itemList(Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType), j));
                }

                SL[i] = SL[i].OrderBy(itemList => itemList.dist).ToList<itemList>();
                L[i] = SL[i].Select(itemList => itemList.index).ToList<int>();
            }

            return L;
        }


        //Building initial model
        static INumVar[] BuildModel(int n)
        {

            if (n != -1)
                listArray = BuildSL();

            INumVar[] z = new INumVar[(instance.NNodes - 1) * instance.NNodes / 2];

            /*
             *expr will hold all the expressions that needs to be added to the model
             *initially it will be the optimality's functions
             *later it will be Ax's rows 
            */
            ILinearNumExpr expr = cplex.LinearNumExpr();


            //Populating objective function
            for (int i = 0; i < instance.NNodes; i++)
            {
                if (n >= 0)
                {
                    //Only links (i,j) with i < j are correct
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {
                        //zPos return the correct position where to store the variable corresponding to the actual link (i,j)
                        int position = zPos(i, j, instance.NNodes);
                        if ((listArray[i]).IndexOf(j) < n)
                            z[position] = cplex.NumVar(0, 1, NumVarType.Int, "z(" + (i + 1) + "," + (j + 1) + ")");
                        else
                            z[position] = cplex.NumVar(0, 0, NumVarType.Int, "z(" + (i + 1) + "," + (j + 1) + ")");
                        expr.AddTerm(z[position], Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType));
                    }
                }
                else
                {
                    //Only links (i,j) with i < j are correct
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {
                        //zPos return the correct position where to store the variable corresponding to the actual link (i,j)
                        int position = zPos(i, j, instance.NNodes);
                        z[position] = cplex.NumVar(0, 1, NumVarType.Int, "z(" + (i + 1) + "," + (j + 1) + ")");
                        expr.AddTerm(z[position], Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType));
                    }
                }
            }

            //Setting the optimality's function
            cplex.AddMinimize(expr);


            //Starting to elaborate Ax
            for (int i = 0; i < instance.NNodes; i++)
            {
                //Resetting expr
                expr = cplex.LinearNumExpr();

                for (int j = 0; j < instance.NNodes; j++)
                {
                    //For each row i only the links (i,j) or (j,i) have coefficent 1
                    //zPos return the correct position where link is stored inside the vector z
                    if (i != j)//No loops wioth only one node
                        expr.AddTerm(z[zPos(i, j, instance.NNodes)], 1);
                }

                //Adding to Ax the current equation with known term 2 and name degree(<current i node>)
                cplex.AddEq(expr, 2, "degree(" + (i + 1) + ")");
            }

            //Printing the complete model inside the file <name_file.tsp.lp>
            if (Program.VERBOSE >= -100)
                cplex.ExportModel(instance.InputFile + ".lp");

            return z;

        }


        //Print for GNUPlot
        static void PrintGNUPlot(string name, int typeSol)
        {
            if (process != null)
            {
                /*
                 *Writing in the prompt:
                 *gnuplot
                 *set style line 1 lc rgb '#0060ad' lt 1 lw 2 pt 7 ps 0.5
                 *plot '<name_current_solution>.dat' with linespoints ls 1 notitle, '<name_current_solution>.dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle"
                 */

                if(typeSol == 0)
                    process.StandardInput.WriteLine("set style line 1 lc rgb '#0060ad' lt 1 lw 2 pt 7 ps 0.5\nplot '" + name + ".dat' with linespoints ls 1 notitle, '" + name + ".dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle");
                else if(typeSol == 1)
                    process.StandardInput.WriteLine("set style line 1 lc rgb '#ad0000' lt 1 lw 2 pt 7 ps 0.5\nplot '" + name + ".dat' with linespoints ls 1 notitle, '" + name + ".dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle");

            }
        }


        //Used to evaluete the correct position to store and read the variables for the model
        static int zPos(int i, int j, int nNodes)
        {
            if (i == j)
                return -1;

            if (i > j)
                return zPos(j, i, nNodes);

            return i * nNodes + j - (i + 1) * (i + 2) / 2;
        }


        //Setting the current real residual time for Cplex and some relative parameters
        static void MipTimelimit(Stopwatch clock)
        {
            double residualTime = instance.TStart + instance.TimeLimit - clock.ElapsedMilliseconds / 1000.0;

            if (residualTime < 0.0)
                residualTime = 0.0;

            cplex.SetParam(Cplex.IntParam.ClockType, 2);
            cplex.SetParam(Cplex.Param.TimeLimit, residualTime);                            // real time
            cplex.SetParam(Cplex.Param.DetTimeLimit, Program.TICKS_PER_SECOND * cplex.GetParam(Cplex.Param.TimeLimit));			// ticks
        }


        //Initialization of the arrays used to keep track of the related components
        static void InitCC(int[] cc)
        {
            for (int i = 0; i < cc.Length; i++)
            {
                cc[i] = i;
            }
        }


        //Updating the related components for the current solution
        static void UpdateCC(int i, int j)
        {
            if (compConn[i] != compConn[j])//Same related component, the latter is not closed yet
            {
                for (int k = 0; k < compConn.Length; k++)// k>i poichè i > j
                {
                    if ((k != j) && (compConn[k] == compConn[j]))
                    {
                        //Same as Kruskal
                        compConn[k] = compConn[i];
                    }
                }

                //Finally also the vallue relative to the Point j are updated
                compConn[j] = compConn[i];
            }
            else//Here the current releted component is complete and the relative subtout elimination constraint can be added to the model
            {
                ILinearNumExpr expr = cplex.LinearNumExpr();

                int cnt = 0;

                for (int h = 0; h < compConn.Length; h++)
                {
                    if (compConn[h] == compConn[i])
                    {
                        for (int k = h + 1; k < compConn.Length; k++)
                        {
                            if (compConn[k] == compConn[i])
                            {
                                expr.AddTerm(z[zPos(h, k, compConn.Length)], 1);
                            }
                        }

                        cnt++;
                    }
                }

                ccExpr.Add(expr);
                bufferCoeffCC.Add(cnt);                
            }
        }

        static Process InitProcess ()
        {
            //Setting values to open Prompt
            ProcessStartInfo processStartInfo = new ProcessStartInfo("cmd.exe");
            processStartInfo.RedirectStandardInput = true;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.UseShellExecute = false;

            //Executing the Prompt
            Process process = Process.Start(processStartInfo);

            //Enabling GNUPlot commands
            process.StandardInput.WriteLine("gnuplot");

            return process;
        }

    }
}
    
