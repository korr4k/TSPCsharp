using ILOG.Concert;
using ILOG.CPLEX;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System;
using System.Linq;
using System.Windows.Forms;

namespace TSPCsharp
{
    class TSP
    {
        //--------------------------------------------------------COMMON Objects--------------------------------------------------------
        //Process used to start GNUPlot
        static Process process;
        //StreamWriter used by GNUPlot to print the solution
        static StreamWriter file;
        //Instance of the solution
        static Instance instance;
        //Stopwatch
        static Stopwatch cl;
        //Cplex object
        static Cplex cplex;
        //INumVar is a special interface used to stare any kinf of variable compatible with cplex
        //Building the model, z is necessary to access the variabiles via their stored names
        static INumVar[] z;

        //------------------------------------------------------Loop COMMON OBjects-----------------------------------------------------
        //listArray contains the nearest availeble edges for each edge 
        static List<int>[] listArray;
        //compConn stores the related component of each node
        static int[] compConn;
        //Buffers used, ccExpr buffers the cuts for the loop method, buffeCoeffCC buffers the cuts known term
        static List<ILinearNumExpr> ccExpr;
        static List<int> bufferCoeffCC;
        //If 0 the solution used heuristics methods, otherwhise it is 1, this parameter is used to set print GNUPlot graphs in different colors
        static int typeSol = 1;


        //Define the Lazy Callback
        public class TSPLazyConsCallback : Cplex.LazyConstraintCallback
        {
            public override void Main()
            {
                //Init buffers, due to multithreading, using global buffers is incorrect
                List<ILinearNumExpr> ccExprLC = new List<ILinearNumExpr>();
                List<int> bufferCoeffCCLC = new List<int>(); ;

                int[] compConnLC = new int[instance.NNodes];

                InitCC(compConnLC);

                //To call GetValues for each value in z is a lot more expensive for unknown reasons
                double[] actualZ = GetValues(z);

                //Node's is that generated the callback, used to create an unique nome for the GNUPlot files
                string nodeId = GetNodeId().ToString();

                StreamWriter fileLC;

                if (Program.VERBOSE >= -1)
                {
                    //Init the StreamWriter for the current solution
                    fileLC = new StreamWriter(instance.InputFile + "_" + nodeId + ".dat", false);
                }

                for (int i = 0; i < instance.NNodes; i++)
                {
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {
                        //Retriving the correct index position for the current link inside z
                        int position = zPos(i, j, instance.NNodes);

                        //Only links in the optimal solution (coefficient = 1) are printed in the GNUPlot file
                        if (actualZ[position] >= 0.5)
                        {
                            //Updating the model with the current subtours elimination
                            BuildCC(i, j, ccExprLC, bufferCoeffCCLC, compConnLC);

                            if (Program.VERBOSE >= -1)
                            {
                                fileLC.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                                fileLC.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");
                            }
                        }
                    }
                }

                if (Program.VERBOSE >= -1)
                {
                    //GNUPlot input file needs to be closed
                    fileLC.Close();
                }

                //Accessing GNUPlot to read the file
                if (Program.VERBOSE >= -1)
                    PrintGNUPlot(instance.InputFile + "_" + nodeId, typeSol);

                //cuts will stores the user's cut
                IRange[] cuts = new IRange[ccExprLC.Count];

                if (cuts.Length > 1)
                {
                    for (int i = 0; i < cuts.Length; i++)
                    {
                        cuts[i] = cplex.Le(ccExprLC[i], bufferCoeffCCLC[i] - 1);

                        //----------------------2----------------------
                        // Riepilogo:
                        //     The cut is treated exactly as cuts generated by CPLEX.
                        //
                        // Commenti:
                        //     In other words, the cut is filtered through the CPLEX process; it may not even
                        //     be added to the relaxation; for example, if other cuts are deemed more effective,
                        //     or if the cut is too dense, or for other similar reasons.
                        //----------------------0----------------------
                        // Riepilogo:
                        //     The cut is added to the relaxation and remains there.
                        //----------------------1----------------------
                        // Riepilogo:
                        //     The cut is added to the relaxation, but can be purged later if CPLEX determines
                        //     that the cut is ineffective.

                        //Adding global cuts to cplex's model
                        Add(cuts[i], 1);
                    }                    
                }
            }

            //Same as
            internal void BuildCC(int i, int j, List<ILinearNumExpr> ccExprLC, List<int> bufferCoeffCCLC, int[] compConnLC)
            {
                if (compConnLC[i] != compConnLC[j])//Same related component, the latter is not closed yet
                {
                    for (int k = 0; k < compConnLC.Length; k++)// k>i poichè i > j
                    {
                        if ((k != j) && (compConnLC[k] == compConnLC[j]))
                        {
                            //Same as Kruskal
                            compConnLC[k] = compConnLC[i];
                        }
                    }

                    //Finally also the vallue relative to the Point j are updated
                    compConnLC[j] = compConnLC[i];
                }
                else//Here the current releted component is complete and the relative subtout elimination constraint can be added to the model
                {
                    ILinearNumExpr expr = cplex.LinearNumExpr();

                    int cnt = 0;

                    for (int h = 0; h < compConnLC.Length; h++)
                    {
                        if (compConnLC[h] == compConnLC[i])
                        {
                            for (int k = h + 1; k < compConnLC.Length; k++)
                            {
                                if (compConnLC[k] == compConnLC[i])
                                {
                                    expr.AddTerm(z[zPos(h, k, compConnLC.Length)], 1);
                                }
                            }

                            cnt++;
                        }
                    }

                    ccExprLC.Add(expr);
                    bufferCoeffCCLC.Add(cnt);
                }

            }
        }

        static Random rnd;
        static int[] zHeuristic;
        static double distHeuristic;
        static int[] incumbentZHeuristic;
        static double incumbentDist;
        static Tabu tabu;


        //Support class for BuildSL()
        public class itemList
        {
            public itemList(double d, int i)
            {
                dist = d;
                index = i;
            }

            public double dist { get; set; }
            public int index { get; set; }
        }


        //"Main" method
        static public bool TSPOpt(Instance inst, Stopwatch clock)
        {
            //cl is the global variable used TSP.cs
            cl = clock;

            //Cplex is the official class offered by IBM inside the API to use cplex
            //algorithms with C#
            cplex = new Cplex();

            instance = inst;

            //Real starting time is stored inside instance
            instance.TStart = clock.ElapsedMilliseconds / 1000.0;

            clock.Stop();
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write("\nPress enter to continue, attention: the display will be cleared");
            Console.ReadLine();
            Console.Clear();
            Console.ForegroundColor = ConsoleColor.White;

            Console.Write("Insert 1 to use the classic loop method, 2 to use the optimal branch & cut and 3 to use heuristics methods: ");

            switch (Console.ReadLine())
            {
                case "1":
                    {
                        Console.Write("\nInsert 1 for normal resolution, 2 to specifie the % precion, 3 to use only a # of the nearest edges, 4 to use both previous options: ");
                        switch (Console.ReadLine())
                        {
                            case "1":
                                {
                                    //Clock restart
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Calling the proper resolution method
                                    Loop(-1, -1);
                                    break;
                                }

                            case "2":
                                {
                                    Console.Write("\nWrite the % precision: ");
                                    //storing the percentage selected
                                    double percentage = Convert.ToDouble(Console.ReadLine());
                                    //Clock restart
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Calling the proper resolution method
                                    Loop(percentage, -1);
                                    break;
                                }

                            case "3":
                                {
                                    Console.Write("\nWrite the # of nearest edges: ");
                                    //number of nearest edges selected
                                    int numb = Convert.ToInt32(Console.ReadLine());
                                    //Clock restart
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Calling the proper resolution method
                                    Loop(-1, numb);
                                    break;
                                }

                            case "4":
                                {
                                    Console.Write("\nWrite the % precision: ");
                                    //storing the percentage selected
                                    double percentage = Convert.ToDouble(Console.ReadLine());
                                    Console.Write("Write the # of nearest edges: ");
                                    //number of nearest edges selected
                                    int numb = Convert.ToInt32(Console.ReadLine());
                                    clock.Start();
                                    //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                                    MipTimelimit(clock);
                                    //Calling the proper resolution method
                                    Loop(percentage, numb);
                                    break;
                                }

                            default:
                                throw new System.Exception("Bad argument");
                        }
                        break;
                    }

                case "2":
                    {
                        //Restarting the clock
                        clock.Start();
                        //Setting the residual time limit for cplex, it's almost equal to instance.TStart
                        MipTimelimit(clock);
                        //Calling the proper resolution method
                        CallBackMethod();
                        break;
                    }
                case "3":
                    {

                        rnd = new Random((int)DateTime.Now.Ticks & 0x0000FFFF);

                        Console.Write("\nInsert 1 to use multi start, 2 to use Tabu-Search: ");
                        switch (Console.ReadLine())
                        {
                            case "1":
                                {
                                    //Clock restart
                                    clock.Start();
                                    //Calling the proper resolution method
                                    Heuristic("2OPT");
                                    break;
                                }

                            case "2":
                                {
                                    //Clock restart
                                    clock.Start();
                                    //Calling the proper resolution method
                                    Heuristic("Tabu-Search");
                                    break;
                                }
                            default:
                                throw new System.Exception("Bad argument");
                        }
                        break;
                    }
                default:
                    throw new System.Exception("Bad argument");
            }
            return true;
        }

        //Handle the resolution method without callbacks
        static void Loop(double perc, int numb)
        {
            //epGap is false when EpGap parameter is at default
            bool epGap = false;

            //allEdges is true when all possible links have their upper bound to 1
            bool allEdges = true;

            //Setting EpGap if a valid percentage is specified
            if (perc >=0 && perc <= 1)
            {
                cplex.SetParam(Cplex.DoubleParam.EpGap, perc);

                epGap = true;

                typeSol = 0;
            }

            //numb is equal to -1 when all links upper bound are 1
            if (numb != -1)
            {
                allEdges = false;

                typeSol = 0;
            }

            //Building the maximum # of links that involves each node
            z = BuildModel(numb);

            //Allocating the correct space to store the optimal solution
            //Only links from node i to j with i < j are considered
            instance.BestSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

            //Init buffers
            compConn = new int[instance.NNodes];
            ccExpr = new List<ILinearNumExpr>();
            bufferCoeffCC = new List<int>();

            //Initialization of the process that handles GNUPlot
            process = InitProcess();


            do
            {
                //When only one related component is found and ehuristics methods are active they are disabled
                if (ccExpr.Count == 1)
                {
                    epGap = false;

                    allEdges = true;

                    cplex.SetParam(Cplex.DoubleParam.EpGap, 1e-06);

                    ResetVariables(z);

                    typeSol = 1;
                }

                //Cplex solves the current model
                cplex.Solve();

                //Initializing the arrays used to eliminate the subtour
                InitCC(compConn);

                ccExpr = new List<ILinearNumExpr>();
                bufferCoeffCC = new List<int>();

                //Init the StreamWriter for the current solution
                file = new StreamWriter(instance.InputFile + ".dat", false);

                //Storing the optimal value of the objective function
                instance.ZBest = cplex.ObjValue;

                //Blank line
                cplex.Output().WriteLine();

                //Printing the optimal solution and the GNUPlot input file
                for (int i = 0; i < instance.NNodes; i++)
                {
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {

                        //Retriving the correct index position for the current link inside z
                        int position = zPos(i, j, instance.NNodes);

                        //Reading the optimal solution for the actual link (i,j)
                        instance.BestSol[position] = cplex.GetValue(z[position]);

                        //Only links in the optimal solution (coefficient = 1) are printed in the GNUPlot file
                        if (instance.BestSol[position] >= 0.5)
                        {
                            /*
                             *Current GNUPlot format is:
                             *-- previus link --
                             *<Blank line>
                             *Xi Yi <index(i)>
                             *Xj Yj <index(j)>
                             *<Blank line> 
                             *-- next link --
                            */
                            file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                            file.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");

                            //Updating the model with the current subtours elimination
                            UpdateCC(i, j);
                        }
                    }
                }

                //Only when more than one related components are found they are added to the model
                if (ccExpr.Count > 1)
                {
                    for (int i = 0; i < ccExpr.Count; i++)
                        cplex.AddLe(ccExpr[i], bufferCoeffCC[i] - 1);
                }

                //GNUPlot input file needs to be closed
                file.Close();

                //Accessing GNUPlot to read the file
                if (Program.VERBOSE >= -1)
                    PrintGNUPlot(instance.InputFile, typeSol);

                //Blank line
                cplex.Output().WriteLine();

                //Writing the value
                cplex.Output().WriteLine("zOPT = " + instance.ZBest + "\n");

                //Exporting the updated model
                if (Program.VERBOSE >= -1)
                    cplex.ExportModel(instance.InputFile + ".lp");

            } while (ccExpr.Count > 1 || epGap || !allEdges); //if there is more then one related components the solution is not optimal 


            //Closing Cplex link
            cplex.End();

            //Accessing GNUPlot to read the file
            if (Program.VERBOSE >= -1)
                PrintGNUPlot(instance.InputFile, typeSol);
        }


        //Handle the callback resolution method
        static void CallBackMethod()
        {
            //-1 means that all links are enabled
            z = BuildModel(-1);

            //Initializing the vector
            instance.BestSol = new double[(instance.NNodes - 1) * instance.NNodes / 2];

            //Creation and initialization of the process that will handle GNUPlot
            process = InitProcess();

            // Turn on traditional search for use with control callbacks
            cplex.SetParam(Cplex.Param.MIP.Strategy.Search, Cplex.MIPSearch.Auto);

            //0 physicals, 1 virtuals
            int coreCount = RetriveCoreNumber(0);

            //Setting cplex # of threads
            cplex.SetParam(Cplex.Param.Threads, coreCount);

            //Adding lazycallback
            cplex.Use(new TSPLazyConsCallback());

            //Solving
            cplex.Solve();

            //Init the StreamWriter for the current solution
            file = new StreamWriter(instance.InputFile + ".dat", false);

            //Storing the optimal value of the objective function
            instance.ZBest = cplex.ObjValue;

            //Blank line
            cplex.Output().WriteLine();

            //Printing the optimal solution and the GNUPlot input file
            for (int i = 0; i < instance.NNodes; i++)
            {
                for (int j = i + 1; j < instance.NNodes; j++)
                {

                    //Retriving the correct index position for the current link inside z
                    int position = zPos(i, j, instance.NNodes);

                    //Reading the optimal solution for the actual link (i,j)
                    instance.BestSol[position] = cplex.GetValue(z[position]);

                    //Only links in the optimal solution (coefficient = 1) are printed in the GNUPlot file
                    if (instance.BestSol[position] >= 0.5)
                    {
                        /*
                         *Current GNUPlot format is:
                         *-- previus link --
                         *<Blank line>
                         *Xi Yi <index(i)>
                         *Xj Yj <index(j)>
                         *<Blank line> 
                         *-- next link --
                        */
                        file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                        file.WriteLine(instance.Coord[j].X + " " + instance.Coord[j].Y + " " + (j + 1) + "\n");
                    }
                }
            }

            //GNUPlot input file needs to be closed
            file.Close();

            //Accessing GNUPlot to read the file
            if (Program.VERBOSE >= -1)
                PrintGNUPlot(instance.InputFile, typeSol);

            //Blank line
            cplex.Output().WriteLine();

            //Writing the value
            cplex.Output().WriteLine("zOPT = " + instance.ZBest + "\n");

            //Exporting the updated model
            if (Program.VERBOSE >= -1)
                cplex.ExportModel(instance.InputFile + ".lp");

            
        }

        //Handle the heuristic resolution method
        static void Heuristic(string choice)
        {
            //Initialization of the process that handles GNUPlot
            process = InitProcess();

            typeSol = 0;

            zHeuristic = new int[instance.NNodes];

            switch (choice)
            {
                case "2OPT":

                    do
                    {
                        BuildRandomSolution();

                        if (incumbentDist > distHeuristic)
                        {
                            incumbentDist = distHeuristic;
                            incumbentZHeuristic = zHeuristic;

                            PrintHeuristicSolution();

                            Console.WriteLine("Incumbed changed");
                        }

                        TwoOpt();

                        if (incumbentDist > distHeuristic)
                        {
                            incumbentDist = distHeuristic;
                            incumbentZHeuristic = zHeuristic;

                            PrintHeuristicSolution();

                            Console.WriteLine("Incumbed changed");
                        }
                        else
                            Console.WriteLine("Incumbed not changed");

                        zHeuristic = new int[instance.NNodes];

                    } while (cl.ElapsedMilliseconds / 1000.0 < instance.TimeLimit);

                    break;
                case "Tabu-Search":

                    BuildRandomSolution();
                    PrintHeuristicSolution();
                    tabu = new Tabu("A", instance, 100);
                    TabuSearch();
                    zHeuristic = incumbentZHeuristic;
                    PrintHeuristicSolution();
                    TwoOpt();
                    break;
            }

            typeSol = 0;
            zHeuristic = incumbentZHeuristic;
            PrintHeuristicSolution();
            Console.WriteLine("Best distance found within the timelit is: " + distHeuristic);
        }

        static void BuildRandomSolution()
        {
            int currentIndex = 0;

            distHeuristic = 0;

            int[] availableIndexes = new int[instance.NNodes];

            for (int i = 0; i < availableIndexes.Length; i++)
                availableIndexes[i] = -1;

            availableIndexes[currentIndex] = 1;

            listArray = BuildSLComplete();

            for (int i = 0; i < instance.NNodes - 1; i++)
            {
                bool found = false;

                int plus = RndPlus();

                int nextIndex = listArray[currentIndex][0 + plus];

                do
                {

                    if (availableIndexes[nextIndex] == -1)
                    {
                        zHeuristic[currentIndex] = nextIndex;
                        distHeuristic += Point.Distance(instance.Coord[currentIndex], instance.Coord[nextIndex], instance.EdgeType);
                        availableIndexes[nextIndex] = 1;
                        currentIndex = nextIndex;
                        found = true;
                    } else
                    {
                        plus++;
                        if (plus >= instance.NNodes - 1)
                        {
                            nextIndex = listArray[currentIndex][0];
                            plus = 0;
                        }
                        else
                            nextIndex = listArray[currentIndex][0 + plus];
                    }

                } while (!found);
            }
            
            if (incumbentZHeuristic == null)
            {
                incumbentZHeuristic = zHeuristic;
                incumbentDist = distHeuristic;
            }
        }

        static int RndPlus()
        {
            double tmp = rnd.NextDouble();

            if (tmp < 0.9)
                return 0;
            else if (tmp < 0.99)
                return 1;
            else
                return 2;
        }

        static void PrintHeuristicSolution()
        {

            //Init the StreamWriter for the current solution
            file = new StreamWriter(instance.InputFile + ".dat", false);

            //Printing the optimal solution and the GNUPlot input file
            for (int i = 0; i < instance.NNodes; i++)
            {
                /*
                 *Current GNUPlot format is:
                 *-- previus link --
                 *<Blank line>
                 *Xi Yi <index(i)>
                 *Xj Yj <index(j)>
                 *<Blank line> 
                 *-- next link --
                */
                file.WriteLine(instance.Coord[i].X + " " + instance.Coord[i].Y + " " + (i + 1));
                file.WriteLine(instance.Coord[zHeuristic[i]].X + " " + instance.Coord[zHeuristic[i]].Y + " " + (zHeuristic[i] + 1) + "\n");

            }

            //GNUPlot input file needs to be closed
            file.Close();

            //Accessing GNUPlot to read the file
            if (Program.VERBOSE >= -1)
                PrintGNUPlotHeuristic(instance.InputFile, typeSol);
        }

        static void TwoOpt()
        {
            int indexStart = 0;
            int cnt = 0;
            bool found = false;

            do
            {
                found = false;
                int a = indexStart;
                int b = zHeuristic[a];
                int c = zHeuristic[b];
                int d = zHeuristic[c];

                for (int i = 0; i < instance.NNodes - 3; i++)
                {
                    double distAC = Point.Distance(instance.Coord[a], instance.Coord[c], instance.EdgeType);
                    double distBD = Point.Distance(instance.Coord[b], instance.Coord[d], instance.EdgeType);
                    double distAD = Point.Distance(instance.Coord[a], instance.Coord[d], instance.EdgeType);
                    double distBC = Point.Distance(instance.Coord[b], instance.Coord[c], instance.EdgeType);

                    double distTotABCD = Point.Distance(instance.Coord[a], instance.Coord[b], instance.EdgeType) +
                        Point.Distance(instance.Coord[c], instance.Coord[d], instance.EdgeType);

                    if (distAC + distBD < distTotABCD)
                    {
                        SwapRoute(c, b);

                        zHeuristic[a] = c;
                        zHeuristic[b] = d;

                        distHeuristic = distHeuristic - distTotABCD + distAC + distBD;

                        indexStart = 0;
                        cnt = 0;
                        found = true;
                        break;
                    }

                    c = d;
                    d = zHeuristic[c];
                }

                if (!found)
                {
                    indexStart = b;
                    cnt++;
                }

            } while (cnt < instance.NNodes);
        }

        static void TabuSearch()
        {
            int indexStart = 0;
            string nextBestMove = "";
            string nextWorstMove = "";
            double bestGain = double.MaxValue;
            double worstGain = double.MinValue;
            int a, b, c, d;
            double distAC, distBD, distTotABCD;

            do
            {
                for (int j = 0; j < instance.NNodes; j++, indexStart = b)
                {
                    a = indexStart;
                    b = zHeuristic[a];
                    c = zHeuristic[b];
                    d = zHeuristic[c];

                    for (int i = 0; i < instance.NNodes - 3; i++, c = d, d = zHeuristic[c])
                    {
                        if (!tabu.IsTabu(a, c) && !tabu.IsTabu(b, d))
                        {
                            distAC = Point.Distance(instance.Coord[a], instance.Coord[c], instance.EdgeType);
                            distBD = Point.Distance(instance.Coord[b], instance.Coord[d], instance.EdgeType);

                            distTotABCD = Point.Distance(instance.Coord[a], instance.Coord[b], instance.EdgeType) +
                                Point.Distance(instance.Coord[c], instance.Coord[d], instance.EdgeType);

                            if ((distAC + distBD) - distTotABCD < bestGain && (distAC + distBD) != distTotABCD)
                            {
                                nextBestMove = a + ";" + b + ";" + c + ";" + d;
                                bestGain = (distAC + distBD) - distTotABCD;
                            }

                            if ((distAC + distBD) - distTotABCD > worstGain && (distAC + distBD) != distTotABCD)
                            {
                                nextWorstMove = a + ";" + b + ";" + c + ";" + d;
                                worstGain = (distAC + distBD) - distTotABCD;
                            }
                        }
                    }
                }

                if (true)
                {

                    string[] currentElements = nextBestMove.Split(';');
                    a = int.Parse(currentElements[0]);
                    b = int.Parse(currentElements[1]);
                    c = int.Parse(currentElements[2]);
                    d = int.Parse(currentElements[3]);

                    SwapRoute(c, b);

                    zHeuristic[a] = c;
                    zHeuristic[b] = d;

                    distHeuristic += bestGain;

                    if (incumbentDist > distHeuristic)
                    {
                        incumbentDist = distHeuristic;
                        incumbentZHeuristic = zHeuristic;
                    }

                    if (bestGain < 0)
                        typeSol = 0;
                    else
                    {
                        tabu.AddTabu(a, b, c, d);
                        typeSol = 1;
                    }

                }
                else
                {

                    string[] currentElements = nextWorstMove.Split(';');
                    a = int.Parse(currentElements[0]);
                    b = int.Parse(currentElements[1]);
                    c = int.Parse(currentElements[2]);
                    d = int.Parse(currentElements[3]);

                    SwapRoute(c, b);

                    zHeuristic[a] = c;
                    zHeuristic[b] = d;

                    distHeuristic += worstGain;

                    tabu.AddTabu(a, b, c, d);
                    typeSol = 1;

                }

                PrintHeuristicSolution();

                bestGain = double.MaxValue;
                worstGain = double.MinValue;

            } while (cl.ElapsedMilliseconds / 1000.0 < instance.TimeLimit);
        }

        //not working
        static void ThreeOpt()
        {
            int indexStart = 0;
            int cnt = 0;
            bool found = false;

            do
            {
                found = false;
                int a = indexStart;
                int b = zHeuristic[a];
                int c = zHeuristic[b];
                int d = zHeuristic[c];
                int e = zHeuristic[d];
                int f = zHeuristic[e];

                for (int i = 0; i < instance.NNodes -2; i++)
                {
                    while (c == a && d == b)
                    {
                        c = d;
                        d = zHeuristic[c];
                    }

                    for (int j = 0; j < instance.NNodes -2 - i; j++)
                    {

                        while (e == a && f == b || e == c && f == d)
                        {
                            e = f;
                            f = zHeuristic[e];
                        }

                        double distAB = Point.Distance(instance.Coord[a], instance.Coord[b], instance.EdgeType);
                        double distAC = Point.Distance(instance.Coord[a], instance.Coord[c], instance.EdgeType);
                        double distAD = Point.Distance(instance.Coord[a], instance.Coord[d], instance.EdgeType);
                        double distAE = Point.Distance(instance.Coord[a], instance.Coord[e], instance.EdgeType);
                        double distCD = Point.Distance(instance.Coord[c], instance.Coord[d], instance.EdgeType);
                        double distCE = Point.Distance(instance.Coord[c], instance.Coord[e], instance.EdgeType);
                        double distCF = Point.Distance(instance.Coord[c], instance.Coord[f], instance.EdgeType);
                        double distEF = Point.Distance(instance.Coord[e], instance.Coord[f], instance.EdgeType);
                        double distEB = Point.Distance(instance.Coord[e], instance.Coord[b], instance.EdgeType);
                        double distDF = Point.Distance(instance.Coord[d], instance.Coord[f], instance.EdgeType);
                        double distBD = Point.Distance(instance.Coord[b], instance.Coord[d], instance.EdgeType);
                        double distBF = Point.Distance(instance.Coord[b], instance.Coord[f], instance.EdgeType);

                        double distTotABCDEF = distAB + distCE +distEF;

                        double minDist = distTotABCDEF;
                        string minRoute = "ABCDEF";

                        if(distAB + distCE + distDF < minDist)
                        {
                            minDist = distAB + distCE + distDF;
                            minRoute = "ABCEDF";
                        }

                        if (distAE + distCF + distBD < minDist)
                        {
                            minDist = distAE + distCF + distBD;
                            minRoute = "AEDBCF";
                        }

                        if (distAC + distEB + distDF < minDist)
                        {
                            minDist = distAC + distEB + distDF;
                            minRoute = "ACBEDF";
                        }

                        if (distAD + distCF + distEB < minDist)
                        {
                            minDist = distAD + distCF + distEB;
                            minRoute = "ADEBCF";
                        }

                        if (distAC + distBD + distEF < minDist)
                        {
                            minDist = distAC + distBD + distEF;
                            minRoute = "ACBDEF";
                        }

                        if (distAE + distBF + distCD < minDist)
                        {
                            minDist = distAE + distBF + distCD;
                            minRoute = "AEDCBF";
                        }

                        if (distAD + distCE + distEB < minDist)
                        {
                            minDist = distAD + distCE + distEB;
                            minRoute = "ADECBF";
                        }



                        if(minRoute == "ABCDEF")
                        {

                        }else if(minRoute == "ABCEDF")
                        {
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, f, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[c] = e;
                            zHeuristic[d] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAB + distCE + distDF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;
                        }
                        else if (minRoute == "AEDBCF")
                        {
                            instance.BestSol[zPos(a, b, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(a, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(c, f, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, b, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[a] = e;
                            zHeuristic[d] = b;
                            zHeuristic[c] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAE + distBD + distCF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;

                        }
                        else if (minRoute == "ACBEDF")
                        {
                            instance.BestSol[zPos(a, b, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(a, c, instance.NNodes)] = 1;
                            instance.BestSol[zPos(b, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, f, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[c] = e;
                            zHeuristic[d] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAB + distCE + distDF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;

                        }
                        else if (minRoute == "ADEBCF")
                        {
                            instance.BestSol[zPos(a, b, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, f, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[c] = e;
                            zHeuristic[d] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAB + distCE + distDF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;

                        }
                        else if (minRoute == "ACBDEF")
                        {
                            instance.BestSol[zPos(a, b, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, f, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[c] = e;
                            zHeuristic[d] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAB + distCE + distDF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;

                        }
                        else if (minRoute == "AEDCBF")
                        {
                            instance.BestSol[zPos(a, b, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, f, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[c] = e;
                            zHeuristic[d] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAB + distCE + distDF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;

                        }
                        else if (minRoute == "ADECBF")
                        {
                            instance.BestSol[zPos(a, b, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, d, instance.NNodes)] = 0;
                            instance.BestSol[zPos(e, f, instance.NNodes)] = 0;
                            instance.BestSol[zPos(c, e, instance.NNodes)] = 1;
                            instance.BestSol[zPos(d, f, instance.NNodes)] = 1;

                            SwapRoute(d, e);

                            zHeuristic[c] = e;
                            zHeuristic[d] = f;

                            distHeuristic = distHeuristic - distTotABCDEF + distAB + distCE + distDF;

                            indexStart = 0;
                            cnt = 0;
                            found = true;

                            //PrintHeuristicSolution();
                            break;

                        }

                        c = d;
                        d = zHeuristic[c];
                    }

                    if (!found)
                    {
                        indexStart = b;
                        cnt++;
                    }
                }

            } while (cnt < instance.NNodes);
        }

        static void SwapRoute(int c, int b)
        {
            int from = b;
            int to = zHeuristic[from];
            do
            {
                int tmpTo = zHeuristic[to];
                zHeuristic[to] = from;
                from = to;
                to = tmpTo;
            } while (from != c);
        }

        //Setting Upper Bounds of each cplex model's variable to 1
        static void ResetVariables(INumVar[] z)
        {
            for (int i = 0; i < z.Length; i++)
                z[i].UB = 1;
        }

        //Computing the nearest edges for each node
        static List<int>[] BuildSL()
        {
            //SL and L stores the information regarding the nearest edges for each node 
            List<itemList>[] SL = new List<itemList>[instance.NNodes];
            List<int>[] L = new List<int>[instance.NNodes];

            for (int i = 0; i < SL.Length; i++)
            {
                SL[i] = new List<itemList>();

                for (int j = i + 1; j < SL.Length; j++)
                {
                    //Simply adding each possible links with its distance
                    if (i != j)
                        SL[i].Add(new itemList(Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType), j));
                }

                //Sorting the list
                SL[i] = SL[i].OrderBy(itemList => itemList.dist).ToList<itemList>();
                //Only the index of the nearest nodes are relevants
                L[i] = SL[i].Select(itemList => itemList.index).ToList<int>();
            }

            return L;
        }

        static List<int>[] BuildSLComplete()
        {
            //SL and L stores the information regarding the nearest edges for each node 
            List<itemList>[] SL = new List<itemList>[instance.NNodes];
            List<int>[] L = new List<int>[instance.NNodes];

            for (int i = 0; i < SL.Length; i++)
            {
                SL[i] = new List<itemList>();

                for (int j = 0; j < SL.Length; j++)
                {
                    //Simply adding each possible links with its distance
                    if (i != j)
                        SL[i].Add(new itemList(Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType), j));
                }

                //Sorting the list
                SL[i] = SL[i].OrderBy(itemList => itemList.dist).ToList<itemList>();
                //Only the index of the nearest nodes are relevants
                L[i] = SL[i].Select(itemList => itemList.index).ToList<int>();
            }

            return L;
        }


        //Building initial model
        static INumVar[] BuildModel(int n)
        {

            //When n is equal to -1 all links have their upper bound to 1, listArray is not needed
            if (n != -1)
                listArray = BuildSL();

            //Init the model's variables
            INumVar[] z = new INumVar[(instance.NNodes - 1) * instance.NNodes / 2];

            /*
             *expr will hold all the expressions that needs to be added to the model
             *initially it will be the optimality's functions
             *later it will be Ax's rows 
            */
            ILinearNumExpr expr = cplex.LinearNumExpr();


            //Populating objective function
            for (int i = 0; i < instance.NNodes; i++)
            {
                if (n >= 0)
                {
                    //Only links (i,j) with i < j are correct
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {
                        //zPos return the correct position where to store the variable corresponding to the actual link (i,j)
                        int position = zPos(i, j, instance.NNodes);
                        if ((listArray[i]).IndexOf(j) < n)
                            z[position] = cplex.NumVar(0, 1, NumVarType.Int, "z(" + (i + 1) + "," + (j + 1) + ")");
                        else
                            z[position] = cplex.NumVar(0, 0, NumVarType.Int, "z(" + (i + 1) + "," + (j + 1) + ")");
                        expr.AddTerm(z[position], Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType));
                    }
                }
                else
                {
                    //Only links (i,j) with i < j are correct
                    for (int j = i + 1; j < instance.NNodes; j++)
                    {
                        //zPos return the correct position where to store the variable corresponding to the actual link (i,j)
                        int position = zPos(i, j, instance.NNodes);
                        z[position] = cplex.NumVar(0, 1, NumVarType.Int, "z(" + (i + 1) + "," + (j + 1) + ")");
                        expr.AddTerm(z[position], Point.Distance(instance.Coord[i], instance.Coord[j], instance.EdgeType));
                    }
                }
            }

            //Setting the optimality's function
            cplex.AddMinimize(expr);


            //Starting to elaborate Ax
            for (int i = 0; i < instance.NNodes; i++)
            {
                //Resetting expr
                expr = cplex.LinearNumExpr();

                for (int j = 0; j < instance.NNodes; j++)
                {
                    //For each row i only the links (i,j) or (j,i) have coefficent 1
                    //zPos return the correct position where link is stored inside the vector z
                    if (i != j)//No loops wioth only one node
                        expr.AddTerm(z[zPos(i, j, instance.NNodes)], 1);
                }

                //Adding to Ax the current equation with known term 2 and name degree(<current i node>)
                cplex.AddEq(expr, 2, "degree(" + (i + 1) + ")");
            }

            //Printing the complete model inside the file <name_file.tsp.lp>
            if (Program.VERBOSE >= -1)
                cplex.ExportModel(instance.InputFile + ".lp");

            return z;

        }


        //Print for GNUPlot
        static void PrintGNUPlot(string name, int typeSol)
        {
            //typeSol == 1 => red lines, TypeSol == 0 => blue Lines
            if (typeSol == 0)
                process.StandardInput.WriteLine("set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 5 ps 0.5\nplot '" + name + ".dat' with linespoints ls 1 notitle, '" + name + ".dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle");
            else if (typeSol == 1)
                process.StandardInput.WriteLine("set style line 1 lc rgb '#ad0000' lt 1 lw 1 pt 5 ps 0.5\nplot '" + name + ".dat' with linespoints ls 1 notitle, '" + name + ".dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle");
        }

        static void PrintGNUPlotHeuristic(string name, int typeSol)
        {
            //typeSol == 1 => red lines, TypeSol == 0 => blue Lines
            if (typeSol == 0)
                process.StandardInput.WriteLine("set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 5 ps 0.5\nset title \"Current best solution: " + incumbentDist + "   Current solution: " + distHeuristic + "\"\nplot '" + name + ".dat' with linespoints ls 1 notitle, '" + name + ".dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle");
            else if (typeSol == 1)
                process.StandardInput.WriteLine("set style line 1 lc rgb '#ad0000' lt 1 lw 1 pt 5 ps 0.5\nset title \"Current best solution: " + incumbentDist + "   Current solution: " + distHeuristic + "\"\nplot '" + name + ".dat' with linespoints ls 1 notitle, '" + name + ".dat' using 1:2:3 with labels point pt 7 offset char 0,0.5 notitle");
        }


        //Returns physical or virtual cores of the pc
        static int RetriveCoreNumber(int type)
        {
            if (type == 0)
            {
                int coreCount = 0;

                foreach (var item in new System.Management.ManagementObjectSearcher("Select NumberOfCores from Win32_Processor").Get())
                {
                    coreCount += int.Parse(item["NumberOfCores"].ToString());
                }

                return coreCount;
            }
            else
                return Environment.ProcessorCount;
        }


        //Used to evaluete the correct position to store and read the variables for the model
        static int zPos(int i, int j, int nNodes)
        {
            if (i == j)
                return -1;

            if (i > j)
                return zPos(j, i, nNodes);

            return i * nNodes + j - (i + 1) * (i + 2) / 2;
        }

        static int[] zPosInv(int index, int nNodes)
        {
            //int i = 0;
            //int cnt = 1;
            //int sup = nNodes - cnt;
            //while(index > sup)
            //{
            //    cnt++;
            //    sup += nNodes - cnt; 
            //}

            //i = cnt - 1;

            //int j = index + (i + 1) * (i + 2) / 2 - i * nNodes;

            //if (zPos(i, j, nNodes) != index)
            //    Console.WriteLine("Sono un coglione. Juve merda");

            for(int i=0; i<nNodes;i++)
            {
                for(int j=i+1;j<nNodes;j++)
                    if(zPos(i,j,nNodes) == index)
                        return new int[] { i, j };
            }

            return null;

            //return new int[] { i, j };
        }


        //Setting the current real residual time for Cplex and some relative parameters
        static void MipTimelimit(Stopwatch clock)
        {
            double residualTime = instance.TStart + instance.TimeLimit - clock.ElapsedMilliseconds / 1000.0;

            if (residualTime < 0.0)
                residualTime = 0.0;

            cplex.SetParam(Cplex.IntParam.ClockType, 2);
            cplex.SetParam(Cplex.Param.TimeLimit, residualTime);                            // real time
            cplex.SetParam(Cplex.Param.DetTimeLimit, Program.TICKS_PER_SECOND * cplex.GetParam(Cplex.Param.TimeLimit));			// ticks
        }


        //Initialization of the arrays used to keep track of the related components
        static void InitCC(int[] cc)
        {
            for (int i = 0; i < cc.Length; i++)
            {
                cc[i] = i;
            }
        }


        //Updating the related components for the current solution
        static void UpdateCC(int i, int j)
        {
            if (compConn[i] != compConn[j])//Same related component, the latter is not closed yet
            {
                for (int k = 0; k < compConn.Length; k++)// k>i poichè i > j
                {
                    if ((k != j) && (compConn[k] == compConn[j]))
                    {
                        //Same as Kruskal
                        compConn[k] = compConn[i];
                    }
                }

                //Finally also the vallue relative to the Point j are updated
                compConn[j] = compConn[i];
            }
            else//Here the current releted component is complete and the relative subtout elimination constraint can be added to the model
            {
                ILinearNumExpr expr = cplex.LinearNumExpr();

                //cnt stores the # of nodes of the current related components
                int cnt = 0;

                for (int h = 0; h < compConn.Length; h++)
                {
                    //Only nodes of the current related components are considered
                    if (compConn[h] == compConn[i])
                    {
                        //Each link involving the node with index h is analized
                        for (int k = h + 1; k < compConn.Length; k++)
                        {
                            //Testing if the link is valid
                            if (compConn[k] == compConn[i])
                            {
                                //Adding the link to the expression with coefficient 1
                                expr.AddTerm(z[zPos(h, k, compConn.Length)], 1);
                            }
                        }

                        cnt++;
                    }
                }

                //Adding the objects to the buffers
                ccExpr.Add(expr);
                bufferCoeffCC.Add(cnt);                
            }
        }

        //Creation of the process used to interect with GNUPlot
        static Process InitProcess ()
        {
            //Setting values to open Prompt
            ProcessStartInfo processStartInfo = new ProcessStartInfo("cmd.exe");
            processStartInfo.RedirectStandardInput = true;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.UseShellExecute = false;

            //Executing the Prompt
            Process process = Process.Start(processStartInfo);

            Object Width = SystemInformation.VirtualScreen.Width;
            Object Height = SystemInformation.VirtualScreen.Height;

            //Enabling GNUPlot commands
            process.StandardInput.WriteLine("gnuplot\nset terminal wxt size {0},{1}\nset lmargin at screen 0.05\nset rmargin at screen 0.95\nset bmargin at screen 0.1\nset tmargin at screen 0.9\nset xrange [{2}:{3}]\nset yrange [{4}:{5}]", Convert.ToDouble(Width.ToString()) - 100, Convert.ToDouble(Height.ToString()) - 100, instance.XMin, instance.XMax, instance.YMin, instance.YMax);

            return process;
        }

        private class Tabu
        {
            string mode;
            string originalMode;
            List<string> tabuVector;
            Instance inst;
            int threshold;

            public Tabu (string mode, Instance inst, int threshold)
            {
                this.mode = mode;
                this.originalMode = mode;
                this.inst = inst;
                this.threshold = threshold;
                this.tabuVector = new List<string>();
            }

            public bool IsTabu(int a, int b)
            {
                if (tabuVector.Contains(a + ";" + b) ||
                    tabuVector.Contains(b + ";" + a))
                    return true;
                else
                    return false;
            }

            public void AddTabu(int a, int b, int c, int d)
            {
                if (mode == "A" && tabuVector.Count >= (threshold - 1))
                {
                    mode = "B";

                }else if(mode == "B")
                {
                    if (tabuVector.Count >= 50)
                    {
                        for (int i = 0; i < 10; i++)
                        {
                            tabuVector.RemoveAt(i);
                        }
                    }
                    else
                        mode = "A";
                }

                if(!tabuVector.Contains(a + ";" + b))
                    tabuVector.Add(a + ";" + b);
                if(!tabuVector.Contains(c + ";" + d))
                    tabuVector.Add(c + ";" + d);
            }

            public void Clear()
            {
                mode = originalMode;
                tabuVector.Clear();
            }

            public int TabuLenght()
            {
                return tabuVector.Count;
            }
        }

    }
}
    
